# Binding classes

This chapter introduces the classes that Python scripts can use in Birdee. We use Python type hint syntax to show the members of the classes.

## Error classes

```python
class CompileError:
	linenumber: int #readonly, the line number of the error
	pos: int #readonly, the position of characters in the line
	msg: str #readwrite, the error message
```
The compile error that was actually raised. It can be got from function `get_compile_error`. 

```python
class TokenizerError:
	linenumber: int #readonly, the line number of the error
	pos: int #readonly, the position of characters in the line
	msg: str #readwrite, the error message
```
The compile error that was actually raised. It can be got from function `get_tokenizer_error`.

## Containers and Ownership pointers

### Ownership pointer

```python
class SOMEUniquePtr:
	def get() -> SOME
```
The ownership pointer of the AST class `SOME`. `SOME` above can be replaced by some AST node classes, which can be `StatementAST`, etc. This UniquePtr class represents the ownership of an AST node. If the ownership is not transfered to another AST node, the AST node will be destroyed when Python runtime reclaim the memory of this ownership pointer object. A reference to AST node is a pointer that has no ownership of the node. You can use `get()` on a ownership pointer to get the reference of the AST node. You cannot get fields or call member functions directly on ownership pointers. Instead, you can operate on a reference by calling `get()`. For more information, please refer to the "Compile time scripts" chapter of Birdee language manual.

For most of the sub-classes of StatementAST and ExprAST, if you get a field of them with type `StatementAST`, you will get a reference. If you assign a value to the `StatementAST` typed fields, you usually need a `StatementASTUniquePtr` and the field will take over the ownership.

### List

```python
class SOMEList:
	def pop_back(): ... # remove the last item
	def push_back(itm: SOMEUniquePtr): ... # append an item to the list, will take the owner ship of the itm
	def __getitem__(idx: int): ...
	def __setitem__(idx: int, itm: SOMEUniquePtr): ... #will take the ownership of the itm
	def __len__() -> int: ...
	def __iter__(): ...
```
A list of AST nodes. `SOME` above can be replaced by some AST node classes, which can be `MemberFunctionDef`, `FieldDef`, etc. You can use the list as a normal Python list. The `[...]` and `for ... in ...` are allowed on AST node lists. 

##  AST classes

### BasicType

```python
class BasicType(Enum):
	CLASS
	NULL
	FUNC
	VOID
	BYTE
	INT
	LONG
	ULONG
	UINT
	FLOAT
	DOUBLE
	BOOLEAN
	POINTER
	PACKAGE
```

It is an enum which represents the basic types.

### ResolvedType

```python
class ResolvedType:
	base: BasicType # readonly, the base type of the resolved type
	index_level: int # readwrite, is it an array? 0 for not array, 1 for 1D array and so on
	def is_class() -> bool: ... # if it is a class (not struct)
	def is_integer() -> bool: ... # if it is an integer
	def get_detail() -> ???: ... # get the detailed info of the type. See comments below.
	def set_detail(_base: BasicType, detail): ... # set the basic type and details
	def __init__():...
	def __str__() -> str: ... # convert the type into a string
	def __eq__(other: ResolvedType) -> bool: ... # if another type is equal to this
```

The internal class that represents a resolved type. It basically contains three parts.
 * `base` is the base type of the type. If it is a basic type (e.g. int), this field should be a enum value (e.g. `BasicType.INT`). If the type is a class/struct, this field should be `BasicType.CLASS`. The detailed ClassAST of the referenced class can be found by `detail`. If the base type is a `BasicType.FUNC`, the type is a functype or closure.
 * `index_level` is the dimension of the array. If it is 0, the type is not an array. If it is larger than 0, the type is a `index_level`-D array of type specified by `base`.
 * `detail` is the detailed information of the type. If the type is a class/struct type, `get_detail()` will return a reference to ClassAST of the referenced class. If the type is a functype or closure, `get_detail()` will return a reference to PrototypeAST.


### SourcePos

```python
class SourcePos:
	source_idx: int #readwrite, a unique index for the source file name
	line: int #readwrite, the line number
	pos: int #readwrite, the position of characters in the line
```
This class represents a position in the source code. Most of the AST nodes contains a SourcePos object to mark the position of the AST in the source file.


### PrototypeAST

```python
class PrototypeAST:
	prefix: str # readonly. returns the symbol prefix of the Function definition. 
	# For example, if the function is defined in a module "com.a", the prefix should be "com.a." 
	name: str # readwrite. the function name or function type name
	return_type: ResolvedType # readwrite. The return type of the function
	args: VariableSingleDefASTList # readonly. The argument definitions
	is_closure: bool # readwrite. if the function is a closure
	cls: ClassAST # readwrite. The class where the function is defined. Can be None if is not a member function
```
This class holds the information of a function type (functype or closure). It also holds information of a function definition.

### Template Parameters and Arguments

Birdee's function and class templates can have placeholders for types and constant values. The placeholders which are declared in the template definition is called "template parameters" in Birdee compiler. For example, the class

```vb
class Templ[T1,T2, v as int]

end
```

has three template parameters, namely T1, T2 and v. The first two are type paramters and the last is constant value parameter. In Python binding, you can access the parameters via the `TemplateParameter`, `TemplateParameters_ClassAST` and `TemplateParameters_FunctionAST`.

The class `TemplateParameter` represents one single template parameter. `TemplateParameters_ClassAST` and `TemplateParameters_FunctionAST` are the template parameter lists for classes and functions

```python
class TemplateParameter:
	type: BasicType # readonly. It is CLASS if the template parameter is a type parameter
	# Otherwise, it is a constant value parameter with the type
	name: str # readwrite. The name of the parameter 

class TemplateParameters_ClassAST: #TemplateParameters_FunctionAST is the same
	params: TemplateParameterList # readonly
	source: str # readonly. The source code of the template
```


On the other hand, the template arguments are the acutal types/values that are given to the templates when using an instance of template.

```python
class TemplateArgument:
	class TemplateArgumentType(Enum):
		TEMPLATE_ARG_TYPE
		TEMPLATE_ARG_EXPR

	kind: TemplateArgumentType # readwrite, the kind of the argument, type? value?
	resolved_type: ResolvedType # readwrite. The resolved type for the type argument or the value
	expr: StatementAST # readwrite. The value expression of the argument. Writing to it needs an ownership pointer and will take the ownership of it

```

### AST base classes

```python
class StatementAST:
	pos: SourcePos # readwrite
	def run(func): ... # run a function "func" on the sub AST nodes of this node

class ExprAST(StatementAST):
	resolved_type: ResolvedType #readwrite, the type of the expression
	def is_lvalue() -> bool: ... # returns true if the expression is an LValue (has an address)
```

These two classes are super classes for most of the AST nodes.

### FunctionAST

This class represents a function definition (with body), or a function declaration (without body).

```python
class FunctionAST(ExprAST):
	body: StatementASTList # readonly, the list of statement AST of the body of the function
	proto: PrototypeAST # readonly, the prototype of the function
	capture_on_stack: bool # readwrite, if the captured variables of the function is stored on stack
	is_declare: bool # readwrite, if the function is a declaration or imported from other module
	is_template_instance: bool # readwrite, if the function is an instance of template function
	is_imported: bool # readwrite, if the function is imported from other modules
	template_instance_args: TemplateArgumentList # readonly, if is an template instance, the template argument list; Otherwise None
	template_source_func: FunctionAST # readonly, if is an template instance, the source template function; Otherwise None
	capture_this: bool # readwrite, if the function captures "this"
	is_template: bool # readonly, if the function is a template function
	parent: FunctionAST # readonly, if is an closure function, the function that contains the current function; Otherwise None
	link_name: str # readwrite, the link-time name for the function. 
	# Specifiled by the "alias" clause of function definition
	template_param: TemplateParameters_FunctionAST # readonly, if is a template function, the template parameters; Otherwise, None
```

Work in progress.

```C++
		py::class_<AnnotationStatementAST, StatementAST>(m, "AnnotationStatementAST")
		.def_static("new", [](vector<string>&& anno, UniquePtrStatementAST& impl) {
			return new UniquePtrStatementAST(std::make_unique< AnnotationStatementAST>(std::move(anno), impl.move()));
		})
		.def_readwrite("is_expr", &AnnotationStatementAST::is_expr)
		.def_readwrite("anno",&AnnotationStatementAST::anno)
		.def_property("impl", [](AnnotationStatementAST& ths) {return GetRef(ths.impl); },
			[](AnnotationStatementAST& ths, UniquePtrStatementAST& impl) {ths.impl = impl.move(); })
		.def("run", [](AnnotationStatementAST& ths, py::object& func) {func(GetRef(ths.impl)); });

```