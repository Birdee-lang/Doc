{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Birdee is a new programming language with C++-level performance and with light-weighted managed runtime. Language mannual Please follow the links in the navigation bar. Getting Birdee Building Birdee from scratch Please follow the instructions in the link . Pre-compiled Birdee Please follow the link to download the pre-built Birdee. For Windows version, just unzip and add the unzipped directory to the environment variable as BIRDEE_HOME . In the directory pointed by BIRDEE_HOME , there should be directories named bin , pylib , blib and src . Also, Birdee compiler depends on a specific version of Python (e.g. 3.7). For Linux Debian systems, use sudo dpkg -i birdee_xxxx.deb to install and sudo dpkg -r birdee to remove. This package requires libpython3.7-dev, libgc-dev and LLVM-6.0 to be installed. Remember to add /usr/bin/birdee0.1 to the environment variable as BIRDEE_HOME . What's in the Birdee toolkit? Birdee provides several useful tools to help develop Birdee programs. Birdee compiler The compiler compiles a single Birdee module source file (*.bdm) into an native object file (*.o or *.obj) or LLVM IR file. The outcome of the compiler can be further linked into an executable file by external linkers (e.g. ld on Linux, link.exe of MSVC). Please note that Birdee compiler alone will not help you link the Birdee modules. You should link the modules by yourself or by the auto-building tool \"bbuild\". For more information on the compiler command line arguments, please refer to here . Besides the object files, the Birdee compiler will generate an meta-data file (*.bmm), for the compiled module, which is in JSON format. It contains information on the exported variables, classes and the function definitions of the module. This overcomes the issue that native object files will lose the important meta-data of the source code. Birdee auto-building tool - bbuild bbuild is a Python-based auto-building tool provided by Birdee, to compile multiple Birdee modules and optionally link them into an executable/shared object file. It can Parse the import dependency of the Birdee modules, and automatically find the source code (or compiled object files) of dependent modules. Automatically compile the modules from the source files. Optionally link the object files into an executable/shared object file For more information on bbuild, please follow the link . Birdee playground (REPL) To help to learn Birdee language and try Birdee programs, we provide a playground program, where you can simply type Birdee code and instantly see the results without compiling the whole program using the compiler. For each line of code you input, the playground will compile and execute it and prints the execution results on the console. Please follow the link to try it. Tips on running compiled Birdee programs On Linux, a compiled Birdee application has an additional dependency on libgc. Please make sure it is installed on the system where the application runs. Run Birdee programs on Windows! To run Birdee programs that are compiled with Birdee compiler on Windows, make sure \"gc_64.dll\" is in DLL search path (e.g. where the \".exe\" file is). If you use exceptions in your Birdee program, make sure \"libgcc_s_seh-1.dll\" and \"libwinpthread-1.dll\" are also in DLL search path. If you use the pre-compiled binaries of Birdee, these DLLs can be found in the \"bin\" directory. These DLL files can also be downloaded via the following links. BaiduYun or GoogleDrive . Note that \"libgcc_s_seh-1.dll\" and \"libwinpthread-1.dll\" are extracted from mingw64.","title":"Welcome"},{"location":"#welcome","text":"Birdee is a new programming language with C++-level performance and with light-weighted managed runtime.","title":"Welcome"},{"location":"#language-mannual","text":"Please follow the links in the navigation bar.","title":"Language mannual"},{"location":"#getting-birdee","text":"","title":"Getting Birdee"},{"location":"#building-birdee-from-scratch","text":"Please follow the instructions in the link .","title":"Building Birdee from scratch"},{"location":"#pre-compiled-birdee","text":"Please follow the link to download the pre-built Birdee. For Windows version, just unzip and add the unzipped directory to the environment variable as BIRDEE_HOME . In the directory pointed by BIRDEE_HOME , there should be directories named bin , pylib , blib and src . Also, Birdee compiler depends on a specific version of Python (e.g. 3.7). For Linux Debian systems, use sudo dpkg -i birdee_xxxx.deb to install and sudo dpkg -r birdee to remove. This package requires libpython3.7-dev, libgc-dev and LLVM-6.0 to be installed. Remember to add /usr/bin/birdee0.1 to the environment variable as BIRDEE_HOME .","title":"Pre-compiled Birdee"},{"location":"#whats-in-the-birdee-toolkit","text":"Birdee provides several useful tools to help develop Birdee programs.","title":"What's in the Birdee toolkit?"},{"location":"#birdee-compiler","text":"The compiler compiles a single Birdee module source file (*.bdm) into an native object file (*.o or *.obj) or LLVM IR file. The outcome of the compiler can be further linked into an executable file by external linkers (e.g. ld on Linux, link.exe of MSVC). Please note that Birdee compiler alone will not help you link the Birdee modules. You should link the modules by yourself or by the auto-building tool \"bbuild\". For more information on the compiler command line arguments, please refer to here . Besides the object files, the Birdee compiler will generate an meta-data file (*.bmm), for the compiled module, which is in JSON format. It contains information on the exported variables, classes and the function definitions of the module. This overcomes the issue that native object files will lose the important meta-data of the source code.","title":"Birdee compiler"},{"location":"#birdee-auto-building-tool-bbuild","text":"bbuild is a Python-based auto-building tool provided by Birdee, to compile multiple Birdee modules and optionally link them into an executable/shared object file. It can Parse the import dependency of the Birdee modules, and automatically find the source code (or compiled object files) of dependent modules. Automatically compile the modules from the source files. Optionally link the object files into an executable/shared object file For more information on bbuild, please follow the link .","title":"Birdee auto-building tool - bbuild"},{"location":"#birdee-playground-repl","text":"To help to learn Birdee language and try Birdee programs, we provide a playground program, where you can simply type Birdee code and instantly see the results without compiling the whole program using the compiler. For each line of code you input, the playground will compile and execute it and prints the execution results on the console. Please follow the link to try it.","title":"Birdee playground (REPL)"},{"location":"#tips-on-running-compiled-birdee-programs","text":"On Linux, a compiled Birdee application has an additional dependency on libgc. Please make sure it is installed on the system where the application runs.","title":"Tips on running compiled Birdee programs"},{"location":"#run-birdee-programs-on-windows","text":"To run Birdee programs that are compiled with Birdee compiler on Windows, make sure \"gc_64.dll\" is in DLL search path (e.g. where the \".exe\" file is). If you use exceptions in your Birdee program, make sure \"libgcc_s_seh-1.dll\" and \"libwinpthread-1.dll\" are also in DLL search path. If you use the pre-compiled binaries of Birdee, these DLLs can be found in the \"bin\" directory. These DLL files can also be downloaded via the following links. BaiduYun or GoogleDrive . Note that \"libgcc_s_seh-1.dll\" and \"libwinpthread-1.dll\" are extracted from mingw64.","title":"Run Birdee programs on Windows!"},{"location":"Birdee Language Mannual/0010HelloWorld/","text":"1. Hello world! Our first Birdee program prints a line of words \"Hello world\" on the console. Create a file named \"hello.bdm\", and write a simple line of code in the file: println( Hello world ) Then switch to the directory of the file \"hello.bdm\" and compile it with command in Linux: python $BIRDEE_HOME/pylib/bbuild.py -le ./hello -i . -o . hello If you are using Windows, you should run the following command in Visual Studio x64 Commmand Prompt. (You can find it in the Visual Studio directory of the start menu.) python %BIRDEE_HOME%\\pylib\\bbuild.py -le .\\hello.exe -i . -o . hello \"bbuild.py\" is a high-level tool for Birdee source compiling and linking. You should use Python 3 to run this command. The above command tells the compiler to find the source code in the current directory and put the object files in the current directory too. It also links the object files to an executable binary file at \"./hello\". Now we have our first Birdee executable \"hello\". Run it by: ./hello Instead of using bbuild, you can also manually compile and link the program with commands: $BIRDEE_HOME/bin/birdeec -i hello.bdm -o hello.o -e gcc -o hello hello.o $BIRDEE_HOME/blib/birdee.o $BIRDEE_HOME/lib/libBirdeeRuntime.a -lgc More command line options for \"birdeec\" can be found here . \"birdeec\" is the core compiler for Birdee language and it generates object files only. You need to link the object file with other necessary files to generate an executable. Fortunately, our tool bbuild can do these all for you. More details of bbuild can be found here An simpler way to try and run Birdee code without compiling and linking is to use the Birdee playground. It provides a interactive environment which accepts Birdee code and immediately evaluate the result of it after you press \"Enter\". More on the playground can be found here","title":"1. Hello world!"},{"location":"Birdee Language Mannual/0010HelloWorld/#1-hello-world","text":"Our first Birdee program prints a line of words \"Hello world\" on the console. Create a file named \"hello.bdm\", and write a simple line of code in the file: println( Hello world ) Then switch to the directory of the file \"hello.bdm\" and compile it with command in Linux: python $BIRDEE_HOME/pylib/bbuild.py -le ./hello -i . -o . hello If you are using Windows, you should run the following command in Visual Studio x64 Commmand Prompt. (You can find it in the Visual Studio directory of the start menu.) python %BIRDEE_HOME%\\pylib\\bbuild.py -le .\\hello.exe -i . -o . hello \"bbuild.py\" is a high-level tool for Birdee source compiling and linking. You should use Python 3 to run this command. The above command tells the compiler to find the source code in the current directory and put the object files in the current directory too. It also links the object files to an executable binary file at \"./hello\". Now we have our first Birdee executable \"hello\". Run it by: ./hello Instead of using bbuild, you can also manually compile and link the program with commands: $BIRDEE_HOME/bin/birdeec -i hello.bdm -o hello.o -e gcc -o hello hello.o $BIRDEE_HOME/blib/birdee.o $BIRDEE_HOME/lib/libBirdeeRuntime.a -lgc More command line options for \"birdeec\" can be found here . \"birdeec\" is the core compiler for Birdee language and it generates object files only. You need to link the object file with other necessary files to generate an executable. Fortunately, our tool bbuild can do these all for you. More details of bbuild can be found here An simpler way to try and run Birdee code without compiling and linking is to use the Birdee playground. It provides a interactive environment which accepts Birdee code and immediately evaluate the result of it after you press \"Enter\". More on the playground can be found here","title":"1. Hello world!"},{"location":"Birdee Language Mannual/0020Basics/","text":"2. Language Basics In this section, the basic syntax of Birdee will be explained, and building more complex programs become possible. 2.1 Variables and expressions Variables are holders of data. They have types specified when they are defined. There are basic types in Birdee, which include boolean (true/false), byte (8-bit signed integer), short (16-bit signed integer), int (32-bit signed integer), long (64-bit signed integer), uint (32-bit unsigned integer), ulong (64-bit unsigned integer), float (32-bit float-point number), double (64-bit float-point number) and pointer (native pointer type). Complex types like array and class will be explained later. (Note: the class type \"string\" is one of the most commonly used class in Birdee, and we have already used it in our \"hello world\" example!) 2.1.1 Variables definitions To define a variable, use the keyword \"dim\". The basic syntax is shown below. The variable_name can be any valid name composed by \"_\", numbers (0-9) and English characters (a-z and A-Z). In addition, the variable_name should not be one of the keywords of Birdee, such as \"dim\" and \"as\". The type can be a basic type, array type or class type. dim {variable_name} as {type} Below is an example to define a variable named \"v\" with integer type in the top-level scope. dim v as int You can assign a value to the variable when defining it. dim v as int = 123 dim str as string = hello You can define multiple variables in one line with only one \"dim\" keyword, separated by comma. (and you can still use \"=\" to assign an initial value). dim v as int = 123, str as string = hello , length as float The type can be omitted and inferred by the compiler in a variable definition when the definition has an initial value assigned. The above example code can be simplified to: dim v = 123, str = hello , length as float Note that the variable \"length\" has no initial value assigned, so the type must be given. 2.1.2 Variable assignment To use a variable, you should first define it with a specific type (or assign an initial value to it). For example, dim v1 as int, v2 as float, v3 as string, v4 as int You can assign values to variables by \"=\": v1=123 v2=3.14 v3= birdee Note that in the above code, the value \"birdee\", which is surrounded by a pair of quotation marks (\"), is a string literal. The string literals will be explained later. Variable does not allow to be assigned with incompatable types. For example, the following two lines of code are not allowed by Birdee. v1= 123 v3=321 It is because \"v1\" is of int type, which cannot be assigned a string value. And \"v3\" is a string variable, and does not accept integers. 2.1.3 Operators Birdee allows arithmetic(+,-,*,/,%, etc.) and logical operators ( , ,| , ||, etc.) in expressions. The meanings and precedence of these operators are shown below: Operator Meaning Precedence * Multiplication 15 / Division 15 % Remainder 15 + Addition 14 - Substraction 14 Less than 11 Larger than 11 = Larger than or equal 11 = Less than or equal 11 == Value equal 10 != Value not equal 10 === Reference equal (for class objects/arrays) 10 !== Reference not equal (for class objects/arrays) 10 Bitwise and 9 ^ Bitwise xor 8 | Bitwise or 7 Logical and 6 || Logical or 5 = Assignment 4 You can use brackets \"()\" to change the default precedence. TBD: explain Logical AND and OR For value types (integers, floats, pointers, ...), the operators \"==\" and \"===\" are equivalent (so are \"!=\" and \"!==\"). For references (class objects and arrays), the operators \"==\" and \"!=\" call the methods \" eq \" and \" ne \" of the left hand side object and use the right hand side object as the parameter, which compare whether the value of objects are equal. The operators \"===\" and \"!==\" only compares the references themselves. For now, we can write a bit more complex programs: dim v1 as int, v1 as int, v3 as float v1 = (12345 + 999) * 6789 v2 = v1 % 32 dim v4 as boolean = v2 v1 println(int2str(v2)) println(bool2str(v4)) Note: \"println\", \"bool2str\" and \"int2str\" are system functions. \"println\" will print a line of string on the console (we have already used it in our \"hello world\"). \"bool2str\" and \"int2str\" are functions that convert boolean and int values to strings, respectively. 2.1.4 Operators for class types The operators in the above section are originally for basic types like int, float and boolean. However, Birdee allow you to apply operators on class types. We will explain it later, but we will now introduce an operator for our old friend - the string class, which is widely used. You can add (+) two strings by the operator \"+\" to concatenate one after the other: dim v1 = birdee dim v2 as string v2= v1 + is awesome println(v2) The above funtion concatenate strings \"birdee\" and \" is awesome\", then prints out the result string \"birdee is awesome\". 2.1.5 Auto type conversion If the types of the operands of an operator do not match, and the operands are both of numeric types (int, uint, float, etc.), Birdee compiler will try to do auto conversion. In an operator expression, the type with a smaller \"promotion value\" will be converted to the type with a larger \"promotion value\", and the resulting type of the expression will be the larger \"promotion value\" type. The promotion values for numeric types are listed below: Type Promotion values byte -2 short -2 int 0 uint 1 long 2 ulong 3 float 4 double 5 For example, dim a as byte = 1, dim b as long =3 b=a+b dim c as float=0.1 dim d = c+b The above program adds a byte (a) with a long (b). It will first convert the value of \"a\" to type long, and add with \"b\", resulting in a type long value. Similarly, when adding \"c\" with \"b\", it will convert \"b\" to type float and the result is in type float, making variable \"d\" a float variable. A functype value can be automatically converted to closures (functype and closures will be discussed later). A value of a subclass can be automatically converted to a sub-class reference (classes will be discussed later). Important note: The assignment operator will always try to convert the value on the right of \"=\" (we call it Rvalue) to the variable on the left of \"=\" (called Lvalue). If type of Rvalue cannot be converted to Lvalue, an error will be raised. 2.1.6 String literals We have met string literals in above examples. Characters surrounded by a pair of quotation marks (\") represents a string literal, Birdee also supports escape characters like \"\\n\", \"\\\\\". Also, Birdee supports raw strings, which will disregard any escape characters. A raw string starts and ends with three quotation marks ('''). You can even have multiple lines in a raw string. println( Hey\\nThis is Birdee! ) println('''Hey This is Birdee!''') println('''Hey\\nThis is Birdee!''') The above program will output: Hey This is Birdee! Hey This is Birdee! Hey\\nThis is Birdee! Note that the first two string literals are equivalent. The third string literal does not parse the escape character \"\\n\". TBD: introduce other constants 2.2 Comment Comments in the source code could help you and other programmers better understand the program. The Birdee compiler will ignore the comments in a program when it is compiled. One way to write comments is to use \"#\", and it will let the compiler to ignore \"#\" and later characters in the source code until the end of the current line. dim a as int = 3+4 # a is an integer with value 7 println(int2str(a)) # print the value of a To write comments in multiple lines, you should use \"##\" to mark the start of the comment and use another \"##\" to mark the end of the comment. ## This program computes the value of 3+4, and then put the value in the variable a . It finally print the value of a ## dim a as int = 3+4 println(int2str(a)) 2.3 Function A function in Birdee is a reusable block of code. To define a function in the top-level, use syntax like: function {function_name} ([ {parameter1} as {type}, {parameter2} as {type}, ... ]) [as {type}] ... end [function] In the example, \"{ }\" means names that you must define and \"[ ]\" means optional syntax which can be omitted. A function with a returning value should specify the returning type at the end of function definition (\"[as {type}]\"), but a function without returning value can omit it. A function can have zero or multiple parameters, with each parameter defined by \"{parameter} as {type}\" in the function definition. The \"end\" in the last line of the function definition marks the end of the function. To make Birdee look similar with the syntax of Visual Basic, you can write an additional (and optional) \"function\" word after \"end\", and the \"function\" word will be omitted by the compiler. We have already met some functions like \"println\" and \"int2str\". They are system functions provided and defined by Birdee. We first show an example of a function doing addition: function add (a as int, b as int) as int dim c = a + b return c end dim result=add(3,4) The function \"add\" takes two parameters: \"a\" and \"b\", both of integer type and returns an integer. In the body of the function, it adds the two parameters and return the result by the \"return\" keyword. In the last line, we call the funtion, and save the result in a variable. Note that unlike the code in the top-level, the code in a function will not be executed unless the function is called. To call a function, type the funtion name followed by a pair of brackets, with the parameters filled in order. If the funtion returns a value, you can use the function call expression as a value: println(int2str(12345)) In the above example, \"int2str(12345)\" is a function call expression. The function \"int2str\" takes the integer \"12345\" as the input and returns a string format of it. So the expression \"int2str(12345)\" itself is a string, and is used as the input of the function \"println\", to print the string in the console. There is a simpler way to define a function in a single line. The syntax is: function [function_name] ([ {parameter1} as {type}, {parameter2} as {type}, ... ]) [as {type}] = {expression} You can use the keyword \"= \" to define the function's body in a single expression. Note that if the function has a return type, the expression of the function body will be automatically returned. You can even omit the function name in function definition. This is useful for functional programming. In addition, the keyword \"function\" can be simplified to \"func\". So a shorter form of the \"add\" function in the last example can be: func add(a as int, b as int) as int = a+b","title":"2. Language Basics"},{"location":"Birdee Language Mannual/0020Basics/#2-language-basics","text":"In this section, the basic syntax of Birdee will be explained, and building more complex programs become possible.","title":"2. Language Basics"},{"location":"Birdee Language Mannual/0020Basics/#21-variables-and-expressions","text":"Variables are holders of data. They have types specified when they are defined. There are basic types in Birdee, which include boolean (true/false), byte (8-bit signed integer), short (16-bit signed integer), int (32-bit signed integer), long (64-bit signed integer), uint (32-bit unsigned integer), ulong (64-bit unsigned integer), float (32-bit float-point number), double (64-bit float-point number) and pointer (native pointer type). Complex types like array and class will be explained later. (Note: the class type \"string\" is one of the most commonly used class in Birdee, and we have already used it in our \"hello world\" example!)","title":"2.1 Variables and expressions"},{"location":"Birdee Language Mannual/0020Basics/#211-variables-definitions","text":"To define a variable, use the keyword \"dim\". The basic syntax is shown below. The variable_name can be any valid name composed by \"_\", numbers (0-9) and English characters (a-z and A-Z). In addition, the variable_name should not be one of the keywords of Birdee, such as \"dim\" and \"as\". The type can be a basic type, array type or class type. dim {variable_name} as {type} Below is an example to define a variable named \"v\" with integer type in the top-level scope. dim v as int You can assign a value to the variable when defining it. dim v as int = 123 dim str as string = hello You can define multiple variables in one line with only one \"dim\" keyword, separated by comma. (and you can still use \"=\" to assign an initial value). dim v as int = 123, str as string = hello , length as float The type can be omitted and inferred by the compiler in a variable definition when the definition has an initial value assigned. The above example code can be simplified to: dim v = 123, str = hello , length as float Note that the variable \"length\" has no initial value assigned, so the type must be given.","title":"2.1.1 Variables definitions"},{"location":"Birdee Language Mannual/0020Basics/#212-variable-assignment","text":"To use a variable, you should first define it with a specific type (or assign an initial value to it). For example, dim v1 as int, v2 as float, v3 as string, v4 as int You can assign values to variables by \"=\": v1=123 v2=3.14 v3= birdee Note that in the above code, the value \"birdee\", which is surrounded by a pair of quotation marks (\"), is a string literal. The string literals will be explained later. Variable does not allow to be assigned with incompatable types. For example, the following two lines of code are not allowed by Birdee. v1= 123 v3=321 It is because \"v1\" is of int type, which cannot be assigned a string value. And \"v3\" is a string variable, and does not accept integers.","title":"2.1.2 Variable assignment"},{"location":"Birdee Language Mannual/0020Basics/#213-operators","text":"Birdee allows arithmetic(+,-,*,/,%, etc.) and logical operators ( , ,| , ||, etc.) in expressions. The meanings and precedence of these operators are shown below: Operator Meaning Precedence * Multiplication 15 / Division 15 % Remainder 15 + Addition 14 - Substraction 14 Less than 11 Larger than 11 = Larger than or equal 11 = Less than or equal 11 == Value equal 10 != Value not equal 10 === Reference equal (for class objects/arrays) 10 !== Reference not equal (for class objects/arrays) 10 Bitwise and 9 ^ Bitwise xor 8 | Bitwise or 7 Logical and 6 || Logical or 5 = Assignment 4 You can use brackets \"()\" to change the default precedence. TBD: explain Logical AND and OR For value types (integers, floats, pointers, ...), the operators \"==\" and \"===\" are equivalent (so are \"!=\" and \"!==\"). For references (class objects and arrays), the operators \"==\" and \"!=\" call the methods \" eq \" and \" ne \" of the left hand side object and use the right hand side object as the parameter, which compare whether the value of objects are equal. The operators \"===\" and \"!==\" only compares the references themselves. For now, we can write a bit more complex programs: dim v1 as int, v1 as int, v3 as float v1 = (12345 + 999) * 6789 v2 = v1 % 32 dim v4 as boolean = v2 v1 println(int2str(v2)) println(bool2str(v4)) Note: \"println\", \"bool2str\" and \"int2str\" are system functions. \"println\" will print a line of string on the console (we have already used it in our \"hello world\"). \"bool2str\" and \"int2str\" are functions that convert boolean and int values to strings, respectively.","title":"2.1.3 Operators"},{"location":"Birdee Language Mannual/0020Basics/#214-operators-for-class-types","text":"The operators in the above section are originally for basic types like int, float and boolean. However, Birdee allow you to apply operators on class types. We will explain it later, but we will now introduce an operator for our old friend - the string class, which is widely used. You can add (+) two strings by the operator \"+\" to concatenate one after the other: dim v1 = birdee dim v2 as string v2= v1 + is awesome println(v2) The above funtion concatenate strings \"birdee\" and \" is awesome\", then prints out the result string \"birdee is awesome\".","title":"2.1.4 Operators for class types"},{"location":"Birdee Language Mannual/0020Basics/#215-auto-type-conversion","text":"If the types of the operands of an operator do not match, and the operands are both of numeric types (int, uint, float, etc.), Birdee compiler will try to do auto conversion. In an operator expression, the type with a smaller \"promotion value\" will be converted to the type with a larger \"promotion value\", and the resulting type of the expression will be the larger \"promotion value\" type. The promotion values for numeric types are listed below: Type Promotion values byte -2 short -2 int 0 uint 1 long 2 ulong 3 float 4 double 5 For example, dim a as byte = 1, dim b as long =3 b=a+b dim c as float=0.1 dim d = c+b The above program adds a byte (a) with a long (b). It will first convert the value of \"a\" to type long, and add with \"b\", resulting in a type long value. Similarly, when adding \"c\" with \"b\", it will convert \"b\" to type float and the result is in type float, making variable \"d\" a float variable. A functype value can be automatically converted to closures (functype and closures will be discussed later). A value of a subclass can be automatically converted to a sub-class reference (classes will be discussed later). Important note: The assignment operator will always try to convert the value on the right of \"=\" (we call it Rvalue) to the variable on the left of \"=\" (called Lvalue). If type of Rvalue cannot be converted to Lvalue, an error will be raised.","title":"2.1.5 Auto type conversion"},{"location":"Birdee Language Mannual/0020Basics/#216-string-literals","text":"We have met string literals in above examples. Characters surrounded by a pair of quotation marks (\") represents a string literal, Birdee also supports escape characters like \"\\n\", \"\\\\\". Also, Birdee supports raw strings, which will disregard any escape characters. A raw string starts and ends with three quotation marks ('''). You can even have multiple lines in a raw string. println( Hey\\nThis is Birdee! ) println('''Hey This is Birdee!''') println('''Hey\\nThis is Birdee!''') The above program will output: Hey This is Birdee! Hey This is Birdee! Hey\\nThis is Birdee! Note that the first two string literals are equivalent. The third string literal does not parse the escape character \"\\n\". TBD: introduce other constants","title":"2.1.6 String literals"},{"location":"Birdee Language Mannual/0020Basics/#22-comment","text":"Comments in the source code could help you and other programmers better understand the program. The Birdee compiler will ignore the comments in a program when it is compiled. One way to write comments is to use \"#\", and it will let the compiler to ignore \"#\" and later characters in the source code until the end of the current line. dim a as int = 3+4 # a is an integer with value 7 println(int2str(a)) # print the value of a To write comments in multiple lines, you should use \"##\" to mark the start of the comment and use another \"##\" to mark the end of the comment. ## This program computes the value of 3+4, and then put the value in the variable a . It finally print the value of a ## dim a as int = 3+4 println(int2str(a))","title":"2.2 Comment"},{"location":"Birdee Language Mannual/0020Basics/#23-function","text":"A function in Birdee is a reusable block of code. To define a function in the top-level, use syntax like: function {function_name} ([ {parameter1} as {type}, {parameter2} as {type}, ... ]) [as {type}] ... end [function] In the example, \"{ }\" means names that you must define and \"[ ]\" means optional syntax which can be omitted. A function with a returning value should specify the returning type at the end of function definition (\"[as {type}]\"), but a function without returning value can omit it. A function can have zero or multiple parameters, with each parameter defined by \"{parameter} as {type}\" in the function definition. The \"end\" in the last line of the function definition marks the end of the function. To make Birdee look similar with the syntax of Visual Basic, you can write an additional (and optional) \"function\" word after \"end\", and the \"function\" word will be omitted by the compiler. We have already met some functions like \"println\" and \"int2str\". They are system functions provided and defined by Birdee. We first show an example of a function doing addition: function add (a as int, b as int) as int dim c = a + b return c end dim result=add(3,4) The function \"add\" takes two parameters: \"a\" and \"b\", both of integer type and returns an integer. In the body of the function, it adds the two parameters and return the result by the \"return\" keyword. In the last line, we call the funtion, and save the result in a variable. Note that unlike the code in the top-level, the code in a function will not be executed unless the function is called. To call a function, type the funtion name followed by a pair of brackets, with the parameters filled in order. If the funtion returns a value, you can use the function call expression as a value: println(int2str(12345)) In the above example, \"int2str(12345)\" is a function call expression. The function \"int2str\" takes the integer \"12345\" as the input and returns a string format of it. So the expression \"int2str(12345)\" itself is a string, and is used as the input of the function \"println\", to print the string in the console. There is a simpler way to define a function in a single line. The syntax is: function [function_name] ([ {parameter1} as {type}, {parameter2} as {type}, ... ]) [as {type}] = {expression} You can use the keyword \"= \" to define the function's body in a single expression. Note that if the function has a return type, the expression of the function body will be automatically returned. You can even omit the function name in function definition. This is useful for functional programming. In addition, the keyword \"function\" can be simplified to \"func\". So a shorter form of the \"add\" function in the last example can be: func add(a as int, b as int) as int = a+b","title":"2.3 Function"},{"location":"Birdee Language Mannual/0030FlowControl/","text":"3. Flow Control The syntax introduced till now allows programs to be executed sequentially. But how to let different parts of the program be executed under different conditions? How to execute some blocks of code for multiple times? The answer is by flow control! 3.1 Conditional Branches 3.1.1 If The \"if\" syntax is used to execute a block of code when the condition is true. The basic syntax is: if {condition} then ... end [if] The \"{condition}\" should be an boolean expression (could be true or false), such as \"a 0\", \"a!=b b 32\" and so on. The code within an \"if\" block will be executed if the condition is true. To mark the end of the block of code, use \"end\" or \"end if\". No matter the condition is true or not, the program will continue at the line after \"end\" or \"end if\", after the \"if\" block is executed. The following example checks if the value of \"a\" is larger than 100. If so, it prints a line \"a is larger than 100\". The program will always print the value of \"a\" no matter what value \"a\" is. if a 100 then println( a is larger than 100 ) end println( a is + int2str(a)) You may want to wirte a program like this: if a condition is true, execute block A; otherwise, execute block B. You can achieve this by the \"if...else...\" syntax. For example, we could change the above program a little bit: if a is not larger than 100, we also want to print a line \"a is no larger than 100\": if a 100 then println( a is larger than 100 ) else println( a is no larger than 100 ) end println( a is + int2str(a)) The \"else\" key word will mark the end of the block to be executed if true, and mark the start of the block to be executed if false. In many cases, multiple conditions should be considered. For example, a teacher may want to find the grade from a score. The grades are given according to the following table (assume the scores are integers): Grade Score A 90-100 B 75-89 C 60-74 F 0-59 We can write a Birdee program to solve the problem: function find_grade(score as int) as string if score =59 then return F else if score =74 then return C else if score =89 then return B else return A end end end end Yes, \"if\" blocks can be nested, but the above program is not an elegant way to solve this program. The nested \"if...else...\" blocks can be simplified by \"else if\" blocks: function find_grade(score as int) as string if score =59 then return F else if score =74 then return C else if score =89 then return B else return A end end The \"else if\" syntax saves some \"end\"s and make nested \"if\" blocks looks better. 3.2 Loop 3.2.1 For Loop To execute a block of code for a specific times, \"for loop\" can be used. The basic syntax is: for {variable} = {start} to {end} ... end [for] The \"{variable}\" should be any Lvalue in integer type. {start} and {end} are any valid integer expressions. The {variable} will increment from {start} to {end} and the block of code in the loop will be executed for ({end} - {start} + 1) times. If {end} {start}, the loop stop executing. The following code will print \"hi! From i=1\", \"hi! From i=2\", \"hi! From i=3\". dim i as int for i=1 to 3 println( hi! From i= + int2str(i)) end The variable \"i\" is called loop variable, which is modified by Birdee language every time the body of the loop is executed. Note that internally, Birdee will generate code to increment the loop variable at the end of the loop body and compare the variable against the {end} expression to decide whether to run the loop body again. You can combine the definition of loop variable with the for loop. For example, you can simply modify the above example to: for dim i=1 to 3 println( hi! From i= + int2str(i)) end However, the loop variables are defined in different scopes in the previous two examples. (What is \"scope\"? We will explain later.) Keep in mind that if you define a variable in a for loop (in the for ... to ..., or in the body of the loop), the variable can only be used within this particular for loop and is not available outside of it. For example, we add a line in the above example: for dim i=1 to 3 println( hi! From i= + int2str(i)) end println(i+1) # Compiler will complain here! Birdee compiler will recognize an error in the last line because variable \"i\" is only defined within the for loop. Also note that {start} and {end} are not necessarily constants, they can be variables, function calls or whatever valid integer expressions. If you do not want to include the {end} value in the for loop, you can use \"till\" key word instead of \"to\" key word: for dim i=1 till 3 println( hi! From i= + int2str(i)) end The above for loop will be executed twice, with i=1 and then i=2. You may want to jump out of the loop in some cases, where you can use the \"break\" keyword to jump to the next line of the end of the loop: for dim i=1 to 1000 println( hi! From i= + int2str(i)) if i==2 then break end end println( End of the loop ) The \"break\" keyword in the above program will let it jump to the line \"println(\"End of the loop\")\". Then you will see two lines with i=1 and i=2 printed in console and a line \"End of the loop\", after the program is executed. You can use \"continue\" keyword to skip the rest of the loop body in the current iteration, and continue at the next iteration: for dim i=1 to 3 if i==2 then continue end println( hi! From i= + int2str(i)) end The above example will print 2 lines with i=1 and i=3. Because when i=2, the loop is skipped. You cannot use \"break\" and \"continue\" outside of loops. 3.2.2 While Loop The \"while\" loop will execute a block of code repeatedly until the given condition becomes \"false\". The syntax of it is: while {condition} ... end [while] The \"condition\" should be a boolean-typed expression. Here we present an example for printing strings from a \"black box\". Assume that the \"black box\" contains some strings and you can call \"get\" function to fetch a string from the box, and you can call \"has_next\" function (which returns a boolean value) to find whether there are any strings in the black box. while has_next() println(get()) end","title":"3. Flow Control"},{"location":"Birdee Language Mannual/0030FlowControl/#3-flow-control","text":"The syntax introduced till now allows programs to be executed sequentially. But how to let different parts of the program be executed under different conditions? How to execute some blocks of code for multiple times? The answer is by flow control!","title":"3. Flow Control"},{"location":"Birdee Language Mannual/0030FlowControl/#31-conditional-branches","text":"","title":"3.1 Conditional Branches"},{"location":"Birdee Language Mannual/0030FlowControl/#311-if","text":"The \"if\" syntax is used to execute a block of code when the condition is true. The basic syntax is: if {condition} then ... end [if] The \"{condition}\" should be an boolean expression (could be true or false), such as \"a 0\", \"a!=b b 32\" and so on. The code within an \"if\" block will be executed if the condition is true. To mark the end of the block of code, use \"end\" or \"end if\". No matter the condition is true or not, the program will continue at the line after \"end\" or \"end if\", after the \"if\" block is executed. The following example checks if the value of \"a\" is larger than 100. If so, it prints a line \"a is larger than 100\". The program will always print the value of \"a\" no matter what value \"a\" is. if a 100 then println( a is larger than 100 ) end println( a is + int2str(a)) You may want to wirte a program like this: if a condition is true, execute block A; otherwise, execute block B. You can achieve this by the \"if...else...\" syntax. For example, we could change the above program a little bit: if a is not larger than 100, we also want to print a line \"a is no larger than 100\": if a 100 then println( a is larger than 100 ) else println( a is no larger than 100 ) end println( a is + int2str(a)) The \"else\" key word will mark the end of the block to be executed if true, and mark the start of the block to be executed if false. In many cases, multiple conditions should be considered. For example, a teacher may want to find the grade from a score. The grades are given according to the following table (assume the scores are integers): Grade Score A 90-100 B 75-89 C 60-74 F 0-59 We can write a Birdee program to solve the problem: function find_grade(score as int) as string if score =59 then return F else if score =74 then return C else if score =89 then return B else return A end end end end Yes, \"if\" blocks can be nested, but the above program is not an elegant way to solve this program. The nested \"if...else...\" blocks can be simplified by \"else if\" blocks: function find_grade(score as int) as string if score =59 then return F else if score =74 then return C else if score =89 then return B else return A end end The \"else if\" syntax saves some \"end\"s and make nested \"if\" blocks looks better.","title":"3.1.1 If"},{"location":"Birdee Language Mannual/0030FlowControl/#32-loop","text":"","title":"3.2 Loop"},{"location":"Birdee Language Mannual/0030FlowControl/#321-for-loop","text":"To execute a block of code for a specific times, \"for loop\" can be used. The basic syntax is: for {variable} = {start} to {end} ... end [for] The \"{variable}\" should be any Lvalue in integer type. {start} and {end} are any valid integer expressions. The {variable} will increment from {start} to {end} and the block of code in the loop will be executed for ({end} - {start} + 1) times. If {end} {start}, the loop stop executing. The following code will print \"hi! From i=1\", \"hi! From i=2\", \"hi! From i=3\". dim i as int for i=1 to 3 println( hi! From i= + int2str(i)) end The variable \"i\" is called loop variable, which is modified by Birdee language every time the body of the loop is executed. Note that internally, Birdee will generate code to increment the loop variable at the end of the loop body and compare the variable against the {end} expression to decide whether to run the loop body again. You can combine the definition of loop variable with the for loop. For example, you can simply modify the above example to: for dim i=1 to 3 println( hi! From i= + int2str(i)) end However, the loop variables are defined in different scopes in the previous two examples. (What is \"scope\"? We will explain later.) Keep in mind that if you define a variable in a for loop (in the for ... to ..., or in the body of the loop), the variable can only be used within this particular for loop and is not available outside of it. For example, we add a line in the above example: for dim i=1 to 3 println( hi! From i= + int2str(i)) end println(i+1) # Compiler will complain here! Birdee compiler will recognize an error in the last line because variable \"i\" is only defined within the for loop. Also note that {start} and {end} are not necessarily constants, they can be variables, function calls or whatever valid integer expressions. If you do not want to include the {end} value in the for loop, you can use \"till\" key word instead of \"to\" key word: for dim i=1 till 3 println( hi! From i= + int2str(i)) end The above for loop will be executed twice, with i=1 and then i=2. You may want to jump out of the loop in some cases, where you can use the \"break\" keyword to jump to the next line of the end of the loop: for dim i=1 to 1000 println( hi! From i= + int2str(i)) if i==2 then break end end println( End of the loop ) The \"break\" keyword in the above program will let it jump to the line \"println(\"End of the loop\")\". Then you will see two lines with i=1 and i=2 printed in console and a line \"End of the loop\", after the program is executed. You can use \"continue\" keyword to skip the rest of the loop body in the current iteration, and continue at the next iteration: for dim i=1 to 3 if i==2 then continue end println( hi! From i= + int2str(i)) end The above example will print 2 lines with i=1 and i=3. Because when i=2, the loop is skipped. You cannot use \"break\" and \"continue\" outside of loops.","title":"3.2.1 For Loop"},{"location":"Birdee Language Mannual/0030FlowControl/#322-while-loop","text":"The \"while\" loop will execute a block of code repeatedly until the given condition becomes \"false\". The syntax of it is: while {condition} ... end [while] The \"condition\" should be a boolean-typed expression. Here we present an example for printing strings from a \"black box\". Assume that the \"black box\" contains some strings and you can call \"get\" function to fetch a string from the box, and you can call \"has_next\" function (which returns a boolean value) to find whether there are any strings in the black box. while has_next() println(get()) end","title":"3.2.2 While Loop"},{"location":"Birdee Language Mannual/0040ScopeAndName/","text":"4. Scope and names We first introduce a concept: basic block. A basic block is a block of code. The basic block in the highest-level is the top-level code; A simple \"if-else\" has two basic blocks: one for condition being true and the other for condition being false; A for loop itself is a basic block. As you can see, basic blocks may have some children basic blocks. Scopes define where a name (variable/function/class) can be used and is visible to the programmers. Every basic block has one corresponding scope. When a name is defined, the name will be added into the current basic block's scope. Scopes are maintained in a tree, where a parent scope may have zero or multiple children scopes. There are some simple rules for scopes in Birdee: 1. The code in a child scope can reference all names (for variable/function/class) of its ancestor scopes - In a child basic block, you can use the functions/variables/classes defined in any ancestor basic blocks. 2. The code in a parent scope is unaware of the names in a child basic block - In a parent basic block, you cannot use the variables (or functions, etc.) which is defined in a child basic block. You can define a variable in the parent basic block which have the same name of some variable in the child basic block. 3. In the same scope, defining two variables/functions/classes with the same name is not allowed. 4. In the child scope, it is allowed to define a variable (or function/class) which has the same name of some variables (or functions, etc.) in the ancestor scopes. 5. When resolving a name, if the name is defined in some ancestor scopes or in the current scope, the variable (or function, etc.) defined in the lowest level of scope will be selected. Note that the parameters of functions can be viewed as defined variables in the function's scope. For more explanations, see comments: dim a as int = 2 function compute(b as int) as int return a*b # Okay because of rule 1 end b=3 # Won't compile! Due to rule 2 if a==2 then dim c as float=123.2 end c=333.0 # Won't compile! Due to rule 2 dim a as string # Won't compile! Due to rule 3 function show(b as int) dim a = hi # Okay because of rule 4 println(a + int2str(b)) # Okay because of rule 5, the definition in the current scope is selected end 4.1 Name resolution rules The name resolution rules defines how identifiers are resolved and bound to the function/variable definition. Given a name of identifier for expression, Birdee language should find the name in the definitions in the following order, from upper ones to lower ones. Once an definition name is matched with the identifier name, the compiler will bind this identifier expression with the selected definition, and will disregard all definitions in lower orders. The names of local variables in the current basic block The names of local variables (including function arguments) in the ancestor basic blocks (nearest first) The names of template arguments (we will discuss templates later. Note that compilers only search constant expression template arguments here.) (If currently in a member function of a class,) The field names of the current class (If currently in a member function of a class,) The member function names of the current class. The global variable (defined in top-level) names defined in the current module The functions names defined in the current module The imported global variable (defined in top-level) names defined in other modules The imported functions names defined in other modules The imported package names The above is the order of name resolution of identifier expressions. Birdee also defines the resolution order for type names. The following order applies to types (e.g. the identifiers after \"as\"): The template argument names of the current function The template argument names of the current class (if exists) The \"functype\" or closure names of the current module The imported \"functype\" or closure names of the imported modules The class names of the current module The imported class names of the imported modules","title":"4. Scope and names"},{"location":"Birdee Language Mannual/0040ScopeAndName/#4-scope-and-names","text":"We first introduce a concept: basic block. A basic block is a block of code. The basic block in the highest-level is the top-level code; A simple \"if-else\" has two basic blocks: one for condition being true and the other for condition being false; A for loop itself is a basic block. As you can see, basic blocks may have some children basic blocks. Scopes define where a name (variable/function/class) can be used and is visible to the programmers. Every basic block has one corresponding scope. When a name is defined, the name will be added into the current basic block's scope. Scopes are maintained in a tree, where a parent scope may have zero or multiple children scopes. There are some simple rules for scopes in Birdee: 1. The code in a child scope can reference all names (for variable/function/class) of its ancestor scopes - In a child basic block, you can use the functions/variables/classes defined in any ancestor basic blocks. 2. The code in a parent scope is unaware of the names in a child basic block - In a parent basic block, you cannot use the variables (or functions, etc.) which is defined in a child basic block. You can define a variable in the parent basic block which have the same name of some variable in the child basic block. 3. In the same scope, defining two variables/functions/classes with the same name is not allowed. 4. In the child scope, it is allowed to define a variable (or function/class) which has the same name of some variables (or functions, etc.) in the ancestor scopes. 5. When resolving a name, if the name is defined in some ancestor scopes or in the current scope, the variable (or function, etc.) defined in the lowest level of scope will be selected. Note that the parameters of functions can be viewed as defined variables in the function's scope. For more explanations, see comments: dim a as int = 2 function compute(b as int) as int return a*b # Okay because of rule 1 end b=3 # Won't compile! Due to rule 2 if a==2 then dim c as float=123.2 end c=333.0 # Won't compile! Due to rule 2 dim a as string # Won't compile! Due to rule 3 function show(b as int) dim a = hi # Okay because of rule 4 println(a + int2str(b)) # Okay because of rule 5, the definition in the current scope is selected end","title":"4. Scope and names"},{"location":"Birdee Language Mannual/0040ScopeAndName/#41-name-resolution-rules","text":"The name resolution rules defines how identifiers are resolved and bound to the function/variable definition. Given a name of identifier for expression, Birdee language should find the name in the definitions in the following order, from upper ones to lower ones. Once an definition name is matched with the identifier name, the compiler will bind this identifier expression with the selected definition, and will disregard all definitions in lower orders. The names of local variables in the current basic block The names of local variables (including function arguments) in the ancestor basic blocks (nearest first) The names of template arguments (we will discuss templates later. Note that compilers only search constant expression template arguments here.) (If currently in a member function of a class,) The field names of the current class (If currently in a member function of a class,) The member function names of the current class. The global variable (defined in top-level) names defined in the current module The functions names defined in the current module The imported global variable (defined in top-level) names defined in other modules The imported functions names defined in other modules The imported package names The above is the order of name resolution of identifier expressions. Birdee also defines the resolution order for type names. The following order applies to types (e.g. the identifiers after \"as\"): The template argument names of the current function The template argument names of the current class (if exists) The \"functype\" or closure names of the current module The imported \"functype\" or closure names of the imported modules The class names of the current module The imported class names of the imported modules","title":"4.1 Name resolution rules"},{"location":"Birdee Language Mannual/0050Array/","text":"5. Array 5.1 Array basics An array is an sequential collection of values with the same type. To use an array type, you can append \"[]\" to other types and you will get a array of that type. See example: dim arr1 as int[] Here \"arr1\" is a variable of integer array type. Arrays of objects are also allowed: dim arr2 as string[] You can declare arrays of arrays (multi-dimension array). Here is an example of two-dimension array: dim arr2 as float[][] To use an array, you should first allocate space for it, by \"new\" operator. The syntax is: new {type} * {number_of_elements} For example, to create an array of integer with 10 elements: dim arr as int[] = new int * 10 To create an [10x20] array of float, you can: dim arr2 as float[][] = new float * 10, 20 Finally, you can access the array by \"[ ]\": arr[0]=12 dim c = arr[0] + 23 arr2[1][3]=3.14 Note that surrounded by \"[ ]\" is the index of the array element you want to access. The index must be an integer type (int, uint, long, ulong, ...). Also, the index starts at 0 and ends at number_of_elements-1. If you create an array by \"new int[10]\", the valid index will be within [0 ~ 9]. The array variable is a reference to the array, not the array itself. So the following code: dim arr as int[] = new int * 10 dim arr2 as int[] = new int * 10 arr2 = arr will not copy the array of 10 elements to \"arr2\", but make the variable \"arr2\" points to the same array of \"arr\". So if we assign a value to an element of \"arr\", you can find the change by the variable \"arr2\", because both variables points to the same array! dim arr as int[] = new int * 10 dim arr2 as int[] = new int * 10 arr2 = arr arr[3] = 123 println(int2str(arr2[3])) # you will see 123 Also note that variables for classes are also references. The same effect applies to class variables too. You can access some properties of an array by: dim arr as int[] = new int * 10 println( The number of elements is + arr.length()) #arr.length() gets the # of elements dim ptr as pointer = arr.get_raw() #arr.get_raw() gets the native pointer of the array 5.2 Array initializers You can create an array and assign inital values of the elements at the same time by array initializers. The syntax is [expr1, ...] An array initializer is composed of a pair of \"[]\", and between the brackets, there should be one or more expressions, sparated by commas. An array initializer itself is an expression of array type, and the contents of the resulting array is initialized by the expressions between the brackets. Here are some examples: dim a as int[] = [1,2,3,4] dim b = [ hi , hello ] println(b[0]) #should be hi The compiler will automatically infer the type of the array initializer by the expressions in the brackets. In the above example, the first line's array contains 4 integers, so it is a integer array. In the second line, the two elements of the array are strings, so the variable \"b\" is automatically infered as string[] . When the types of the expressions in the array initializer are not the same, the compiler will try to find the most \"general\" type by the expression types in the array. The rules to find a general type can be found in the \"Auto type conversion\" in \"Basics\" chapter. If the types of expressions are incompatable (or cannot be automatically converted), an error will be raised.","title":"5. Array"},{"location":"Birdee Language Mannual/0050Array/#5-array","text":"","title":"5. Array"},{"location":"Birdee Language Mannual/0050Array/#51-array-basics","text":"An array is an sequential collection of values with the same type. To use an array type, you can append \"[]\" to other types and you will get a array of that type. See example: dim arr1 as int[] Here \"arr1\" is a variable of integer array type. Arrays of objects are also allowed: dim arr2 as string[] You can declare arrays of arrays (multi-dimension array). Here is an example of two-dimension array: dim arr2 as float[][] To use an array, you should first allocate space for it, by \"new\" operator. The syntax is: new {type} * {number_of_elements} For example, to create an array of integer with 10 elements: dim arr as int[] = new int * 10 To create an [10x20] array of float, you can: dim arr2 as float[][] = new float * 10, 20 Finally, you can access the array by \"[ ]\": arr[0]=12 dim c = arr[0] + 23 arr2[1][3]=3.14 Note that surrounded by \"[ ]\" is the index of the array element you want to access. The index must be an integer type (int, uint, long, ulong, ...). Also, the index starts at 0 and ends at number_of_elements-1. If you create an array by \"new int[10]\", the valid index will be within [0 ~ 9]. The array variable is a reference to the array, not the array itself. So the following code: dim arr as int[] = new int * 10 dim arr2 as int[] = new int * 10 arr2 = arr will not copy the array of 10 elements to \"arr2\", but make the variable \"arr2\" points to the same array of \"arr\". So if we assign a value to an element of \"arr\", you can find the change by the variable \"arr2\", because both variables points to the same array! dim arr as int[] = new int * 10 dim arr2 as int[] = new int * 10 arr2 = arr arr[3] = 123 println(int2str(arr2[3])) # you will see 123 Also note that variables for classes are also references. The same effect applies to class variables too. You can access some properties of an array by: dim arr as int[] = new int * 10 println( The number of elements is + arr.length()) #arr.length() gets the # of elements dim ptr as pointer = arr.get_raw() #arr.get_raw() gets the native pointer of the array","title":"5.1 Array basics"},{"location":"Birdee Language Mannual/0050Array/#52-array-initializers","text":"You can create an array and assign inital values of the elements at the same time by array initializers. The syntax is [expr1, ...] An array initializer is composed of a pair of \"[]\", and between the brackets, there should be one or more expressions, sparated by commas. An array initializer itself is an expression of array type, and the contents of the resulting array is initialized by the expressions between the brackets. Here are some examples: dim a as int[] = [1,2,3,4] dim b = [ hi , hello ] println(b[0]) #should be hi The compiler will automatically infer the type of the array initializer by the expressions in the brackets. In the above example, the first line's array contains 4 integers, so it is a integer array. In the second line, the two elements of the array are strings, so the variable \"b\" is automatically infered as string[] . When the types of the expressions in the array initializer are not the same, the compiler will try to find the most \"general\" type by the expression types in the array. The rules to find a general type can be found in the \"Auto type conversion\" in \"Basics\" chapter. If the types of expressions are incompatable (or cannot be automatically converted), an error will be raised.","title":"5.2 Array initializers"},{"location":"Birdee Language Mannual/0060Class/","text":"6. Class 6.1 Basic definitions A class is a structured collection of data. Related variables can be include in a class. To define a class, use the below syntax: class {class_name} ... end [class] The body of a class (\"...\" in above syntax) can be declaration of member variables and member functions. To define a member variable, use the below syntax within the \"class ... end\": public {variable_name} as {type} or private {variable_name} as {type} Note: current version of Birdee does not allow assign initial values to member variables. The \"public\" and \"private\" keywords specify the access modifier of the variable. We will discusses it a bit later. Now we write our first class: class bird public name as string public weight as float end The class describes a bird with a name and a weight. You cannot use the member variables until you create an instance of the class. To create an instance of \"bird\" class, use \"new\" keyword: dim mybird as bird = new bird mybird.name = Birdee mybird.wright = 2.3 println(mybird.name) The member variables can be accessed by a \".\" after a class instance expression, with the name of the member variable. The above example creates an instance of class \"bird\" and assign it to a variable \"mybird\" (Note that the class name can be used as a type!). The example then assign the member variables of \"mybird\". The member variables belongs to the instances of the class. Thus, you cannot use them without a reference to an instance. 6.2 Explanations of terminologies 6.2.1 Class v.s. Class Instance v.s. Object As defined above, a class is the definition of structured data. A class (for example, \"bird\" class) is a type for some data. Class instance is a piece of concrete data of some class. \"string\" is a class, and a string variable is a class instance of string. Class instances are sometimes called \"Objects\". Note that different instances of a class are independent with each other. Assigning the member variable of one instance will not affect the same member variable of others. 6.2.2 Member variables fields They have the same meaning. 6.2.3 Member functions methods They have the same meaning. 6.2.4 Reference Once an object is allocated in memory, how can you find it and operate on it? The answer is by \"reference\". A reference points to a instance of class (or an array). Variables of class/array types holds the references to the instances in the memory (e.g. dim mybird as bird). So copying variables of class/array types copies the references to the instances, instead of copying the object/array themselves. Here we introduce a special reference constant \"null\". It points to actually nothing. You can assign null to any reference typed variable (class, array). If a reference is null, it means that it is an empty value. You should never call a member method or get the field of a null reference, or an error will occur. You can check if a reference is null by: if some_reference !== null then ... end Note that for class object variables, the initial values are null. 6.2.5 \"this\" \"this\" is a reference to the current object in the member function. It is a Birdee keyword that can only be used in member functions. For Birdee code obj.funct() when it is run, in the method \"funct\", \"this\" will point to the object being called - in this case, \"obj\". 6.3 Member functions Member functions can be defined within the scope of the class: {access_modifier} function {function_name} ([ {parameter1} as {type}, {parameter2} as {type}, ... ]) [as {type}] ... end [function] It is similar to the definition of normal functions, except that member functions are defined inside a class, and there is an \"access_modifier\" at the beginning of the function. The \"access_modifier\" can be \"public\", \"private\" or omitted (which will be explained later). We can write a member function in the above \"bird\" class: class bird public name as string public weight as float public function fly() println( my name is + this.name + . I am flying! ) end end You can call \"fly\" on an instance of \"bird\" class: dim mybird as bird = new bird mybird.name = Birdee mybird.wright = 2.3 mybird.fly() The above example of \"bird\" class uses a keyword \"this\" of Birdee to represent the current instance calling the member function (see the line: println(\"my name is \"+ this.name + \". I am flying!\") ) . When the member function is called ( mybird.fly() ), \"this\" will be a reference to the instance pointed by \"mybird\". \"this\" keyword cannot be used outside the class definition. Also, in the member functions, to use the member variables, \"this\" keyword can be omitted. For example \"this.name\" can be simplified to \"name\", when name is a member variable of the same class. Also note that for a member function, if there is a local variable (variables defined in the body of a function or in the arguments) having the same name of a member variable, using the name will result in using the local variable. To use the member variable have a conflicting name, use \"this.XXX\" instead. (XXX is the conflicting name). Note that the member functions cannot be accessed without an instance. 6.4 Access modifier We finally explain what is \"private\" and \"public\" in front of the member variables and functions. If a member variable or function is defined \"private\", no one can access it unless it is a member function of the same class, for example: class bird public name as string public weight as float private secret_name as string end dim mybird as bird = new bird mybird.secret_name= sadas The above code will not compile, because \"secret_name\" is a private member. Access control (making members private/public) is useful when you have some internal variables or functions that you do not want other people to have access to. But remind that a member function can always access all members of the same class, regardless of being private or public. Note that a member function's access modifier can be omitted when defining it, and the access is set to \"public\" by default. 6.5 Initialization destruction We can now create instances by \"new\". But what if we want to initialze the object while creating it? The syntax of \"New with initialization\" can be use. new {class_name}.{method_name}([arg1,arg2,....]) The class_name is the name of the class of the instance to be created. The method_name is the member function name to be called after the creation of the object. The function should be a public function. Here is an example: class bird public name as string public weight as float public void init(name as string, weight as float) this.name=name this.weight=weight end end dim mybird as bird = new bird.init( birdee ,2.13) The above example creates and initializes a \"bird\" object, which is equivalent to: dim mybird as bird = new bird mybird.init( birdee ,2.13) Note: the \"New with initialization\" will discard the return value of the called function and will always return the created instance. When the class has a \"__init__\" method defined in the class body, users can use \"New with initialization\" in a simpler way. The following code: dim obj = new SomeClass( hi ) will create an new instance of class SomeClass and call obj.__init__(\"hi\") for initialization. If the \"__init__\" method has no arguments, users can further save the \"(...)\" for calling \"__init__\": class SomeClass public function __init__() end end dim obj = new SomeClass #__init__ will be called here. Note that \"__init__\" must be a public function in the class. Birdee uses garbage collection for memory management, which means when the object created is no longer used (when there are no references pointing to the object), the object will be automatically delected. If the object has \"__del__\" method defined, when it is deleted and, the method will be called. You can do some finalization work in this method. 6.6 Operator overloading Operator overloading means you can apply basic operators (like +,-,*,/,...) on you own class and define your classes' own behavior on them. We are acutally familar with the use of operator overload, which is used in \"+\" operator of string. (Don't forget that \"string\" is simply a class defined by Birdee!). We can use \"+\" to concatenate two strings: println( string A + string B ) There is no magic in it and Birdee implements it using operator overload. To overload operator \"+\", you must define a special member function \"__add__\" in your class: class complex public real as double public imaginary as double public function __add__(complex other) as complex return new complex:set(this.real + other.real, this.imaginary + other.imaginary) end public function set(real as double,imaginary as double) this.real=real this.imaginary=imaginary end end dim v1 = new complex:set(1,3), v2 = new complex:set(2,4) dim v3 = v1 + v2 println(double2str(v3.real)) The above example defines a complex number class. It overloads \"+\" by the function \"__add__\". The function accepts another \"complex\" object and creates a new complex object as the result. It then creates two complex numbers (1,3) and (2,4), add them and store in variable \"v3\" and print the real part of the result. The line \"dim v3 = v1 + v2\" will be equivalent to: dim v3 = v1.__add__(v2) There are other operators that can be overloaded. The operators and functions to implement are listed in the below table: Operator Function Name to implement Operand + __add__ The other object - __sub__ The other object * __mul__ The other object / __div__ The other object % __mod__ The other object == __eq__ The other object != __ne__ The other object = __ge__ The other object = __le__ The other object __gt__ The other object __lt__ The other object || __logic_or__ The other object | __or__ The other object __logic_and__ The other object __and__ The other object ^ __xor__ The other object ! __not__ None * (added before an expression) __deref__ None Array read __getitem__ The \"index\" Array write __setitem__ The \"index\" and the object to \"put\" in For a class object, if an operator is applied, the corresponding method will be called. If the method is not defined or it is private, a compile error will be raised. For overloaded binary opeartors (operators with two opearnds), \"A ? B\", where \"?\" is any binary operators, is equivalent to \"A.__XXXX__(B)\", where \"__XXXX__\" is the corresponding method. For overloaded unary operators (operators with one operand), using them is equivalent to \"A.__XXXX__()\", where \"__XXXX__\" is the corresponding method. Operators for array read write are special cases for operator overloading. These two operators overloads the \"[]\" operator which is originally used for accessing array elements. If the indexed object is to be read \"from\" an object, the \"__getitem__\" method will be called. For Birdee code like dim a = obj[ 123 ] where the variable \"obj\" is not an array, the compiler will first the \"__getitem__\" method of the class of \"obj\". The actual generated code will be dim a = obj.__getitem__( 123 ) Similarly, if the indexed element is written (on the left of the \"=\"), the method \"__setitem__\" will be called. The first parameter should be the index and the second parameter should be the value to be written to the object. For example, the following two lines of code have the same effect: obj[ 123 ]=34 obj.__setitem__( 123 ,34) The existence of the method \"__setitem__\" is optional, as long as you never \"write\" to an indexed element. However, if you want to overload \"[]\", the method \"__getitem__\" should always be defined in the class. Note that the type of parameters of methods for operator overloading is not necessarily the same class of the current class. They can be any valid types. Also note that you can use function templates for operator overloading. Templates will be later introduced. 6.7 Class inherit 6.7.1 Basic inherit Class can inherit another class's public members through class inherit. The inherited class is also called parent class. A class with parent class is usually viewed as a specification of its parent. The following codes: class ParentClass private a as int public b as int public function get() as int return a end end class SomeClass : ParentClass public function __init__() end public function get2() as int return b + get() end end define a class named \"SomeClass\" with a parent class named \"ParentClass\", and SomeClass inherits member field \"b\" and member function \"get()\" from ParentClass, note that member field \"a\" is not inherited since it's private to ParentClass. Also, SomeClass can access the member it inherits inside class directly, as showed in the example. Besides, the following code: class ParentClass public function __init__() end public function __del__() end public function __not__() as boolean return true end end class SomeClass : ParentClass public function __init__() end public function __del__() end end dim foo = new SomeClass dim bar = !foo shows an example of class inherit with special member functions. Note that in code \"dim foo = new SomeClass\", the function init () of SomeClass will be automatically called, but init () of ParentClass will not! Also, the del () of SomeClass will be automatically called when garbadge collected, but del () of ParentClass will not. And the code \"dim bar = !foo\" won't compile because SomeClass does not contain an operator overloading function for !. Even if SomeClass inherits one from ParentClass, the compiler will not automatically call it. 6.7.2 \"super\" What if we want the functions in parent be called during above scenarios? We can use the \"super\" keyword. Similar to \"this\" keyword, \"super\" keyword represents a built-in reference inside class. However, \"this\" refers to the instance itself, while \"super\" refers to the parent part of the instance. That is to say, we can use \"super\" keyword to only access the members inherited from parent. With \"super\" keyword, the above code can be modified to: class ParentClass public function __init__() end public function __del__() end public function __not__() as boolean return true end end class SomeClass : ParentClass public function __init__() super.__init__() end public function __del__() super.__del__() end public function __not__() as boolean return super.__not__() end end dim foo = new SomeClass dim bar = !foo Then, the code will compile and the special functions of parent will be called automatically. 6.8 Run Time Type Information (RTTI) You can get the type information of an object at the run time, as long as the type of the object has Run Time Type Information (RTTI) enabled. The RTTI describes the name and the inherience information of a class. By default, RTTI will not be generated for classes unless the classes has virtual functions. You can manually enable RTTI on a class by adding \"@enable_rtti\" before the \"class\" keyword of a class. The following example shows three classes with RTTI. Note that classes with virtual functions automatically include RTTI. @enable_rtti class A end class B @virtual public function b() end end class C public c as int @virtual public function b() end end Note that if a class has RTTI enabled, all classes extending (inheriting from) it will be automatically marked RTTI-enabled. If a class is manually marked enable_rtti , either it has no parent class, or it should extend a class with RTTI. Given an expression, the RTTI data can be fetched by the keyword typeof . The returned value of typeof(some_expression) is an object of class type_info , which contains the RTTI of the class of the expression. The class type_info has a method to get the name of the class - get_name , and it has a method public function is_parent_of(child as type_info) as boolean to check if another class (represented by RTTI) is inherited from the current class. Also, the type_info class has a method public function get_parent() as type_info to get RTTI of the parent class. If a class has no parent class, the method returns null. See the following example: dim a as B = new C println(typeof(a).get_name()) # should print XXXX.C println(typeof(a).get_parent().get_name()) # should print XXXX.B The variable \"a\" is declared as an object in class B. But it is assigned with an instance of class C. Using typeof operator, we can get the exact type of the variable \"a\". The typeof operator will execute the expression and extract the reference to the RTTI object at the run time. The expressions to be evaluated by typeof should be of classes with RTTI, otherwise the compiler will throw an error. A unique RTTI object will be created for each different class. Class template instances are different classes with different RTTIs. Given a type, the RTTI can be fetched by a special function get_type_info[T] defined in module rtti . You can import this function by import rtti:get_type_info . You need to replace T with the class you need to fetch for RTTI. T can only be classes with RTTI. RTTI is useful when a variable is assigned with a subclass of the class which the variable is defined. Developers may want to check if the variable really holds an object in a subclass. Since RTTI for a class is unique, we can compare the references of type_info (RTTI) by === to check that: import rtti:get_type_info dim a as B = new C if typeof(a)===get_type_info[C]() then println( the variable a is of class C ) end The subclass checking and safe down-casting can be done with RTTI. Birdee provides the function dyn_cast in the module rtti to safely convert a superclass reference to a subclass reference. import rtti:dyn_cast dim a as B = new C dim c as C = dyn_cast[C](a) priintln(int2str(c.c)) The above code converts a variable \"a\" of superclass \"B\" to variable \"c\" of subclass \"C\", using dyn_cast[C] . The function dyn_cast[C] will convert the reference in the parameter to a reference of class \"C\". If the object pointered by the given parameter is not an instance of \"C\" or subclass of \"C\", dyn_cast[C] will return null. You can replace 'C' here with other classes with RTTI. dyn_cast[...] is a system provided function, which internally compares the RTTIs of the classes. Enabling RTTI has some overhead in space. If a class has RTTI, all of its instance has one additional hidden member pointing to the type_info object of the class. 6.9 Abstract Class Interface TODO 6.10 Structs Struct is a similar but different concept as class. Structs can be similarly defined as classes. You just need to replace \"class\" keyword with \"struct\". struct {name} ... end [struct] The member variables and functions can be similarly defined and used in structs. So what's the difference between struct and class? One key difference is that for local variables defined in functions, structs are allocated on the stack and class objects are allocated on the heap. The access and allocation of data on the stack is much faster than on the heap. Also, once the program leaves the scope of a function, the space of the local struct variables will be deallocated. The second difference is that, in the context of Birdee, variables of \"class\" has \"reference semantic\", while variables of \"struct\" has \"value semantic\". A class variable (including local, global and member one) is always a reference to an object in the heap or null. If you copy a class object variable, you just copy the reference to the object, not the actual data of object. On the other hand, copying struct variables (by operator \"=\") or implicitly copying struct variables (in function parameters), you will copy the whole struct object. Hence, struct variables are \"values\", not \"references\". If a class/struct, say \"A\", has a class, say \"B\", member variable, the class/struct A only holds a refernce to B. But if \"B\" is changed to struct, \"B\" will embeded into the memory layout of \"A\", which means allocating an object of \"A\" will implicitly allocate space for \"B\". So you should be careful when the struct has many fields - copying these structs involves large amounts of memory copying. Some notes on struct: Operator overloading is supported in structs. You cannot enable RTTI on struct Important: The \"__del__\" methods of structs will not be automatically called when the structs objects are destroyed!","title":"6. Class"},{"location":"Birdee Language Mannual/0060Class/#6-class","text":"","title":"6. Class"},{"location":"Birdee Language Mannual/0060Class/#61-basic-definitions","text":"A class is a structured collection of data. Related variables can be include in a class. To define a class, use the below syntax: class {class_name} ... end [class] The body of a class (\"...\" in above syntax) can be declaration of member variables and member functions. To define a member variable, use the below syntax within the \"class ... end\": public {variable_name} as {type} or private {variable_name} as {type} Note: current version of Birdee does not allow assign initial values to member variables. The \"public\" and \"private\" keywords specify the access modifier of the variable. We will discusses it a bit later. Now we write our first class: class bird public name as string public weight as float end The class describes a bird with a name and a weight. You cannot use the member variables until you create an instance of the class. To create an instance of \"bird\" class, use \"new\" keyword: dim mybird as bird = new bird mybird.name = Birdee mybird.wright = 2.3 println(mybird.name) The member variables can be accessed by a \".\" after a class instance expression, with the name of the member variable. The above example creates an instance of class \"bird\" and assign it to a variable \"mybird\" (Note that the class name can be used as a type!). The example then assign the member variables of \"mybird\". The member variables belongs to the instances of the class. Thus, you cannot use them without a reference to an instance.","title":"6.1 Basic definitions"},{"location":"Birdee Language Mannual/0060Class/#62-explanations-of-terminologies","text":"","title":"6.2 Explanations of terminologies"},{"location":"Birdee Language Mannual/0060Class/#621-class-vs-class-instance-vs-object","text":"As defined above, a class is the definition of structured data. A class (for example, \"bird\" class) is a type for some data. Class instance is a piece of concrete data of some class. \"string\" is a class, and a string variable is a class instance of string. Class instances are sometimes called \"Objects\". Note that different instances of a class are independent with each other. Assigning the member variable of one instance will not affect the same member variable of others.","title":"6.2.1 Class v.s. Class Instance v.s. Object"},{"location":"Birdee Language Mannual/0060Class/#622-member-variables-fields","text":"They have the same meaning.","title":"6.2.2 Member variables &amp; fields"},{"location":"Birdee Language Mannual/0060Class/#623-member-functions-methods","text":"They have the same meaning.","title":"6.2.3 Member functions &amp; methods"},{"location":"Birdee Language Mannual/0060Class/#624-reference","text":"Once an object is allocated in memory, how can you find it and operate on it? The answer is by \"reference\". A reference points to a instance of class (or an array). Variables of class/array types holds the references to the instances in the memory (e.g. dim mybird as bird). So copying variables of class/array types copies the references to the instances, instead of copying the object/array themselves. Here we introduce a special reference constant \"null\". It points to actually nothing. You can assign null to any reference typed variable (class, array). If a reference is null, it means that it is an empty value. You should never call a member method or get the field of a null reference, or an error will occur. You can check if a reference is null by: if some_reference !== null then ... end Note that for class object variables, the initial values are null.","title":"6.2.4 Reference"},{"location":"Birdee Language Mannual/0060Class/#625-this","text":"\"this\" is a reference to the current object in the member function. It is a Birdee keyword that can only be used in member functions. For Birdee code obj.funct() when it is run, in the method \"funct\", \"this\" will point to the object being called - in this case, \"obj\".","title":"6.2.5 \"this\""},{"location":"Birdee Language Mannual/0060Class/#63-member-functions","text":"Member functions can be defined within the scope of the class: {access_modifier} function {function_name} ([ {parameter1} as {type}, {parameter2} as {type}, ... ]) [as {type}] ... end [function] It is similar to the definition of normal functions, except that member functions are defined inside a class, and there is an \"access_modifier\" at the beginning of the function. The \"access_modifier\" can be \"public\", \"private\" or omitted (which will be explained later). We can write a member function in the above \"bird\" class: class bird public name as string public weight as float public function fly() println( my name is + this.name + . I am flying! ) end end You can call \"fly\" on an instance of \"bird\" class: dim mybird as bird = new bird mybird.name = Birdee mybird.wright = 2.3 mybird.fly() The above example of \"bird\" class uses a keyword \"this\" of Birdee to represent the current instance calling the member function (see the line: println(\"my name is \"+ this.name + \". I am flying!\") ) . When the member function is called ( mybird.fly() ), \"this\" will be a reference to the instance pointed by \"mybird\". \"this\" keyword cannot be used outside the class definition. Also, in the member functions, to use the member variables, \"this\" keyword can be omitted. For example \"this.name\" can be simplified to \"name\", when name is a member variable of the same class. Also note that for a member function, if there is a local variable (variables defined in the body of a function or in the arguments) having the same name of a member variable, using the name will result in using the local variable. To use the member variable have a conflicting name, use \"this.XXX\" instead. (XXX is the conflicting name). Note that the member functions cannot be accessed without an instance.","title":"6.3 Member functions"},{"location":"Birdee Language Mannual/0060Class/#64-access-modifier","text":"We finally explain what is \"private\" and \"public\" in front of the member variables and functions. If a member variable or function is defined \"private\", no one can access it unless it is a member function of the same class, for example: class bird public name as string public weight as float private secret_name as string end dim mybird as bird = new bird mybird.secret_name= sadas The above code will not compile, because \"secret_name\" is a private member. Access control (making members private/public) is useful when you have some internal variables or functions that you do not want other people to have access to. But remind that a member function can always access all members of the same class, regardless of being private or public. Note that a member function's access modifier can be omitted when defining it, and the access is set to \"public\" by default.","title":"6.4 Access modifier"},{"location":"Birdee Language Mannual/0060Class/#65-initialization-destruction","text":"We can now create instances by \"new\". But what if we want to initialze the object while creating it? The syntax of \"New with initialization\" can be use. new {class_name}.{method_name}([arg1,arg2,....]) The class_name is the name of the class of the instance to be created. The method_name is the member function name to be called after the creation of the object. The function should be a public function. Here is an example: class bird public name as string public weight as float public void init(name as string, weight as float) this.name=name this.weight=weight end end dim mybird as bird = new bird.init( birdee ,2.13) The above example creates and initializes a \"bird\" object, which is equivalent to: dim mybird as bird = new bird mybird.init( birdee ,2.13) Note: the \"New with initialization\" will discard the return value of the called function and will always return the created instance. When the class has a \"__init__\" method defined in the class body, users can use \"New with initialization\" in a simpler way. The following code: dim obj = new SomeClass( hi ) will create an new instance of class SomeClass and call obj.__init__(\"hi\") for initialization. If the \"__init__\" method has no arguments, users can further save the \"(...)\" for calling \"__init__\": class SomeClass public function __init__() end end dim obj = new SomeClass #__init__ will be called here. Note that \"__init__\" must be a public function in the class. Birdee uses garbage collection for memory management, which means when the object created is no longer used (when there are no references pointing to the object), the object will be automatically delected. If the object has \"__del__\" method defined, when it is deleted and, the method will be called. You can do some finalization work in this method.","title":"6.5 Initialization &amp; destruction"},{"location":"Birdee Language Mannual/0060Class/#66-operator-overloading","text":"Operator overloading means you can apply basic operators (like +,-,*,/,...) on you own class and define your classes' own behavior on them. We are acutally familar with the use of operator overload, which is used in \"+\" operator of string. (Don't forget that \"string\" is simply a class defined by Birdee!). We can use \"+\" to concatenate two strings: println( string A + string B ) There is no magic in it and Birdee implements it using operator overload. To overload operator \"+\", you must define a special member function \"__add__\" in your class: class complex public real as double public imaginary as double public function __add__(complex other) as complex return new complex:set(this.real + other.real, this.imaginary + other.imaginary) end public function set(real as double,imaginary as double) this.real=real this.imaginary=imaginary end end dim v1 = new complex:set(1,3), v2 = new complex:set(2,4) dim v3 = v1 + v2 println(double2str(v3.real)) The above example defines a complex number class. It overloads \"+\" by the function \"__add__\". The function accepts another \"complex\" object and creates a new complex object as the result. It then creates two complex numbers (1,3) and (2,4), add them and store in variable \"v3\" and print the real part of the result. The line \"dim v3 = v1 + v2\" will be equivalent to: dim v3 = v1.__add__(v2) There are other operators that can be overloaded. The operators and functions to implement are listed in the below table: Operator Function Name to implement Operand + __add__ The other object - __sub__ The other object * __mul__ The other object / __div__ The other object % __mod__ The other object == __eq__ The other object != __ne__ The other object = __ge__ The other object = __le__ The other object __gt__ The other object __lt__ The other object || __logic_or__ The other object | __or__ The other object __logic_and__ The other object __and__ The other object ^ __xor__ The other object ! __not__ None * (added before an expression) __deref__ None Array read __getitem__ The \"index\" Array write __setitem__ The \"index\" and the object to \"put\" in For a class object, if an operator is applied, the corresponding method will be called. If the method is not defined or it is private, a compile error will be raised. For overloaded binary opeartors (operators with two opearnds), \"A ? B\", where \"?\" is any binary operators, is equivalent to \"A.__XXXX__(B)\", where \"__XXXX__\" is the corresponding method. For overloaded unary operators (operators with one operand), using them is equivalent to \"A.__XXXX__()\", where \"__XXXX__\" is the corresponding method. Operators for array read write are special cases for operator overloading. These two operators overloads the \"[]\" operator which is originally used for accessing array elements. If the indexed object is to be read \"from\" an object, the \"__getitem__\" method will be called. For Birdee code like dim a = obj[ 123 ] where the variable \"obj\" is not an array, the compiler will first the \"__getitem__\" method of the class of \"obj\". The actual generated code will be dim a = obj.__getitem__( 123 ) Similarly, if the indexed element is written (on the left of the \"=\"), the method \"__setitem__\" will be called. The first parameter should be the index and the second parameter should be the value to be written to the object. For example, the following two lines of code have the same effect: obj[ 123 ]=34 obj.__setitem__( 123 ,34) The existence of the method \"__setitem__\" is optional, as long as you never \"write\" to an indexed element. However, if you want to overload \"[]\", the method \"__getitem__\" should always be defined in the class. Note that the type of parameters of methods for operator overloading is not necessarily the same class of the current class. They can be any valid types. Also note that you can use function templates for operator overloading. Templates will be later introduced.","title":"6.6 Operator overloading"},{"location":"Birdee Language Mannual/0060Class/#67-class-inherit","text":"","title":"6.7 Class inherit"},{"location":"Birdee Language Mannual/0060Class/#671-basic-inherit","text":"Class can inherit another class's public members through class inherit. The inherited class is also called parent class. A class with parent class is usually viewed as a specification of its parent. The following codes: class ParentClass private a as int public b as int public function get() as int return a end end class SomeClass : ParentClass public function __init__() end public function get2() as int return b + get() end end define a class named \"SomeClass\" with a parent class named \"ParentClass\", and SomeClass inherits member field \"b\" and member function \"get()\" from ParentClass, note that member field \"a\" is not inherited since it's private to ParentClass. Also, SomeClass can access the member it inherits inside class directly, as showed in the example. Besides, the following code: class ParentClass public function __init__() end public function __del__() end public function __not__() as boolean return true end end class SomeClass : ParentClass public function __init__() end public function __del__() end end dim foo = new SomeClass dim bar = !foo shows an example of class inherit with special member functions. Note that in code \"dim foo = new SomeClass\", the function init () of SomeClass will be automatically called, but init () of ParentClass will not! Also, the del () of SomeClass will be automatically called when garbadge collected, but del () of ParentClass will not. And the code \"dim bar = !foo\" won't compile because SomeClass does not contain an operator overloading function for !. Even if SomeClass inherits one from ParentClass, the compiler will not automatically call it.","title":"6.7.1 Basic inherit"},{"location":"Birdee Language Mannual/0060Class/#672-super","text":"What if we want the functions in parent be called during above scenarios? We can use the \"super\" keyword. Similar to \"this\" keyword, \"super\" keyword represents a built-in reference inside class. However, \"this\" refers to the instance itself, while \"super\" refers to the parent part of the instance. That is to say, we can use \"super\" keyword to only access the members inherited from parent. With \"super\" keyword, the above code can be modified to: class ParentClass public function __init__() end public function __del__() end public function __not__() as boolean return true end end class SomeClass : ParentClass public function __init__() super.__init__() end public function __del__() super.__del__() end public function __not__() as boolean return super.__not__() end end dim foo = new SomeClass dim bar = !foo Then, the code will compile and the special functions of parent will be called automatically.","title":"6.7.2 \"super\""},{"location":"Birdee Language Mannual/0060Class/#68-run-time-type-information-rtti","text":"You can get the type information of an object at the run time, as long as the type of the object has Run Time Type Information (RTTI) enabled. The RTTI describes the name and the inherience information of a class. By default, RTTI will not be generated for classes unless the classes has virtual functions. You can manually enable RTTI on a class by adding \"@enable_rtti\" before the \"class\" keyword of a class. The following example shows three classes with RTTI. Note that classes with virtual functions automatically include RTTI. @enable_rtti class A end class B @virtual public function b() end end class C public c as int @virtual public function b() end end Note that if a class has RTTI enabled, all classes extending (inheriting from) it will be automatically marked RTTI-enabled. If a class is manually marked enable_rtti , either it has no parent class, or it should extend a class with RTTI. Given an expression, the RTTI data can be fetched by the keyword typeof . The returned value of typeof(some_expression) is an object of class type_info , which contains the RTTI of the class of the expression. The class type_info has a method to get the name of the class - get_name , and it has a method public function is_parent_of(child as type_info) as boolean to check if another class (represented by RTTI) is inherited from the current class. Also, the type_info class has a method public function get_parent() as type_info to get RTTI of the parent class. If a class has no parent class, the method returns null. See the following example: dim a as B = new C println(typeof(a).get_name()) # should print XXXX.C println(typeof(a).get_parent().get_name()) # should print XXXX.B The variable \"a\" is declared as an object in class B. But it is assigned with an instance of class C. Using typeof operator, we can get the exact type of the variable \"a\". The typeof operator will execute the expression and extract the reference to the RTTI object at the run time. The expressions to be evaluated by typeof should be of classes with RTTI, otherwise the compiler will throw an error. A unique RTTI object will be created for each different class. Class template instances are different classes with different RTTIs. Given a type, the RTTI can be fetched by a special function get_type_info[T] defined in module rtti . You can import this function by import rtti:get_type_info . You need to replace T with the class you need to fetch for RTTI. T can only be classes with RTTI. RTTI is useful when a variable is assigned with a subclass of the class which the variable is defined. Developers may want to check if the variable really holds an object in a subclass. Since RTTI for a class is unique, we can compare the references of type_info (RTTI) by === to check that: import rtti:get_type_info dim a as B = new C if typeof(a)===get_type_info[C]() then println( the variable a is of class C ) end The subclass checking and safe down-casting can be done with RTTI. Birdee provides the function dyn_cast in the module rtti to safely convert a superclass reference to a subclass reference. import rtti:dyn_cast dim a as B = new C dim c as C = dyn_cast[C](a) priintln(int2str(c.c)) The above code converts a variable \"a\" of superclass \"B\" to variable \"c\" of subclass \"C\", using dyn_cast[C] . The function dyn_cast[C] will convert the reference in the parameter to a reference of class \"C\". If the object pointered by the given parameter is not an instance of \"C\" or subclass of \"C\", dyn_cast[C] will return null. You can replace 'C' here with other classes with RTTI. dyn_cast[...] is a system provided function, which internally compares the RTTIs of the classes. Enabling RTTI has some overhead in space. If a class has RTTI, all of its instance has one additional hidden member pointing to the type_info object of the class.","title":"6.8 Run Time Type Information (RTTI)"},{"location":"Birdee Language Mannual/0060Class/#69-abstract-class-interface","text":"TODO","title":"6.9 Abstract Class &amp; Interface"},{"location":"Birdee Language Mannual/0060Class/#610-structs","text":"Struct is a similar but different concept as class. Structs can be similarly defined as classes. You just need to replace \"class\" keyword with \"struct\". struct {name} ... end [struct] The member variables and functions can be similarly defined and used in structs. So what's the difference between struct and class? One key difference is that for local variables defined in functions, structs are allocated on the stack and class objects are allocated on the heap. The access and allocation of data on the stack is much faster than on the heap. Also, once the program leaves the scope of a function, the space of the local struct variables will be deallocated. The second difference is that, in the context of Birdee, variables of \"class\" has \"reference semantic\", while variables of \"struct\" has \"value semantic\". A class variable (including local, global and member one) is always a reference to an object in the heap or null. If you copy a class object variable, you just copy the reference to the object, not the actual data of object. On the other hand, copying struct variables (by operator \"=\") or implicitly copying struct variables (in function parameters), you will copy the whole struct object. Hence, struct variables are \"values\", not \"references\". If a class/struct, say \"A\", has a class, say \"B\", member variable, the class/struct A only holds a refernce to B. But if \"B\" is changed to struct, \"B\" will embeded into the memory layout of \"A\", which means allocating an object of \"A\" will implicitly allocate space for \"B\". So you should be careful when the struct has many fields - copying these structs involves large amounts of memory copying. Some notes on struct: Operator overloading is supported in structs. You cannot enable RTTI on struct Important: The \"__del__\" methods of structs will not be automatically called when the structs objects are destroyed!","title":"6.10 Structs"},{"location":"Birdee Language Mannual/0070Import/","text":"7. Modules and Imports Birdee programs can be encapsulated into modules. A module is a collection of functions, classes and global variables that can be invoked and used by other Birdee code. A similar concept for Birdee's module is the object files in C/C++ compilation systems. The main difference is that Birdee's modules contains metadata to describe the prototype of the exported functions, the definitions of the classes and the types of the exported variables in the module, while in C/C++, an object file is just a collection of code and variable, and users must write a header file or explicitly declare the variables and functions with \"extern\" keyword. Such header files are no longer needed in Birdee. When a Birdee program is compiled by the \"birdeec\" compiler, the source code will be converted into a module, which consists of an object file (which can be linked with C/C++ object files) and a metadata file (*.bmm file. \"bmm\" represents \"Birdee Module Metadata\") which describes the variables, classes and functions of the module. To use a module that already exists, users can use \"import\" keyword in the Birdee code. Note that a module can \"import\" multiple existing modules and all \"import\" should be written at the beginning of the Birdee code before any other top level code. The functions, classes and variables in the top-level of a module are called symbols. After importing a module, the symbols can be used in the current Birdee module. Note that if a module is imported by any syntax above, the top-level code of the imported library will be executed exactly once. There are 4 ways to import an external module. 7.1 Module Import The first form of syntax is: import {module_name} The \"module_name\" is composed of directory names separated by dots (\".\"). The Birdee compiler will search the local file system for the module to be imported using the path provided by the \"module_name\". There are two ways setting the root path of searching the modules. One way is to set the \"BIRDEE_HOME\" environment variable in your OS. The compiler will search \"BIRDEE_HOME/blib\" for the target module. Another way is to set a module search path in the command line arguments for \"birdeec\" with \"-l\" switch. The compiler will first try to find the target module with root directory set by the command line arguments, then by the \"BIRDEE_HOME\" environment variable. For example, if the \"BIRDEE_HOME\" is set as \"/home/menooker/birdee\" and we have a \"-l /sourcecode/mylib\" argument in the command line, to resolve the code \"import sys.net.socket\" (let's assume there exists such a module), the compiler will first find \"/sourcecode/mylib/sys/net/socket.bmm\". If it does not exist, \"/home/menooker/birdee/blib/sys/net/socket.bmm\" will be searched. After importing with this syntax, users can use \"{module_name}.{symbol_name}\" to access the variables, functions or classes in the module. For example, import sys.net.socket sys.net.socket.connect( 192.168.0.1 ,999) The \"{module_name}.{symbol_name}\" is called qualified name of a symbol. However, the module we are talking about here has not been implemented yet unfortunately. 7.2 Symbol Import The second form of syntax is: import {module_name}:{symbol_name} This form of import will do \"module import\" just as the last section does. In addition, it will import a symbol name of a variable, function or class from the target module. Users can simply use \"symbol_name\" to access the the symbol instead of the long qualified name. For example import sys.net.socket:connect connect( 192.168.0.1 ,999) 7.3 All Symbols Import All symbols import will do \"Symbol Import\" on all symbols of the target module. The syntax is: import {module_name}:* After all symbols import, the variables, functions and classes can be accessed using the names instead of qualified names. For example import sys.net.socket:* connect( 192.168.0.1 ,999) 7.4 Auto Import The compiler will automatically import all symbols from some core modules of Birdee, such as \"birdee.bmm\". \"birdee.bmm\" contains the core features like \"string\", \"println\". 7.5 Private symbols As we have discussed above, the classes, variables and functions (include function declartions) in the top-level will be exported in a Birdee module, which can be used by other modules. Sometimes, developers do not want to expose the internal classes/variables/functions of a module. In this case, they can add \"@private\" before the symbols (classes/variables/functions) that they want to hide from other modules. If a symbol is marked \"private\", other modules cannot access it by importing the module. Here is an example of a module with private symbols: @private dim private_v = 1 #the private can be followed by a space @private class someclass #the private can be followed by a newline end function foo() #by default, it is public end 7.6 Import using scripts You can use a Python expression to generate the module name and the symbol to import at the compile time by import {@PYTHONSCRIPT@} or by import module_name:{@PYTHONSCRIPT@} The code between \"{@\" and \"@}\" should be a Python string expression. Birdee compiler will execute the Python code to get the module name and the symbol name to import. This feature is useful when your code needs to support multiple platforms. The following example shows how to import a module on Windows and import another module on Linux. import {@ system.specific.win32.file if get_os_name()== windows else system.specific.unistd.file @}:* In this example, the modules system.specific.win32.file and system.specific.unistd.file contains operation system specific code, but they provide the same interfaces for the user of these two modules. The users of the modules do not need to modify their own code to make the code platform independent.","title":"7. Modules and Imports"},{"location":"Birdee Language Mannual/0070Import/#7-modules-and-imports","text":"Birdee programs can be encapsulated into modules. A module is a collection of functions, classes and global variables that can be invoked and used by other Birdee code. A similar concept for Birdee's module is the object files in C/C++ compilation systems. The main difference is that Birdee's modules contains metadata to describe the prototype of the exported functions, the definitions of the classes and the types of the exported variables in the module, while in C/C++, an object file is just a collection of code and variable, and users must write a header file or explicitly declare the variables and functions with \"extern\" keyword. Such header files are no longer needed in Birdee. When a Birdee program is compiled by the \"birdeec\" compiler, the source code will be converted into a module, which consists of an object file (which can be linked with C/C++ object files) and a metadata file (*.bmm file. \"bmm\" represents \"Birdee Module Metadata\") which describes the variables, classes and functions of the module. To use a module that already exists, users can use \"import\" keyword in the Birdee code. Note that a module can \"import\" multiple existing modules and all \"import\" should be written at the beginning of the Birdee code before any other top level code. The functions, classes and variables in the top-level of a module are called symbols. After importing a module, the symbols can be used in the current Birdee module. Note that if a module is imported by any syntax above, the top-level code of the imported library will be executed exactly once. There are 4 ways to import an external module.","title":"7. Modules and Imports"},{"location":"Birdee Language Mannual/0070Import/#71-module-import","text":"The first form of syntax is: import {module_name} The \"module_name\" is composed of directory names separated by dots (\".\"). The Birdee compiler will search the local file system for the module to be imported using the path provided by the \"module_name\". There are two ways setting the root path of searching the modules. One way is to set the \"BIRDEE_HOME\" environment variable in your OS. The compiler will search \"BIRDEE_HOME/blib\" for the target module. Another way is to set a module search path in the command line arguments for \"birdeec\" with \"-l\" switch. The compiler will first try to find the target module with root directory set by the command line arguments, then by the \"BIRDEE_HOME\" environment variable. For example, if the \"BIRDEE_HOME\" is set as \"/home/menooker/birdee\" and we have a \"-l /sourcecode/mylib\" argument in the command line, to resolve the code \"import sys.net.socket\" (let's assume there exists such a module), the compiler will first find \"/sourcecode/mylib/sys/net/socket.bmm\". If it does not exist, \"/home/menooker/birdee/blib/sys/net/socket.bmm\" will be searched. After importing with this syntax, users can use \"{module_name}.{symbol_name}\" to access the variables, functions or classes in the module. For example, import sys.net.socket sys.net.socket.connect( 192.168.0.1 ,999) The \"{module_name}.{symbol_name}\" is called qualified name of a symbol. However, the module we are talking about here has not been implemented yet unfortunately.","title":"7.1 Module Import"},{"location":"Birdee Language Mannual/0070Import/#72-symbol-import","text":"The second form of syntax is: import {module_name}:{symbol_name} This form of import will do \"module import\" just as the last section does. In addition, it will import a symbol name of a variable, function or class from the target module. Users can simply use \"symbol_name\" to access the the symbol instead of the long qualified name. For example import sys.net.socket:connect connect( 192.168.0.1 ,999)","title":"7.2 Symbol Import"},{"location":"Birdee Language Mannual/0070Import/#73-all-symbols-import","text":"All symbols import will do \"Symbol Import\" on all symbols of the target module. The syntax is: import {module_name}:* After all symbols import, the variables, functions and classes can be accessed using the names instead of qualified names. For example import sys.net.socket:* connect( 192.168.0.1 ,999)","title":"7.3 All Symbols Import"},{"location":"Birdee Language Mannual/0070Import/#74-auto-import","text":"The compiler will automatically import all symbols from some core modules of Birdee, such as \"birdee.bmm\". \"birdee.bmm\" contains the core features like \"string\", \"println\".","title":"7.4 Auto Import"},{"location":"Birdee Language Mannual/0070Import/#75-private-symbols","text":"As we have discussed above, the classes, variables and functions (include function declartions) in the top-level will be exported in a Birdee module, which can be used by other modules. Sometimes, developers do not want to expose the internal classes/variables/functions of a module. In this case, they can add \"@private\" before the symbols (classes/variables/functions) that they want to hide from other modules. If a symbol is marked \"private\", other modules cannot access it by importing the module. Here is an example of a module with private symbols: @private dim private_v = 1 #the private can be followed by a space @private class someclass #the private can be followed by a newline end function foo() #by default, it is public end","title":"7.5 Private symbols"},{"location":"Birdee Language Mannual/0070Import/#76-import-using-scripts","text":"You can use a Python expression to generate the module name and the symbol to import at the compile time by import {@PYTHONSCRIPT@} or by import module_name:{@PYTHONSCRIPT@} The code between \"{@\" and \"@}\" should be a Python string expression. Birdee compiler will execute the Python code to get the module name and the symbol name to import. This feature is useful when your code needs to support multiple platforms. The following example shows how to import a module on Windows and import another module on Linux. import {@ system.specific.win32.file if get_os_name()== windows else system.specific.unistd.file @}:* In this example, the modules system.specific.win32.file and system.specific.unistd.file contains operation system specific code, but they provide the same interfaces for the user of these two modules. The users of the modules do not need to modify their own code to make the code platform independent.","title":"7.6 Import using scripts"},{"location":"Birdee Language Mannual/0080Template/","text":"8. Templates We explain the use of templates with the following example. Assume we have a function doing addition on int: function add(a as int, b as int) as int return a+b end What if we want a function adding floats? We may re-write an similar function: function add(a as float, b as float) as float return a+b end What if we want a function adding strings, or custom class objects? Writing so many functions that is almost the same? We can use templates! 8.1 Function Templates Templates can define more general version of functions. To define a function template, users should use the syntax: function {function_name}[{placeholder1},{placeholder2},...]({arguments}) as {return type} ... end In the context of Birdee templates, the \"placeholders\" refers to the template parameters. The templates allow types to be the parameters of functions and classes. The difference between normal functions and function templates is that function templates has \"[...]\" part for the template arguments. Here is an example for adding two paramters: function add[T](a as T, b as T) as T return a+b end In the function header, we declare a template parameter for typename by \"T\", and we can use the template parameter as a type in the rest part of the function. To use the template function, add \"[...]\" to the function name to give the parameters to the template parameters. For example: add[int](1 , 3) add[string]( haha , yoyo ) add[float](1.2 , 3.4) In addition, the template parameter in the function template can be actual constant values rather than typenames. As is shown above, to declare a typename template parameter, users need to insert an identifier in the \"[...]\" of the function header. Similarly, declare a constant value template parameter, insert \"{identifier} as {type}\" into \"[...]\". Note that Birdee only support basic types (integers/floats) and string as the type of constant value template parameter. For example, we modifier the template above a little: function add[T,offset as int](a as T, b as T) as T return a+b+offset end We add a constant value template parameter \"offset\", and use it in the returned expression. Then we use it with: add[int,3](1 , 3) add[float,66](1.2 , 3.4) However, the code \"add[string,123](\"foo\",\"bar\")\" will not compile, since adding an integer to a string is not allowed. Also note that the arguments to the constant value placeholders can only be literal numbers/strings, such as \"12.34\" or 12.34. Member functions of a class can also be a template: class myclass private value as int public function add[T](v as T) value = value + v end end 8.2 Class Templates Similarly, one can define a class template with the following syntax: class {class_name}[{placeholder1},{placeholder2},...] ... end The placeholders can be similarly used in the scope of the class. Here is an example for a class for linked list: class list[T] public head as list_node[T] public tail as list_node[T] public function push_back(v as T) dim node=new list_node[T] node.v=v node.next=null if head===null then head=node tail=node else tail.next=node tail=node end end public function create() head=null tail=null end end class list_node[T] public v as T public next as list_node[T] end You can use it with: dim mylist = new list[string]:create() mylist.push_back( hi ) println(mylist.tail.v) Note that \"list[string]\" and \"list[int]\" are different types and not related. 8.3 Template type parameter deduction In some cases, you can call an template function without giving some of the template arguments. Birdee compiler can infer the template arguments from the function arguments. For example, for function: function add[T](a as T, B as T) as T return a+b end We can call the template function with: add(1,2) Since the type of arguments of the function has been given (\"1\" and \"2\" are of type \"int\") and in the template they are declared as \"T\", Birdee can infer that the template parameter \"T\" for the template \"add[T]\" is \"int\". So the code above has the same effect as: add[int](1,2) Template type parameter deduction has some restrictions. It only applies to function templates. The template parameters to be automatically inferred must be used in the function's parameters. The template parameters can be infered even it is in a complex type in the function parameter. For example, Birdee can infer the template parameter \"T\" in the following code: function get[T](a as T[]) as T return a[0] end The function parameter \"a\" is declared as a complicated type \"T[]\". For the given function parameter int[] , the compiler can infer T as int. Besides the array type, the template parameter deduction on closure types and functypes are supported. You can manually give some of the template arguments and leave other template arguments to be inferred by Birdee compiler. However, the template parameters to be automatically inferred must be the last several template parameters declared in the template's parameter list. For example, if we need a function template to add two values and convert the value to a specific type, the code can be: function add[RetT,T1,T2](a as T1, B as T2) as RetT return a+b end We can use it by giving the argument for \"RetT\" and leave \"T1\" and \"T2\" inferred by the compiler. For example: dim v = add[double](123,3.45f) Make sure that the template parameters that are designed to be given by the caller manually must be the first few parameters in the parameter list. A template type parameters cannot be inferred as more than one different types. For example, the following template will not compile: function add[T](a as T, B as T) as T return a+b end add(1, 2.34) Because \"T\" is first inferred as \"int\" then \"float\". All template parameters should either be manually specified by the caller (with [...]) or inferred with function's parameters. 8.4 Variadic template and function 8.4.1 Variadic template Sometimes it is useful to let templates have variable number of template parameters. For example, Birdee's standard library provides the \"tuple\" template struct which can combine value of multiple types in one variable. Here is an example for using \"tuple\": import tuple:tuple dim a as tuple[int,float,string] a.v0 = 1 #v0 is int a.v1 = 3.14 #v1 is float a.v2 = hello #v2 is string dim b as tuple[float,int] b.v0 = a.v1 #v0 is int b.v1 = a.v0 The \"tuple\" template can accept any number of argument types. In the example, we use two instances of tuple, with arguments \"int,float,string\" and \"float,int\". The definition of the tuple template is something like: struct tuple[...] #detailed definition omitted end Here the ellipsis \"...\" in the template parameter list lets the compiler know that the template is a variadic template. And the \"...\" accepts any number of template arguments. You can still declare template parameters even if there is the ellipsis (\"...\") in the parameter list. However, the ellipsis (\"...\") should appear at the end of the parameter list. # an example of declaring template parameters with ... struct vararg_struct[T1,T2,...] end # the following code won't compile struct vararg_struct_bad[...,T1,T2] end You can use the compile-time scripts to get the argument types in \"...\" within a template instance, by Python code: targs = get_cur_class().template_instance_args for targ in targs: ... Compile-time scripts will be discussed soon later. 8.4.2 Variadic function The ellipsis \"...\" can also be used in function parameter list. Moreover, you can use \"...\" in function's parameter to let the function accept variable number of parameters. For example, a function template that returns the sum of all arguments can be: func addn[...](...) as int return {@ arr_args=[] for arg in get_cur_func().proto.args: arr_args.append(arg.name) set_ast(expr( + .join(arr_args))) @} end The code between \"{@\" and \"@}\" is the compile time Python script. The script expands \"...\" and returns an expression that adds the parameters all. We use function to add any number of values: addn(1,2,3,4) addn(1,2) How does variadic function works? It is based on template type parameter deduction. When you call the function \"addn\" with \"addn(1,2,3,4)\", the \"...\" in the function parameter will be assigned with types \"int,int,int,int\". Then the ellipsis in the template parameter will be matched with the ellipsis in the function parameter. So the actual function to be generated in this example will be \"addn[int,int,int,int]\". Another way to use variadic function is to use it in a member function of variadic template class/struct. For example, you can define a member function in \"tuple\" to set all fields in a tuple object: struct tuple[...] #detailed definition omitted function set(...) #detailed code omitted end end For a tuple type \"tuple[int,float]\", the member function \"set\" will be expanded as function set(___vararg0 as int, ___vararg1 as float) #detailed code omitted end Some rules for variadic functions should be followed: Birdee creates an local varaible for each of the arguments of \"...\" in the function parameter, with names \"___vararg0\", \"___vararg1\", \"___vararg2\", ... (starting with three underscores \"_\"). Only template functions with variadic template parameters can have variadic function parameters. The ellipsis should only appear in the end of function's parameter list. 8.4.3 Named variadic parameter It is possible to create a variadic member function in a variadic class template. In the last section, we have already shown an example of using \"...\" in non-template function parameter to expand the variadic template parameters of the parent class. It is also allowed to create a variadic template function in a variadic class template. For example, class cls[...] public function f[...](...) end end In this example, which ellipsis will be expanded in the ellipsis in the function parameter? In this case, Birdee will expand the template argument of function \"f\" to the parameter list. That is, \"new cls[int].f[string]\" will have a parameter type of \"string\". However, what if we want to expand the \"...\" in the function parameter using the class template parameters? Thus, we introduce named variadic parameter. An identifier can follow the \"...\" in template parameter lists and function parameter lists to specify which ellipsis the function parameter will be expanded as. class cls[...CArg] public function f[...FArg](...CArg) end public function f2[...FArg](...FArg) end end dim obj = new cls[boolean] obj.f[string](true) obj.f2[string]( hello ) If a named function parameter ellipsis is expanded, it will first find a matched name in the current function template's named ellipsis. If no match, it will search for its name in the current class/struct's named ellipsis. If still no match, an compile error occurs. If a named function parameter ellipsis is expanded, it will first try to match current function template's ellipsis. If current function is not a template instance, it will search match current class/struct's ellipsis. 8.5 Notes on Templates Once users \"call\" a template with arguments, the compiler will instantiate an instance of the template. The template instance will be created only once for the same arguments to the placeholders in the same module. An instance of template will create an independent segment of code and data structures that is not shared by other instances. The whole source code for the templates will be copied into the metadata file of the module after compiled, for the use of other modules.","title":"8. Templates"},{"location":"Birdee Language Mannual/0080Template/#8-templates","text":"We explain the use of templates with the following example. Assume we have a function doing addition on int: function add(a as int, b as int) as int return a+b end What if we want a function adding floats? We may re-write an similar function: function add(a as float, b as float) as float return a+b end What if we want a function adding strings, or custom class objects? Writing so many functions that is almost the same? We can use templates!","title":"8. Templates"},{"location":"Birdee Language Mannual/0080Template/#81-function-templates","text":"Templates can define more general version of functions. To define a function template, users should use the syntax: function {function_name}[{placeholder1},{placeholder2},...]({arguments}) as {return type} ... end In the context of Birdee templates, the \"placeholders\" refers to the template parameters. The templates allow types to be the parameters of functions and classes. The difference between normal functions and function templates is that function templates has \"[...]\" part for the template arguments. Here is an example for adding two paramters: function add[T](a as T, b as T) as T return a+b end In the function header, we declare a template parameter for typename by \"T\", and we can use the template parameter as a type in the rest part of the function. To use the template function, add \"[...]\" to the function name to give the parameters to the template parameters. For example: add[int](1 , 3) add[string]( haha , yoyo ) add[float](1.2 , 3.4) In addition, the template parameter in the function template can be actual constant values rather than typenames. As is shown above, to declare a typename template parameter, users need to insert an identifier in the \"[...]\" of the function header. Similarly, declare a constant value template parameter, insert \"{identifier} as {type}\" into \"[...]\". Note that Birdee only support basic types (integers/floats) and string as the type of constant value template parameter. For example, we modifier the template above a little: function add[T,offset as int](a as T, b as T) as T return a+b+offset end We add a constant value template parameter \"offset\", and use it in the returned expression. Then we use it with: add[int,3](1 , 3) add[float,66](1.2 , 3.4) However, the code \"add[string,123](\"foo\",\"bar\")\" will not compile, since adding an integer to a string is not allowed. Also note that the arguments to the constant value placeholders can only be literal numbers/strings, such as \"12.34\" or 12.34. Member functions of a class can also be a template: class myclass private value as int public function add[T](v as T) value = value + v end end","title":"8.1 Function Templates"},{"location":"Birdee Language Mannual/0080Template/#82-class-templates","text":"Similarly, one can define a class template with the following syntax: class {class_name}[{placeholder1},{placeholder2},...] ... end The placeholders can be similarly used in the scope of the class. Here is an example for a class for linked list: class list[T] public head as list_node[T] public tail as list_node[T] public function push_back(v as T) dim node=new list_node[T] node.v=v node.next=null if head===null then head=node tail=node else tail.next=node tail=node end end public function create() head=null tail=null end end class list_node[T] public v as T public next as list_node[T] end You can use it with: dim mylist = new list[string]:create() mylist.push_back( hi ) println(mylist.tail.v) Note that \"list[string]\" and \"list[int]\" are different types and not related.","title":"8.2 Class Templates"},{"location":"Birdee Language Mannual/0080Template/#83-template-type-parameter-deduction","text":"In some cases, you can call an template function without giving some of the template arguments. Birdee compiler can infer the template arguments from the function arguments. For example, for function: function add[T](a as T, B as T) as T return a+b end We can call the template function with: add(1,2) Since the type of arguments of the function has been given (\"1\" and \"2\" are of type \"int\") and in the template they are declared as \"T\", Birdee can infer that the template parameter \"T\" for the template \"add[T]\" is \"int\". So the code above has the same effect as: add[int](1,2) Template type parameter deduction has some restrictions. It only applies to function templates. The template parameters to be automatically inferred must be used in the function's parameters. The template parameters can be infered even it is in a complex type in the function parameter. For example, Birdee can infer the template parameter \"T\" in the following code: function get[T](a as T[]) as T return a[0] end The function parameter \"a\" is declared as a complicated type \"T[]\". For the given function parameter int[] , the compiler can infer T as int. Besides the array type, the template parameter deduction on closure types and functypes are supported. You can manually give some of the template arguments and leave other template arguments to be inferred by Birdee compiler. However, the template parameters to be automatically inferred must be the last several template parameters declared in the template's parameter list. For example, if we need a function template to add two values and convert the value to a specific type, the code can be: function add[RetT,T1,T2](a as T1, B as T2) as RetT return a+b end We can use it by giving the argument for \"RetT\" and leave \"T1\" and \"T2\" inferred by the compiler. For example: dim v = add[double](123,3.45f) Make sure that the template parameters that are designed to be given by the caller manually must be the first few parameters in the parameter list. A template type parameters cannot be inferred as more than one different types. For example, the following template will not compile: function add[T](a as T, B as T) as T return a+b end add(1, 2.34) Because \"T\" is first inferred as \"int\" then \"float\". All template parameters should either be manually specified by the caller (with [...]) or inferred with function's parameters.","title":"8.3 Template type parameter deduction"},{"location":"Birdee Language Mannual/0080Template/#84-variadic-template-and-function","text":"","title":"8.4 Variadic template and function"},{"location":"Birdee Language Mannual/0080Template/#841-variadic-template","text":"Sometimes it is useful to let templates have variable number of template parameters. For example, Birdee's standard library provides the \"tuple\" template struct which can combine value of multiple types in one variable. Here is an example for using \"tuple\": import tuple:tuple dim a as tuple[int,float,string] a.v0 = 1 #v0 is int a.v1 = 3.14 #v1 is float a.v2 = hello #v2 is string dim b as tuple[float,int] b.v0 = a.v1 #v0 is int b.v1 = a.v0 The \"tuple\" template can accept any number of argument types. In the example, we use two instances of tuple, with arguments \"int,float,string\" and \"float,int\". The definition of the tuple template is something like: struct tuple[...] #detailed definition omitted end Here the ellipsis \"...\" in the template parameter list lets the compiler know that the template is a variadic template. And the \"...\" accepts any number of template arguments. You can still declare template parameters even if there is the ellipsis (\"...\") in the parameter list. However, the ellipsis (\"...\") should appear at the end of the parameter list. # an example of declaring template parameters with ... struct vararg_struct[T1,T2,...] end # the following code won't compile struct vararg_struct_bad[...,T1,T2] end You can use the compile-time scripts to get the argument types in \"...\" within a template instance, by Python code: targs = get_cur_class().template_instance_args for targ in targs: ... Compile-time scripts will be discussed soon later.","title":"8.4.1 Variadic template"},{"location":"Birdee Language Mannual/0080Template/#842-variadic-function","text":"The ellipsis \"...\" can also be used in function parameter list. Moreover, you can use \"...\" in function's parameter to let the function accept variable number of parameters. For example, a function template that returns the sum of all arguments can be: func addn[...](...) as int return {@ arr_args=[] for arg in get_cur_func().proto.args: arr_args.append(arg.name) set_ast(expr( + .join(arr_args))) @} end The code between \"{@\" and \"@}\" is the compile time Python script. The script expands \"...\" and returns an expression that adds the parameters all. We use function to add any number of values: addn(1,2,3,4) addn(1,2) How does variadic function works? It is based on template type parameter deduction. When you call the function \"addn\" with \"addn(1,2,3,4)\", the \"...\" in the function parameter will be assigned with types \"int,int,int,int\". Then the ellipsis in the template parameter will be matched with the ellipsis in the function parameter. So the actual function to be generated in this example will be \"addn[int,int,int,int]\". Another way to use variadic function is to use it in a member function of variadic template class/struct. For example, you can define a member function in \"tuple\" to set all fields in a tuple object: struct tuple[...] #detailed definition omitted function set(...) #detailed code omitted end end For a tuple type \"tuple[int,float]\", the member function \"set\" will be expanded as function set(___vararg0 as int, ___vararg1 as float) #detailed code omitted end Some rules for variadic functions should be followed: Birdee creates an local varaible for each of the arguments of \"...\" in the function parameter, with names \"___vararg0\", \"___vararg1\", \"___vararg2\", ... (starting with three underscores \"_\"). Only template functions with variadic template parameters can have variadic function parameters. The ellipsis should only appear in the end of function's parameter list.","title":"8.4.2 Variadic function"},{"location":"Birdee Language Mannual/0080Template/#843-named-variadic-parameter","text":"It is possible to create a variadic member function in a variadic class template. In the last section, we have already shown an example of using \"...\" in non-template function parameter to expand the variadic template parameters of the parent class. It is also allowed to create a variadic template function in a variadic class template. For example, class cls[...] public function f[...](...) end end In this example, which ellipsis will be expanded in the ellipsis in the function parameter? In this case, Birdee will expand the template argument of function \"f\" to the parameter list. That is, \"new cls[int].f[string]\" will have a parameter type of \"string\". However, what if we want to expand the \"...\" in the function parameter using the class template parameters? Thus, we introduce named variadic parameter. An identifier can follow the \"...\" in template parameter lists and function parameter lists to specify which ellipsis the function parameter will be expanded as. class cls[...CArg] public function f[...FArg](...CArg) end public function f2[...FArg](...FArg) end end dim obj = new cls[boolean] obj.f[string](true) obj.f2[string]( hello ) If a named function parameter ellipsis is expanded, it will first find a matched name in the current function template's named ellipsis. If no match, it will search for its name in the current class/struct's named ellipsis. If still no match, an compile error occurs. If a named function parameter ellipsis is expanded, it will first try to match current function template's ellipsis. If current function is not a template instance, it will search match current class/struct's ellipsis.","title":"8.4.3 Named variadic parameter"},{"location":"Birdee Language Mannual/0080Template/#85-notes-on-templates","text":"Once users \"call\" a template with arguments, the compiler will instantiate an instance of the template. The template instance will be created only once for the same arguments to the placeholders in the same module. An instance of template will create an independent segment of code and data structures that is not shared by other instances. The whole source code for the templates will be copied into the metadata file of the module after compiled, for the use of other modules.","title":"8.5 Notes on Templates"},{"location":"Birdee Language Mannual/0090Script/","text":"9. Compile-time scripts You can embed Python scripts in Birdee codes. The scripts are executed in compile time and these scripts will NOT be executed in the run time. Generally, the script is used for generating and compiling Birdee code in compile-time altering the existing Birdee code Compile-time scripts can completely replace macros and template-based meta-programming. In C++, these two features are powerful but hard to master - that's one of the reason of starting this programming language project. 9.1 Script basics To embed Python scripts in Birdee source code, you only need to surround your Python script with \"{@\" and \"@}\". For example {@ print( hello world ) @} dim a = hey world println(a) The above is a Birdee program. It can be divided into two parts. The first part is a Python script, which prints a string \"hello world\". When the program is compiled, the script will be run by the Birdee compiler, and prints the string in the standard output of the compiler itself. The second part is the Birdee code. It defines a variable and prints a string \"hey world\". This part will be executed in the run time. What can embedded Python scripts do? You can use them to generate Birdee code and insert the generated code into the place where \"{@\" and \"@}\" is. The \"{@\" and \"@}\" with the script can serve as a statement, expression or a type specifier. An expression is a piece of code which represents a value, like \"1\", \"add(1,2)\", \"variable_a\". Statements are super-class of expressions. A statement is a line or a block of Birdee code, but not necessarily has a value. For example, \"dim a as int\", \"if a 0 then ...\". A type specifier represents a typename and usually appears after \"as\" key word in Birdee code. To use the script as an expression, see the following example: dim a as int = {@set_ast(expr( 56 ))@} The script in \"{@\" and \"@}\" will generate an expression \"56\" as an integer and the script will be replaced by this expression when compiled. The functions \"set_ast\" and \"expr\" are built-in functions defined in Birdee compiler's embeded Python interpreter. The Python function \"expr\" accepts a string and compiles the string as the source code of an expression in Birdee. It returns an AST node for Birdee compiler. (An AST node is an element of the parsed Birdee source code.) The function \"set_ast\" takes an AST node as input and make Birdee compiler to insert the AST node at the position of current script in the Birdee source code. Note that in \"{@\" and \"@}\", any valid Python code is allowed. You can even use Python3's \"input\" function to get input from the user when the source code is compiled. You can also define functions in embedded scripts. Note that all Python code in \"{@\" and \"@}\" is executed in the same \"top level\" of Python interpreter. Defining variables in one script will affect all scripts executed later. Next let's see a more complex example: class student private id as int public function __init__(id as int) this.id=id end end {@ cnt=0 def counter(): set_ast(expr(str(cnt))) cnt+=1 @} dim stu1 = new student({@counter()@}) dim stu2 = new student({@counter()@}) dim stu3 = new student({@counter()@}) In this example, we have created a python function \"counter\", which generates an increasing integer after each call to it. Then we create 3 instances of \"student\" class and statically assign IDs to them. Then parameters for the constructor of \"student\" class for stu1 to stu3 will be \"1\", \"2\" and \"3\". Note that in C++, it may introduce much more lines of code to implement such compile-time template-based counter. Statements without values can also be compiled by Birdee's embedded scripts. Instead of using the function \"expr\", the function \"stmt\" can be utilized to compile a python string to an AST node. For example: dim cmpstr= hello {@ user_input=input() set_ast(stmt(f''' if cmpstr == {user_input} then println( It is hello! ) end ''')) @} The above example can be compiled by Birdee with Python 3.6+. It gets an input from the user and generate an \"if\" statement block to compare with a Birdee string variable. A script in Birdee can be used as a type specifier. Similar to statement and expression generation, you can use the functions \"set_type\" and \"resolve_type\" in the scripts to use script as a type. \"resolve_type\" accepts a string and will compile the string as a typename. It returns a \"ResolvedType\" object which is an internal representation of a type in Birdee. \"set_type\" accepts an \"ResolvedType\" object and makes the compiler replace the current script with this type. Here is an example in which defines an integer variable using these two functions: dim v as {@set_type(resolve_type( int ))@} We can do some \"meta-programming\" with the scripts. The following example implements a compile-time function to get and use the return type of any function (the counterpart of C++ meta-programming \"std::result_of\"): {@ def result_of(str_expr): exp = expr(str_expr).get() ty = exp.resolved_type prototype = ty.get_detail() assert(isinstance(prototype, PrototypeAST)) # make sure the expression points to an function set_type(prototype.return_type) @} function func1() as int return 0 end dim v as {@result_of( func1 )@} # should be int As we can see in this example, we can access the type of an expression by the \"resolved_type\" field and we can get the return type of an function prototype by its \"return_type\". AST nodes are objects that can be accessed by the python script and details of the nodes can be found in the fields of them. We will later discuss the details of AST nodes. The python scripts of Birdee can import existing Python modules by normal \"import\" command of python. Note that the directory \"$BIRDEE_HOME/pylib\" has been added to the python module search path of Python interpreter. 9.2 Scopes of the scripts As we know, variable names in Python are scoped. For example, you cannot use a local variable defined in a Python function in the code outside of the function. Similarly, the embeded scripts of Birdee follows the scopes of the Birdee code. The Python interpreter uses the \"context\" to manage the mapping from variable names to the actual data. Once the Birdee code enters a new level of basic block (e.g. the compiler enters a function/the body of \"for\" loop) or scope (e.g. the class definition), the Python interpreter will copy the Python context (the \"name\" - \"variable\" map) of the previous context. The scripts in the child context (in other words, in the lower level of the scopes) can have access to the names defined in parent Python contexts. But the scripts in the parent context cannot access the names in children context. The scripts in the same level of Birdee scope/basic block shares the same Python context. See the following example: {@a=1@} function f() {@print(a)@} # Okay, a is defined in the parent context print( Hi ) # Birdee code {@b=1@} end {@print(b)@} # Error here! b is defined in the children context The modules of Birdee has different Python contexts, which means that you cannot directly use the Python names defined in scripts in other Birdee modules. But there is a way to do so and we will introduce it later in this chapter. 9.3 Annotations Annotations can be applied on statements or expressions of Birdee programs. The syntax to use annotation is: @annotation_name1 @annotation_name2 .... expression_or_statement or @annotation_name expression_or_statement In a word, annotations can be used by prepending @annotation_name to an expression or statement. The annotation and the annotated code can be separated by a new line or not. You can add multiple annotations to the same part of code (the multiple annotations will be called in the order in the source code). A parsed Birdee program will be translated in the form of AST (Abstract Syntax Tree) form. Each expression or statement is a node of the AST. To process the annotation, in the compile time, the compiler will evaluate the annotation_name as a Python expression. The annotation_name can be a Python function name, a call to a Python function generator or any Python code that returns a callable Python object. The annotated part of code (in the AST node object form) will be applied to the Python function specified by the annotation name. The python function or callable object called by an annotation should take a parameter which is an AST node object. We show an example of an annotation that prints the type of the annotated AST node. You should first define or import a python function in an embedded script. Then call it with an annotation in Birdee code. {@ def show_ast(node): print(type(node)) @} @show_ast function func1() println( hello ) end @show_ast dim var as int @show_ast func1() {@ def show_ast2(prefix): return lambda node: print(prefix + type(node)) @} @show_ast2( prefix ) function func2() println( hello ) end After compiling the above code, the compiler will print \"FunctionAST\", \"VariableSingleDefAST\" and \"CallExprAST\" to its stdout. Note that the three annotations are executed in the same order as they are used in the Birdee source code. In the example, we first define a python function named \"show_ast\" in the script. It has one argument which is the annotated AST node. Here we simply get and print the type of the AST node with python's built-in keyword \"type\" and \"print\". Then in the Birdee part of code, we apply the annotation \"show_ast\" on a function definition, a variable definition and a function call expression. Finally, after compiling the code, we can see the type names of these AST nodes. This annotation example only reads the AST nodes. Useful tools can be developed by using read-only annotations, like code safety checking. We can do more than that because annotations can modify the annotated AST! In the next example, we define and use an annotation which: Can be applied on variable definitions Checks if the variable is a string and is not initialized when defined If so, add an initializer to the variable definition, and initialize the string variable to string \"(null)\" {@ def add_initializer(node): if isinstance(node,VariableSingleDefAST): if node.value is None and node.resolved_type == resolve_type( string ): #if node's initializer is null and its type is string node.value = expr(' (null) '') elif isinstance(node,VariableMultiDefAST)): #VariableMultiDefAST is multiple variable definitions in one line for sub_def in node.lst: #node.lst is the list of VariableSingleDefAST contained in VariableMultiDefAST add_initializer(sub_def) #apply the VariableSingleDefAST to the current function @} @add_initializer dim a as string println(a) @add_initializer dim b as string, c as string= hi println(b) println(c) We first define a python function. It accepts a single variable definition (VariableSingleDefAST) or multiple definitions (VariableMultiDefAST) in a line of code. Then for single variable definitions, the function check the initializer expression (node.value) and the variable type (node.resolved_type), and sets the initializer to string expression \"(null)\" if the variable has no initializer and the variable type is \"string\". For multiple definitions, the AST node (VariableMultiDefAST) contains a list of VariableSingleDefAST for each of the variable definitions. Our function iterates on the the list of contained VariableSingleDefAST to add the initializer. Once again, some fields of the AST node objects are used in this example. We will discuss about their details later. We apply the annotation on a single variable definition \"a\" and multiple definitions \"b\" and \"c\". Since variable \"c\" already has an initializer, the annotation has no effect on it. For variables \"a\" and \"b\", they will have an initial value \"(null)\" after the annotation has been applied. If you apply an annotation on a template, the corresponding Python function will not be called with the template AST, but when each of the instance of the template is constructed, the Python function will be called on the instance AST. Please be careful on how Birdee compiler split the annotation from the annotated Birdee code. The annotation starts from \"@\" and ends at the first encountered space (\" \") or newline. So if your annotation contains a space, the code will not work as expected. For example, the following code will not compile, because there is a space in \"The prefix\": {@ def show_ast2(prefix): return lambda node: print(prefix + type(node)) @} @show_ast2( The prefix ) function func2() println( hello ) 9.4 Init scripts and importing as modules By default, Birdee will dispose all embeded Python scripts which are not in templates. So the following module will compile, but will not function: {@ def somefunction(ast): pass @} @somefunction func hello[T](h as T) end If we compile the above code in a Birdee module \"hello\" and we import \"hello\" in another module, a Python error will be thrown, saying that the name \"somefunction\" is not found. The cause is that the script in the top level that defines the function is lost. To preserve the script, you should add an annotation init_script on the embeded scripts. Note that init_script is a special annotation defined by Birdee compiler, so you cannot create a user-defined annotation with the same name. init_script can only be applied on top-level embeded scripts. Otherwise, the compiler will fail on the program. You can mark multiple top-level scripts as init_script , the scripts will be executed after it is imported by other modules. The multiple scriptts will be executed in the original order defined in the source code. The above code can be modified to work: @init_script {@ def somefunction(ast): pass @} ... Remind that the different modules in Birdee have independent Python contexts. Even after importing a module, the init scripts will not affect the Python context in the current module. So in the above example, the function \"somefunction\" can only be used in the scripts in the module \"hello\". However, you can import the Python names defined in other modules' init scripts by importing them: import hello {@from hello import somefunction@} @somefunction function a() end In the above example, the init scipts of the module hello is imported as a Python module by the line {@from hello import somefunction@} . The module names of the Python modules can be derived from the names of Birdee modules where the scripts are defined. You just need to replace the \".\" in the Birdee module names with \"_0\". For example, for Birdee module \"org.birdee.a\", its corresponding Python module is org_0birdee_0a . 9.5 Generative script It is an interesting feature that the Birdee compiler itself can be used as an python library. Python programs can use Birdee to generate Birdee programs. We call these python programs \"generative scripts\". There are two ways to use Birdee in python generative scripts. The first way is to use Birdee compiler in Python interpreter mode. You need to add a switch \"-s\" to the command line parameter of Birdee compiler to activate this mode. When \"-s\" switch is given, the compiler will treat the input file as an Python program and run the input script with Python interpreter. The second way to run generative scripts is to simply run the standard python interpreter and import the module \"birdeec\" in the python code. Note that the Birdee binary library for python binding must be available in Python's library search path. And the library file must be named \"birdeec.so\" (on linux) or \"birdeec.pyd\" (on Windows). All APIs used in embedded scripts that are discussed above can also be used in generative scripts. Birdee compiler exposes some APIs that are only available for generative scripts. They are designed for compiler control. Here is an simple example of a generative script. from birdeec import * top_level(''' dim str = hello world println(str) ''') process_top_level() generate() clear_compile_unit() To use Birdee as a python library, you must first import the module \"birdeec\". (Note that for embedded scripts, this module has been automatically imported.) You can compile the top level code by function \"top_level\". It accepts a python string of Birdee source code. The function returns nothing, but the top-level code will be stored in the compiler library after \"top_level\" is called. Then, you should use function \"process_top_level\" to build the AST of the program and check the potential errors in the source code. The next step is to call function \"generate\" to generate the target object file. Optionally, if you want to re-use the current python process to compile another Birdee program, you should call the function \"clear_compile_unit\" to clear the internal states of the Birdee compiler library. This function is useful when you need to compile multiple Birdee programs in one script for testing. Our Birdee compiler project has been using generative scripts to test the features and expected behaviors of the compiler. 9.4 Error handling We have already introduced several APIs for python to compile a string of Birdee code to Birdee programs, including \"expr\", \"stmt\", \"top_level\", \"process_top_level\". An erroneous Birdee program string will fail to compile and an Python exception will be raised when calling these functions. You can catch the exception in both embedded and generative scripts using python's exception handling mechanism. The basic example to catch compilation errors is shown as follows: try: ... may_throw(...) ... except TokenizerException: e=get_tokenizer_error() print(e.linenumber,e.pos,e.msg) except CompileException: e=get_compile_error() print(e.linenumber,e.pos,e.msg) Catching a TokenizerException means that the compiler meets an unrecognized token in the program. An CompileException means that the program is somewhat invalid. The function \"may_throw\" is any function that may raise an compiler exception, which include: expr - may throw TokenizerException and CompileException stmt - may throw TokenizerException and CompileException top_level - may throw TokenizerException process_top_level - may throw CompileException Note that the exception object in the \"except\" clause in python for Birdee does not contain detailed exception informantion. You can either use function \"get_tokenizer_error\" or \"get_compile_error\" to get detailed exception information like the position of the error and the explanation of the error. Important note: Once the compile raises an exception, the compiler is in an unrecoverable state. You must not continue to use the compiler instance and you must call \"clear_compile_unit\" to reset the state of the compiler before continue to use \"birdeec\" library. 9.5 Memory management and pointer ownership There are two memory management systems in Birdee's compiler. One is the core part of the compiler which is written in C++. It uses unique_ptr to manage the lifetime and the ownership of the AST nodes. The other is the python interpreter's memory management system which uses reference counting. It is challenging to combine these two memory systems. For example, after we allocate an AST in python (e.g. by \"expr\" function), how can we move the ownership of the AST object to the C++ unique_ptr? We address this problem by introducing \"pointer ownership\" in python binding of Birdee. Having ownership of an object means that the respective memory management system is responsible to free the space for the object. If a parent AST node has the ownership pointer to another children AST node, it means that when the parent node is destroyed, the children nodes of it must be destroyed by it. If a python variable has the ownership pointer to an AST node, you can transfer the ownership of the pointer by assigning the ownership pointer to an existing AST node's ownership pointer field. Or you can use some APIs like \"set_ast\" to transfer the ownership to the compiler. For most of the fields in AST nodes, getting the fields in python gives you a reference. In this section, we refer to the term \"reference\" as the pointer to an AST node without ownership. Note that reading an ownership pointer field of an AST node in python returns a reference to the object (not the ownership pointer!). For example, a Birdee variable definition is represented by the AST node class \"VariableSingleDefAST\" and the initializer of the variable can be accessed by the field \"value\" as an ownership pointer. You can get the reference to the initializer expression by: var_ast = some_variable_def_ast init_of_var = var_ast.value The functions like \"expr\" and \"stmt\" returns an ownership pointer to the compiled AST. You cannot directly access the fields of the AST node by an ownership pointer. However, you can use the \"get\" method of an ownership pointer in python to get the reference to the AST object and then access the fields with the reference. exp=expr( 123 ) print(type(exp)) #should be StatementAST_UniquePtr print(type(exp.get())) #should be NumberExprAST Writing to an ownership pointer field of an AST node requires an ownership pointer in python. You cannot write to an ownership pointer field with a reference. After ownership transfer from a python ownership pointer, the python ownership pointer will point to null value. Take the class \"VariableSingleDefAST\" as an example: var_ast = some_variable_def_ast # it has type VariableSingleDefAST exp=expr( 123 ) #an ownership pointer to an expression var_ast.value = exp.get() #fails to run here! It requires an ownership pointer, not a reference var_ast.value = exp #okay, ownership transfer from exp assert(exp.get() is None) #exp is empty after transfering ownership 9.6 Detailed API specification TBD","title":"9. Compile-time scripts"},{"location":"Birdee Language Mannual/0090Script/#9-compile-time-scripts","text":"You can embed Python scripts in Birdee codes. The scripts are executed in compile time and these scripts will NOT be executed in the run time. Generally, the script is used for generating and compiling Birdee code in compile-time altering the existing Birdee code Compile-time scripts can completely replace macros and template-based meta-programming. In C++, these two features are powerful but hard to master - that's one of the reason of starting this programming language project.","title":"9. Compile-time scripts"},{"location":"Birdee Language Mannual/0090Script/#91-script-basics","text":"To embed Python scripts in Birdee source code, you only need to surround your Python script with \"{@\" and \"@}\". For example {@ print( hello world ) @} dim a = hey world println(a) The above is a Birdee program. It can be divided into two parts. The first part is a Python script, which prints a string \"hello world\". When the program is compiled, the script will be run by the Birdee compiler, and prints the string in the standard output of the compiler itself. The second part is the Birdee code. It defines a variable and prints a string \"hey world\". This part will be executed in the run time. What can embedded Python scripts do? You can use them to generate Birdee code and insert the generated code into the place where \"{@\" and \"@}\" is. The \"{@\" and \"@}\" with the script can serve as a statement, expression or a type specifier. An expression is a piece of code which represents a value, like \"1\", \"add(1,2)\", \"variable_a\". Statements are super-class of expressions. A statement is a line or a block of Birdee code, but not necessarily has a value. For example, \"dim a as int\", \"if a 0 then ...\". A type specifier represents a typename and usually appears after \"as\" key word in Birdee code. To use the script as an expression, see the following example: dim a as int = {@set_ast(expr( 56 ))@} The script in \"{@\" and \"@}\" will generate an expression \"56\" as an integer and the script will be replaced by this expression when compiled. The functions \"set_ast\" and \"expr\" are built-in functions defined in Birdee compiler's embeded Python interpreter. The Python function \"expr\" accepts a string and compiles the string as the source code of an expression in Birdee. It returns an AST node for Birdee compiler. (An AST node is an element of the parsed Birdee source code.) The function \"set_ast\" takes an AST node as input and make Birdee compiler to insert the AST node at the position of current script in the Birdee source code. Note that in \"{@\" and \"@}\", any valid Python code is allowed. You can even use Python3's \"input\" function to get input from the user when the source code is compiled. You can also define functions in embedded scripts. Note that all Python code in \"{@\" and \"@}\" is executed in the same \"top level\" of Python interpreter. Defining variables in one script will affect all scripts executed later. Next let's see a more complex example: class student private id as int public function __init__(id as int) this.id=id end end {@ cnt=0 def counter(): set_ast(expr(str(cnt))) cnt+=1 @} dim stu1 = new student({@counter()@}) dim stu2 = new student({@counter()@}) dim stu3 = new student({@counter()@}) In this example, we have created a python function \"counter\", which generates an increasing integer after each call to it. Then we create 3 instances of \"student\" class and statically assign IDs to them. Then parameters for the constructor of \"student\" class for stu1 to stu3 will be \"1\", \"2\" and \"3\". Note that in C++, it may introduce much more lines of code to implement such compile-time template-based counter. Statements without values can also be compiled by Birdee's embedded scripts. Instead of using the function \"expr\", the function \"stmt\" can be utilized to compile a python string to an AST node. For example: dim cmpstr= hello {@ user_input=input() set_ast(stmt(f''' if cmpstr == {user_input} then println( It is hello! ) end ''')) @} The above example can be compiled by Birdee with Python 3.6+. It gets an input from the user and generate an \"if\" statement block to compare with a Birdee string variable. A script in Birdee can be used as a type specifier. Similar to statement and expression generation, you can use the functions \"set_type\" and \"resolve_type\" in the scripts to use script as a type. \"resolve_type\" accepts a string and will compile the string as a typename. It returns a \"ResolvedType\" object which is an internal representation of a type in Birdee. \"set_type\" accepts an \"ResolvedType\" object and makes the compiler replace the current script with this type. Here is an example in which defines an integer variable using these two functions: dim v as {@set_type(resolve_type( int ))@} We can do some \"meta-programming\" with the scripts. The following example implements a compile-time function to get and use the return type of any function (the counterpart of C++ meta-programming \"std::result_of\"): {@ def result_of(str_expr): exp = expr(str_expr).get() ty = exp.resolved_type prototype = ty.get_detail() assert(isinstance(prototype, PrototypeAST)) # make sure the expression points to an function set_type(prototype.return_type) @} function func1() as int return 0 end dim v as {@result_of( func1 )@} # should be int As we can see in this example, we can access the type of an expression by the \"resolved_type\" field and we can get the return type of an function prototype by its \"return_type\". AST nodes are objects that can be accessed by the python script and details of the nodes can be found in the fields of them. We will later discuss the details of AST nodes. The python scripts of Birdee can import existing Python modules by normal \"import\" command of python. Note that the directory \"$BIRDEE_HOME/pylib\" has been added to the python module search path of Python interpreter.","title":"9.1 Script basics"},{"location":"Birdee Language Mannual/0090Script/#92-scopes-of-the-scripts","text":"As we know, variable names in Python are scoped. For example, you cannot use a local variable defined in a Python function in the code outside of the function. Similarly, the embeded scripts of Birdee follows the scopes of the Birdee code. The Python interpreter uses the \"context\" to manage the mapping from variable names to the actual data. Once the Birdee code enters a new level of basic block (e.g. the compiler enters a function/the body of \"for\" loop) or scope (e.g. the class definition), the Python interpreter will copy the Python context (the \"name\" - \"variable\" map) of the previous context. The scripts in the child context (in other words, in the lower level of the scopes) can have access to the names defined in parent Python contexts. But the scripts in the parent context cannot access the names in children context. The scripts in the same level of Birdee scope/basic block shares the same Python context. See the following example: {@a=1@} function f() {@print(a)@} # Okay, a is defined in the parent context print( Hi ) # Birdee code {@b=1@} end {@print(b)@} # Error here! b is defined in the children context The modules of Birdee has different Python contexts, which means that you cannot directly use the Python names defined in scripts in other Birdee modules. But there is a way to do so and we will introduce it later in this chapter.","title":"9.2 Scopes of the scripts"},{"location":"Birdee Language Mannual/0090Script/#93-annotations","text":"Annotations can be applied on statements or expressions of Birdee programs. The syntax to use annotation is: @annotation_name1 @annotation_name2 .... expression_or_statement or @annotation_name expression_or_statement In a word, annotations can be used by prepending @annotation_name to an expression or statement. The annotation and the annotated code can be separated by a new line or not. You can add multiple annotations to the same part of code (the multiple annotations will be called in the order in the source code). A parsed Birdee program will be translated in the form of AST (Abstract Syntax Tree) form. Each expression or statement is a node of the AST. To process the annotation, in the compile time, the compiler will evaluate the annotation_name as a Python expression. The annotation_name can be a Python function name, a call to a Python function generator or any Python code that returns a callable Python object. The annotated part of code (in the AST node object form) will be applied to the Python function specified by the annotation name. The python function or callable object called by an annotation should take a parameter which is an AST node object. We show an example of an annotation that prints the type of the annotated AST node. You should first define or import a python function in an embedded script. Then call it with an annotation in Birdee code. {@ def show_ast(node): print(type(node)) @} @show_ast function func1() println( hello ) end @show_ast dim var as int @show_ast func1() {@ def show_ast2(prefix): return lambda node: print(prefix + type(node)) @} @show_ast2( prefix ) function func2() println( hello ) end After compiling the above code, the compiler will print \"FunctionAST\", \"VariableSingleDefAST\" and \"CallExprAST\" to its stdout. Note that the three annotations are executed in the same order as they are used in the Birdee source code. In the example, we first define a python function named \"show_ast\" in the script. It has one argument which is the annotated AST node. Here we simply get and print the type of the AST node with python's built-in keyword \"type\" and \"print\". Then in the Birdee part of code, we apply the annotation \"show_ast\" on a function definition, a variable definition and a function call expression. Finally, after compiling the code, we can see the type names of these AST nodes. This annotation example only reads the AST nodes. Useful tools can be developed by using read-only annotations, like code safety checking. We can do more than that because annotations can modify the annotated AST! In the next example, we define and use an annotation which: Can be applied on variable definitions Checks if the variable is a string and is not initialized when defined If so, add an initializer to the variable definition, and initialize the string variable to string \"(null)\" {@ def add_initializer(node): if isinstance(node,VariableSingleDefAST): if node.value is None and node.resolved_type == resolve_type( string ): #if node's initializer is null and its type is string node.value = expr(' (null) '') elif isinstance(node,VariableMultiDefAST)): #VariableMultiDefAST is multiple variable definitions in one line for sub_def in node.lst: #node.lst is the list of VariableSingleDefAST contained in VariableMultiDefAST add_initializer(sub_def) #apply the VariableSingleDefAST to the current function @} @add_initializer dim a as string println(a) @add_initializer dim b as string, c as string= hi println(b) println(c) We first define a python function. It accepts a single variable definition (VariableSingleDefAST) or multiple definitions (VariableMultiDefAST) in a line of code. Then for single variable definitions, the function check the initializer expression (node.value) and the variable type (node.resolved_type), and sets the initializer to string expression \"(null)\" if the variable has no initializer and the variable type is \"string\". For multiple definitions, the AST node (VariableMultiDefAST) contains a list of VariableSingleDefAST for each of the variable definitions. Our function iterates on the the list of contained VariableSingleDefAST to add the initializer. Once again, some fields of the AST node objects are used in this example. We will discuss about their details later. We apply the annotation on a single variable definition \"a\" and multiple definitions \"b\" and \"c\". Since variable \"c\" already has an initializer, the annotation has no effect on it. For variables \"a\" and \"b\", they will have an initial value \"(null)\" after the annotation has been applied. If you apply an annotation on a template, the corresponding Python function will not be called with the template AST, but when each of the instance of the template is constructed, the Python function will be called on the instance AST. Please be careful on how Birdee compiler split the annotation from the annotated Birdee code. The annotation starts from \"@\" and ends at the first encountered space (\" \") or newline. So if your annotation contains a space, the code will not work as expected. For example, the following code will not compile, because there is a space in \"The prefix\": {@ def show_ast2(prefix): return lambda node: print(prefix + type(node)) @} @show_ast2( The prefix ) function func2() println( hello )","title":"9.3 Annotations"},{"location":"Birdee Language Mannual/0090Script/#94-init-scripts-and-importing-as-modules","text":"By default, Birdee will dispose all embeded Python scripts which are not in templates. So the following module will compile, but will not function: {@ def somefunction(ast): pass @} @somefunction func hello[T](h as T) end If we compile the above code in a Birdee module \"hello\" and we import \"hello\" in another module, a Python error will be thrown, saying that the name \"somefunction\" is not found. The cause is that the script in the top level that defines the function is lost. To preserve the script, you should add an annotation init_script on the embeded scripts. Note that init_script is a special annotation defined by Birdee compiler, so you cannot create a user-defined annotation with the same name. init_script can only be applied on top-level embeded scripts. Otherwise, the compiler will fail on the program. You can mark multiple top-level scripts as init_script , the scripts will be executed after it is imported by other modules. The multiple scriptts will be executed in the original order defined in the source code. The above code can be modified to work: @init_script {@ def somefunction(ast): pass @} ... Remind that the different modules in Birdee have independent Python contexts. Even after importing a module, the init scripts will not affect the Python context in the current module. So in the above example, the function \"somefunction\" can only be used in the scripts in the module \"hello\". However, you can import the Python names defined in other modules' init scripts by importing them: import hello {@from hello import somefunction@} @somefunction function a() end In the above example, the init scipts of the module hello is imported as a Python module by the line {@from hello import somefunction@} . The module names of the Python modules can be derived from the names of Birdee modules where the scripts are defined. You just need to replace the \".\" in the Birdee module names with \"_0\". For example, for Birdee module \"org.birdee.a\", its corresponding Python module is org_0birdee_0a .","title":"9.4 Init scripts and importing as modules"},{"location":"Birdee Language Mannual/0090Script/#95-generative-script","text":"It is an interesting feature that the Birdee compiler itself can be used as an python library. Python programs can use Birdee to generate Birdee programs. We call these python programs \"generative scripts\". There are two ways to use Birdee in python generative scripts. The first way is to use Birdee compiler in Python interpreter mode. You need to add a switch \"-s\" to the command line parameter of Birdee compiler to activate this mode. When \"-s\" switch is given, the compiler will treat the input file as an Python program and run the input script with Python interpreter. The second way to run generative scripts is to simply run the standard python interpreter and import the module \"birdeec\" in the python code. Note that the Birdee binary library for python binding must be available in Python's library search path. And the library file must be named \"birdeec.so\" (on linux) or \"birdeec.pyd\" (on Windows). All APIs used in embedded scripts that are discussed above can also be used in generative scripts. Birdee compiler exposes some APIs that are only available for generative scripts. They are designed for compiler control. Here is an simple example of a generative script. from birdeec import * top_level(''' dim str = hello world println(str) ''') process_top_level() generate() clear_compile_unit() To use Birdee as a python library, you must first import the module \"birdeec\". (Note that for embedded scripts, this module has been automatically imported.) You can compile the top level code by function \"top_level\". It accepts a python string of Birdee source code. The function returns nothing, but the top-level code will be stored in the compiler library after \"top_level\" is called. Then, you should use function \"process_top_level\" to build the AST of the program and check the potential errors in the source code. The next step is to call function \"generate\" to generate the target object file. Optionally, if you want to re-use the current python process to compile another Birdee program, you should call the function \"clear_compile_unit\" to clear the internal states of the Birdee compiler library. This function is useful when you need to compile multiple Birdee programs in one script for testing. Our Birdee compiler project has been using generative scripts to test the features and expected behaviors of the compiler.","title":"9.5 Generative script"},{"location":"Birdee Language Mannual/0090Script/#94-error-handling","text":"We have already introduced several APIs for python to compile a string of Birdee code to Birdee programs, including \"expr\", \"stmt\", \"top_level\", \"process_top_level\". An erroneous Birdee program string will fail to compile and an Python exception will be raised when calling these functions. You can catch the exception in both embedded and generative scripts using python's exception handling mechanism. The basic example to catch compilation errors is shown as follows: try: ... may_throw(...) ... except TokenizerException: e=get_tokenizer_error() print(e.linenumber,e.pos,e.msg) except CompileException: e=get_compile_error() print(e.linenumber,e.pos,e.msg) Catching a TokenizerException means that the compiler meets an unrecognized token in the program. An CompileException means that the program is somewhat invalid. The function \"may_throw\" is any function that may raise an compiler exception, which include: expr - may throw TokenizerException and CompileException stmt - may throw TokenizerException and CompileException top_level - may throw TokenizerException process_top_level - may throw CompileException Note that the exception object in the \"except\" clause in python for Birdee does not contain detailed exception informantion. You can either use function \"get_tokenizer_error\" or \"get_compile_error\" to get detailed exception information like the position of the error and the explanation of the error. Important note: Once the compile raises an exception, the compiler is in an unrecoverable state. You must not continue to use the compiler instance and you must call \"clear_compile_unit\" to reset the state of the compiler before continue to use \"birdeec\" library.","title":"9.4 Error handling"},{"location":"Birdee Language Mannual/0090Script/#95-memory-management-and-pointer-ownership","text":"There are two memory management systems in Birdee's compiler. One is the core part of the compiler which is written in C++. It uses unique_ptr to manage the lifetime and the ownership of the AST nodes. The other is the python interpreter's memory management system which uses reference counting. It is challenging to combine these two memory systems. For example, after we allocate an AST in python (e.g. by \"expr\" function), how can we move the ownership of the AST object to the C++ unique_ptr? We address this problem by introducing \"pointer ownership\" in python binding of Birdee. Having ownership of an object means that the respective memory management system is responsible to free the space for the object. If a parent AST node has the ownership pointer to another children AST node, it means that when the parent node is destroyed, the children nodes of it must be destroyed by it. If a python variable has the ownership pointer to an AST node, you can transfer the ownership of the pointer by assigning the ownership pointer to an existing AST node's ownership pointer field. Or you can use some APIs like \"set_ast\" to transfer the ownership to the compiler. For most of the fields in AST nodes, getting the fields in python gives you a reference. In this section, we refer to the term \"reference\" as the pointer to an AST node without ownership. Note that reading an ownership pointer field of an AST node in python returns a reference to the object (not the ownership pointer!). For example, a Birdee variable definition is represented by the AST node class \"VariableSingleDefAST\" and the initializer of the variable can be accessed by the field \"value\" as an ownership pointer. You can get the reference to the initializer expression by: var_ast = some_variable_def_ast init_of_var = var_ast.value The functions like \"expr\" and \"stmt\" returns an ownership pointer to the compiled AST. You cannot directly access the fields of the AST node by an ownership pointer. However, you can use the \"get\" method of an ownership pointer in python to get the reference to the AST object and then access the fields with the reference. exp=expr( 123 ) print(type(exp)) #should be StatementAST_UniquePtr print(type(exp.get())) #should be NumberExprAST Writing to an ownership pointer field of an AST node requires an ownership pointer in python. You cannot write to an ownership pointer field with a reference. After ownership transfer from a python ownership pointer, the python ownership pointer will point to null value. Take the class \"VariableSingleDefAST\" as an example: var_ast = some_variable_def_ast # it has type VariableSingleDefAST exp=expr( 123 ) #an ownership pointer to an expression var_ast.value = exp.get() #fails to run here! It requires an ownership pointer, not a reference var_ast.value = exp #okay, ownership transfer from exp assert(exp.get() is None) #exp is empty after transfering ownership","title":"9.5 Memory management and pointer ownership"},{"location":"Birdee Language Mannual/0090Script/#96-detailed-api-specification","text":"TBD","title":"9.6 Detailed API specification"},{"location":"Birdee Language Mannual/0100Cpp/","text":"10. Interoperability with C/C++ 10.1 Calling C/C++ from Birdee Birdee code can easily call C/C++ functions. You should first declare an external function in Birdee source code with the correct prototype. Then link the compiled Birdee object file with C/C++ object files or libraries. The syntax to declare an external function is declare {function_name} [alias { function_alias }] ([parameters]) [as {return_type}] For example, we can declare a C function \"puts\" which prints a string by: declare function puts (str as pointer) as int Note that the \"puts\" function in C takes an \"char*\" as argument. Here we use raw pointer type \"pointer\" as the type for this argument. We can then use this function to print the contents of a Birdee string: puts( hello .get_raw()) The \"get_raw\" method of the string class of Birdee returns the raw pointer of the string data. In C/C++ or other languages, the compiler may mangle the name of the function, making the function name \"strange\". You can use the \"alias\" clause of when declaring a function. For example, the linking name of an external function is \"_add0\", and you want to simply use the function with name \"add\", you can declare it by: declare function add alias _add0 () as int You may need to pass pointers of Birdee-managed data to an external function. To get the pointer to an Birdee variable, you can use \"addressof\" keyword: addressof(lvalue) You can apply \"addressof\" on any \"LValues\", which have an address in the run time. Basically, variables and fields of class objects are LValues. Note that you can apply addressof on fields of structs only when the struct object itself is an LValue. You can convert a reference to an object to raw pointer by \"pointerof\" keyword: pointerof(reference) The \"reference\" here is any valid reference expression (array or class objects). \"addressof\" and \"pointerof\" has different meanings. \"addressof\" gets the address of the variable itself. And \"pointerof\" gets the address of the object that the expression points to. dim a as string = hi dim p_a = addressof(a) # p_a = a in C++ dim p_hi = pointerof(a) # p_hi = (void*)a in C++ You can get the pointer to the \"real\" data buffer of some built-in data structures. Birdee \"string\" and arrays has \"get_raw\" method to get the pointer of the internal buffer. Using pointerof on string and arrays to get \"char*\" or \"int*\" may not work correctly as you have expected! 10.2 Calling Birdee from C/C++ Birdee variables and functions can be used in C/C++ or other languages. Each Birdee function or variable has a unique name which is composed of \"module_name\" + \".\" + \"func/variable name\". For example, for a module \"com.menooker.lib\", it has a variable \"a\" and a function \"func_a\". Then the unique name of the variable and the function will be \"com.menooker.lib.a\" and \"com.menooker.lib.func_a\". The unique names for template functions in Birdee are constructed by appending the template parameter to the template names, and using \"[\" and \"]\" to mark the start and the end of the template parameters, just like how template functions are used in the source code. For example, the unique name of an instance of the function template \"add_2\" can be \"com.menooker.lib.add[int,float]\". Unique name is used internally in Birdee compiler. However, in C++ or C, you cannot declare a function name with a dot in it. Birdee use name mangling to transform the unique name of a variable or function to a valid name for C/C++. Mangled unique names are the names of global top-level variables and functions generated in the object file in Birdee. Simple rules are used to mangle a unique name - Replace any: \"_\" with \"__\" \".\" with \"_0\" \"!\" with \"_1\" \"[\" with \"_2\" \"]\" with \"_3\" \",\" with \"_4\" \" \" with \"_5\" other characters that are not in [a-z] or [A-Z] with \"_xHH\", where HH is the hexadecimal representation of the ASCII code of the character, e.g. \"_x2h\". For example we have a Birdee module: package com.menooker.lib function add_2[T1,T2](a as T1,b as T1) as T2 return a+b end add_2[int,float] # declare an instance of the function template dim g_value as int = 10 The unique name \"com.menooker.lib.add_2[int,float]\" will be transformed to \"com_0menooker_0lib_0add__2_2int_4float_3\". Similarly, the unique name \"com.menooker.lib.g_value\" will be transformed to \"com_0menooker_0lib_0g__value\". Then, in C++ code, you can declare the function and the global variable by: extern C void com_0menooker_0lib_0_1main(); extern C float com_0menooker_0lib_0add__2_2int_4float_3 (int,int); extern int com_0menooker_0lib_0g__value; Note 1: If you want to use this C++ declaration in C code, replace extern \"C\" with \"extern\". Note 2: The function with unique name \"{module_name}.!main\" is the top-level \"main function\" code for the module. In the above example, we declare a function \"com_0menooker_0lib_0_1main\" for the top-level code. Remember to call the top-level \"main function\" code once before using the variables and the functions of the module. If the \"main function\" is not called, the module's global variables may not be correctly initialized. The top-level code of a Birdee module will call all top-level \"main functions\" of the modules it imports. So you don't need to manually call all module's top-level \"main functions\". Instead, you only need to call the \"main functions\" of several \"root\" modules. There is no effect to call a top-level \"main function\" multiple times after the first call to it - the \"main function\" will do nothing after it is called for the first time.","title":"10. Interoperability with C/C++"},{"location":"Birdee Language Mannual/0100Cpp/#10-interoperability-with-cc","text":"","title":"10. Interoperability with C/C++"},{"location":"Birdee Language Mannual/0100Cpp/#101-calling-cc-from-birdee","text":"Birdee code can easily call C/C++ functions. You should first declare an external function in Birdee source code with the correct prototype. Then link the compiled Birdee object file with C/C++ object files or libraries. The syntax to declare an external function is declare {function_name} [alias { function_alias }] ([parameters]) [as {return_type}] For example, we can declare a C function \"puts\" which prints a string by: declare function puts (str as pointer) as int Note that the \"puts\" function in C takes an \"char*\" as argument. Here we use raw pointer type \"pointer\" as the type for this argument. We can then use this function to print the contents of a Birdee string: puts( hello .get_raw()) The \"get_raw\" method of the string class of Birdee returns the raw pointer of the string data. In C/C++ or other languages, the compiler may mangle the name of the function, making the function name \"strange\". You can use the \"alias\" clause of when declaring a function. For example, the linking name of an external function is \"_add0\", and you want to simply use the function with name \"add\", you can declare it by: declare function add alias _add0 () as int You may need to pass pointers of Birdee-managed data to an external function. To get the pointer to an Birdee variable, you can use \"addressof\" keyword: addressof(lvalue) You can apply \"addressof\" on any \"LValues\", which have an address in the run time. Basically, variables and fields of class objects are LValues. Note that you can apply addressof on fields of structs only when the struct object itself is an LValue. You can convert a reference to an object to raw pointer by \"pointerof\" keyword: pointerof(reference) The \"reference\" here is any valid reference expression (array or class objects). \"addressof\" and \"pointerof\" has different meanings. \"addressof\" gets the address of the variable itself. And \"pointerof\" gets the address of the object that the expression points to. dim a as string = hi dim p_a = addressof(a) # p_a = a in C++ dim p_hi = pointerof(a) # p_hi = (void*)a in C++ You can get the pointer to the \"real\" data buffer of some built-in data structures. Birdee \"string\" and arrays has \"get_raw\" method to get the pointer of the internal buffer. Using pointerof on string and arrays to get \"char*\" or \"int*\" may not work correctly as you have expected!","title":"10.1 Calling C/C++ from Birdee"},{"location":"Birdee Language Mannual/0100Cpp/#102-calling-birdee-from-cc","text":"Birdee variables and functions can be used in C/C++ or other languages. Each Birdee function or variable has a unique name which is composed of \"module_name\" + \".\" + \"func/variable name\". For example, for a module \"com.menooker.lib\", it has a variable \"a\" and a function \"func_a\". Then the unique name of the variable and the function will be \"com.menooker.lib.a\" and \"com.menooker.lib.func_a\". The unique names for template functions in Birdee are constructed by appending the template parameter to the template names, and using \"[\" and \"]\" to mark the start and the end of the template parameters, just like how template functions are used in the source code. For example, the unique name of an instance of the function template \"add_2\" can be \"com.menooker.lib.add[int,float]\". Unique name is used internally in Birdee compiler. However, in C++ or C, you cannot declare a function name with a dot in it. Birdee use name mangling to transform the unique name of a variable or function to a valid name for C/C++. Mangled unique names are the names of global top-level variables and functions generated in the object file in Birdee. Simple rules are used to mangle a unique name - Replace any: \"_\" with \"__\" \".\" with \"_0\" \"!\" with \"_1\" \"[\" with \"_2\" \"]\" with \"_3\" \",\" with \"_4\" \" \" with \"_5\" other characters that are not in [a-z] or [A-Z] with \"_xHH\", where HH is the hexadecimal representation of the ASCII code of the character, e.g. \"_x2h\". For example we have a Birdee module: package com.menooker.lib function add_2[T1,T2](a as T1,b as T1) as T2 return a+b end add_2[int,float] # declare an instance of the function template dim g_value as int = 10 The unique name \"com.menooker.lib.add_2[int,float]\" will be transformed to \"com_0menooker_0lib_0add__2_2int_4float_3\". Similarly, the unique name \"com.menooker.lib.g_value\" will be transformed to \"com_0menooker_0lib_0g__value\". Then, in C++ code, you can declare the function and the global variable by: extern C void com_0menooker_0lib_0_1main(); extern C float com_0menooker_0lib_0add__2_2int_4float_3 (int,int); extern int com_0menooker_0lib_0g__value; Note 1: If you want to use this C++ declaration in C code, replace extern \"C\" with \"extern\". Note 2: The function with unique name \"{module_name}.!main\" is the top-level \"main function\" code for the module. In the above example, we declare a function \"com_0menooker_0lib_0_1main\" for the top-level code. Remember to call the top-level \"main function\" code once before using the variables and the functions of the module. If the \"main function\" is not called, the module's global variables may not be correctly initialized. The top-level code of a Birdee module will call all top-level \"main functions\" of the modules it imports. So you don't need to manually call all module's top-level \"main functions\". Instead, you only need to call the \"main functions\" of several \"root\" modules. There is no effect to call a top-level \"main function\" multiple times after the first call to it - the \"main function\" will do nothing after it is called for the first time.","title":"10.2 Calling Birdee from C/C++"},{"location":"Birdee Language Mannual/0110Functional/","text":"11. Functional Programming 11.1 Function variables Functions of Birdee are expressions. You can assign a function to a variable and use the variable to call the function. For example, dim func_var = function (a as int, b as int) as int = a+b println(int2str(func_var(1,2))) The first line defines a \"one line\" function, which returns the sum of the arguments. The function definition begins from the keyword \"function\". Note that we can define a function without naming it, which results in an anonymous function. The function definition itself is an expression, and we assign it to a variable \"func_var\". Then in the second line, we use this variable as if it is a function. The function variable is \"mutable\", which means you can re-assign another function to it. dim func_var = function (a as int, b as int) as int = a+b println(int2str(func_var(1,2))) func_var = function (a as int, b as int) as int = a-b println(int2str(func_var(1,2))) What's the type of a function variable (e.g. \"func_var\" in the example)? Birdee introduces a new type system called \"functype\". You can define a \"functype\" by: functype {typename} ([arguments...]) [as {return_type}] It looks like declaring a function, but it actually defines a type. A \"functype\" defines a type of functions, with the given prototype (the argument types and return type). After using \"functype\" definition, you can define a function variable without initializing it with an existing function. For example, functype myfunctype (v1 as string, v2 as int) dim func1 as myfunctype, func2 as myfunctype func1 = func (str as string, i as int) = println(str + int2str(i)) func2 = func1 func2( My student id is , 23) In the example, we define a functype called myfunctype. We define two function variables \"func1\" and \"func2\". We assign a function to func1 and assign func2 with the value of func1. Finally, we call the anonymous function with the variable func2. A function variable can be assigned with a function definition, a named function or another function variable, as long as the prototype of them are the same. Birdee considers two prototypes are the same if and only if the order and the types of the arguments are the same, and they have the same return type. Note that the functype name, the function name and the argument names are not considered when comparing the prototypes. function add(a as int, b as int) as int return a+b end functype thefunctype (v1 as int, v2 as int) as int dim foo as thefunctype foo = add #okay functype otherfunctype (fff as int, bbb as int) as int dim bar as otherfunctype = foo # okay foo = func (a as int,b as int) = a+b #fail to compile here! In the above example, the functype \"thefunctype\" and \"otherfunctype\" are exactly the same. The last line of code will fail to compile, because the return type of the function (which returns nothing) and the return type of \"foo\" (which is int) are different. Sometimes for simplicity, you can use in-place definition of functype without defining it in advance. For example, function callfunc(f as functype (v as int), b as int) f(b) end function print_int(a as int) = println(int2str(a)) callfunc(print_int,32) The function \"callfunc\" takes 2 arguments. The first one is a function variable, which has the type \"functype (v as int) as int\". The \"callfunc\" function simply calls the function variable \"f\" with the argument \"b\". We pass the function \"print_int\" as a parameter to the function \"callfunc\". 11.2 Closures Before talking about closures, we first introduce a feature of Birdee, that you can define functions in the body of other functions. For example, function outer() dim inner = function (str as string) println(str) end for dim i = 1 to 10 inner(int2str(i)) end end This example defines a \"inner\" function which can only be called within the \"outer\" function. In the inner nested function, you can access the local variables (and the arguments) of the parent or ancestor outer function. For example, function outer() dim prefix = i is dim inner = function (str as string) println(prefix + str) end for dim i = 1 to 10 inner(int2str(i)) end end The \"inner\" function accesses the \"outer\" function's \"prefix\" variable. The \"inner\" function is called a closure, because it \"captures\" the variable of outer function. To explain what \"closure\" is, we first explore how local variables work in a function without being captured. The local variables (or maybe some arguments) of a function are stored on the stack of the program. Once the program enter the function, the variables will be allocated on the stack, and they will be destroyed after the function returns. Without capturing, the life time of local variables is controlled by the function. If a local variable is used in the inner function, the inner function \"captures\" the variable defined in the parent function. Now the captured variables are owned by both parent function and inner function. An inner function with captured variables is called a \"closure\". Closures can be viewed as functions with its internal states. Note that a function without capturing variables has no internal states, because it either uses global variables (not internal), or uses local variables which cannot persist after the function returns. In contrast, a closure uses captured variables to store its local states. Like functype, we can define a closure type by the syntax: closure {typename} ([arguments...]) [as {return_type}] The usage of closure type is almost the same as functype. For example, we define and use a closure: closure counter_closure () as int function get_counter() as counter_closure dim i as int = 0 dim f = func () as int i = i + 1 return i end return f end dim counter as counter_closure = get_counter() println(int2str(counter())) println(int2str(counter())) println(int2str(counter())) counter = get_counter() println(int2str(counter())) In this example, we define a closure type called \"counter_closure\". Then we construct a function that returns a \"counter_closure\". It builds a function \"f\", which captures a local variable \"i\" of \"get_counter\". In function \"f\", it increases \"i\" and return the value of \"i\". The closure function \"f\" is returned by function \"get_counter\". We then define a closure variable \"counter\" and use \"get_counter\" to assign a closure to it. We call \"counter\" three times. The magic happens here! The closure function \"counter\" outputs 1, 2, and 3 in three calls to it, which means it remembers its internal states. Then we re-assign a new closure instance to \"counter\", and it returns 1 after calling it. So the output of this example is \"1\", \"2\", \"3\" and \"1\". Why? Because when \"get_counter\" returns a new closure, it creates a new instance of the internal state (the variable \"i\"). The closure will bind the internal state with the internal function \"f\". Calling the closure will modify the captured variable \"i\" in the state. Another call to \"get_counter\" creates another instance of the state. Closure and functype are quite similar. Closure can be in-place defined too. The only difference is that functype only points to a function without state. You can assign to a closure variable with a functype variable (or a function without captured variable). However, you cannot assign to a functype variable with a closure variable or any function that captures parent variables. Note: using global variables in a function will not capture a global variable. How are closures implemented in Birdee? When a parent function finds that its local variable is captured by a inner function, it will put the variable in a \"internal state object\". When the parent function is called, it will allocate the internal state object on the heap. A closure variable contains two values, the first is the address of internal state object and the second is the function pointer. In contrast, a functype variable is just a function pointer in the low level of the compiler. The inner function that captures outer variables will have an additional hidden argument to get the internal state object from the closure variable. The parent function will assign its address of internal state object to the closure. When the program calls a closure, the compiler first fetch the internal state object address and the function address from the closure variable. It then call the function with the object address and some other arguments. As we can see, the default implementation of closure makes the parent function allocate the captured variables on the heap, which could be a performance concern. Sometimes the inner functions of a function are only used in the parent function, and the inner function closure is never used by any non-ancestor functions, we can allocate the the captured variables on the stack. Only if you are sure about it, you can use the \"stack_capture\" annotation on the parent function to make faster closures. 11.2.1 Binding objects with methods using closures Closures can be used to hold a reference to an object with a method. The expression object_expression.member_function can be automatically converted to a closure of the same prototype of the member function. For example, the \"string\" class has a member function \"get_raw\", you can bind a string with the function by: dim str = hello dim funct as closure () as pointer = str.get_raw # note: no () here funct() # the same effect as str.get_raw()","title":"11. Functional Programming"},{"location":"Birdee Language Mannual/0110Functional/#11-functional-programming","text":"","title":"11. Functional Programming"},{"location":"Birdee Language Mannual/0110Functional/#111-function-variables","text":"Functions of Birdee are expressions. You can assign a function to a variable and use the variable to call the function. For example, dim func_var = function (a as int, b as int) as int = a+b println(int2str(func_var(1,2))) The first line defines a \"one line\" function, which returns the sum of the arguments. The function definition begins from the keyword \"function\". Note that we can define a function without naming it, which results in an anonymous function. The function definition itself is an expression, and we assign it to a variable \"func_var\". Then in the second line, we use this variable as if it is a function. The function variable is \"mutable\", which means you can re-assign another function to it. dim func_var = function (a as int, b as int) as int = a+b println(int2str(func_var(1,2))) func_var = function (a as int, b as int) as int = a-b println(int2str(func_var(1,2))) What's the type of a function variable (e.g. \"func_var\" in the example)? Birdee introduces a new type system called \"functype\". You can define a \"functype\" by: functype {typename} ([arguments...]) [as {return_type}] It looks like declaring a function, but it actually defines a type. A \"functype\" defines a type of functions, with the given prototype (the argument types and return type). After using \"functype\" definition, you can define a function variable without initializing it with an existing function. For example, functype myfunctype (v1 as string, v2 as int) dim func1 as myfunctype, func2 as myfunctype func1 = func (str as string, i as int) = println(str + int2str(i)) func2 = func1 func2( My student id is , 23) In the example, we define a functype called myfunctype. We define two function variables \"func1\" and \"func2\". We assign a function to func1 and assign func2 with the value of func1. Finally, we call the anonymous function with the variable func2. A function variable can be assigned with a function definition, a named function or another function variable, as long as the prototype of them are the same. Birdee considers two prototypes are the same if and only if the order and the types of the arguments are the same, and they have the same return type. Note that the functype name, the function name and the argument names are not considered when comparing the prototypes. function add(a as int, b as int) as int return a+b end functype thefunctype (v1 as int, v2 as int) as int dim foo as thefunctype foo = add #okay functype otherfunctype (fff as int, bbb as int) as int dim bar as otherfunctype = foo # okay foo = func (a as int,b as int) = a+b #fail to compile here! In the above example, the functype \"thefunctype\" and \"otherfunctype\" are exactly the same. The last line of code will fail to compile, because the return type of the function (which returns nothing) and the return type of \"foo\" (which is int) are different. Sometimes for simplicity, you can use in-place definition of functype without defining it in advance. For example, function callfunc(f as functype (v as int), b as int) f(b) end function print_int(a as int) = println(int2str(a)) callfunc(print_int,32) The function \"callfunc\" takes 2 arguments. The first one is a function variable, which has the type \"functype (v as int) as int\". The \"callfunc\" function simply calls the function variable \"f\" with the argument \"b\". We pass the function \"print_int\" as a parameter to the function \"callfunc\".","title":"11.1 Function variables"},{"location":"Birdee Language Mannual/0110Functional/#112-closures","text":"Before talking about closures, we first introduce a feature of Birdee, that you can define functions in the body of other functions. For example, function outer() dim inner = function (str as string) println(str) end for dim i = 1 to 10 inner(int2str(i)) end end This example defines a \"inner\" function which can only be called within the \"outer\" function. In the inner nested function, you can access the local variables (and the arguments) of the parent or ancestor outer function. For example, function outer() dim prefix = i is dim inner = function (str as string) println(prefix + str) end for dim i = 1 to 10 inner(int2str(i)) end end The \"inner\" function accesses the \"outer\" function's \"prefix\" variable. The \"inner\" function is called a closure, because it \"captures\" the variable of outer function. To explain what \"closure\" is, we first explore how local variables work in a function without being captured. The local variables (or maybe some arguments) of a function are stored on the stack of the program. Once the program enter the function, the variables will be allocated on the stack, and they will be destroyed after the function returns. Without capturing, the life time of local variables is controlled by the function. If a local variable is used in the inner function, the inner function \"captures\" the variable defined in the parent function. Now the captured variables are owned by both parent function and inner function. An inner function with captured variables is called a \"closure\". Closures can be viewed as functions with its internal states. Note that a function without capturing variables has no internal states, because it either uses global variables (not internal), or uses local variables which cannot persist after the function returns. In contrast, a closure uses captured variables to store its local states. Like functype, we can define a closure type by the syntax: closure {typename} ([arguments...]) [as {return_type}] The usage of closure type is almost the same as functype. For example, we define and use a closure: closure counter_closure () as int function get_counter() as counter_closure dim i as int = 0 dim f = func () as int i = i + 1 return i end return f end dim counter as counter_closure = get_counter() println(int2str(counter())) println(int2str(counter())) println(int2str(counter())) counter = get_counter() println(int2str(counter())) In this example, we define a closure type called \"counter_closure\". Then we construct a function that returns a \"counter_closure\". It builds a function \"f\", which captures a local variable \"i\" of \"get_counter\". In function \"f\", it increases \"i\" and return the value of \"i\". The closure function \"f\" is returned by function \"get_counter\". We then define a closure variable \"counter\" and use \"get_counter\" to assign a closure to it. We call \"counter\" three times. The magic happens here! The closure function \"counter\" outputs 1, 2, and 3 in three calls to it, which means it remembers its internal states. Then we re-assign a new closure instance to \"counter\", and it returns 1 after calling it. So the output of this example is \"1\", \"2\", \"3\" and \"1\". Why? Because when \"get_counter\" returns a new closure, it creates a new instance of the internal state (the variable \"i\"). The closure will bind the internal state with the internal function \"f\". Calling the closure will modify the captured variable \"i\" in the state. Another call to \"get_counter\" creates another instance of the state. Closure and functype are quite similar. Closure can be in-place defined too. The only difference is that functype only points to a function without state. You can assign to a closure variable with a functype variable (or a function without captured variable). However, you cannot assign to a functype variable with a closure variable or any function that captures parent variables. Note: using global variables in a function will not capture a global variable. How are closures implemented in Birdee? When a parent function finds that its local variable is captured by a inner function, it will put the variable in a \"internal state object\". When the parent function is called, it will allocate the internal state object on the heap. A closure variable contains two values, the first is the address of internal state object and the second is the function pointer. In contrast, a functype variable is just a function pointer in the low level of the compiler. The inner function that captures outer variables will have an additional hidden argument to get the internal state object from the closure variable. The parent function will assign its address of internal state object to the closure. When the program calls a closure, the compiler first fetch the internal state object address and the function address from the closure variable. It then call the function with the object address and some other arguments. As we can see, the default implementation of closure makes the parent function allocate the captured variables on the heap, which could be a performance concern. Sometimes the inner functions of a function are only used in the parent function, and the inner function closure is never used by any non-ancestor functions, we can allocate the the captured variables on the stack. Only if you are sure about it, you can use the \"stack_capture\" annotation on the parent function to make faster closures.","title":"11.2 Closures"},{"location":"Birdee Language Mannual/0110Functional/#1121-binding-objects-with-methods-using-closures","text":"Closures can be used to hold a reference to an object with a method. The expression object_expression.member_function can be automatically converted to a closure of the same prototype of the member function. For example, the \"string\" class has a member function \"get_raw\", you can bind a string with the function by: dim str = hello dim funct as closure () as pointer = str.get_raw # note: no () here funct() # the same effect as str.get_raw()","title":"11.2.1 Binding objects with methods using closures"},{"location":"Birdee Language Mannual/0120Exception/","text":"12. Exception handling 12.1 Exception handling basics Exceptions means that the program enters an uncommon state at the run time. Exceptions may occur when the program has encountered some errors like dereferencing null or dividing by 0: dim a as string = null, b as int = 0 println(a) dim c = 32/b Birdee programmers can also manually generate an exception in their Birdee code. Let's first consider what the program will be like without exceptions. For example, if we need to write a program that checks the communication with a server. We are given a function \"send_msg\" that can send a message to the server. If sending message fails, \"send_msg\" returns false. If successful, it returns true. We are required to send 4 messages to the server. If any one of the message fails, we must print \"Connection Down\". The program will be: if send_msg()==false then println( Connection Down ) else if send_msg()==false then println( Connection Down ) else if send_msg()==false then println( Connection Down ) end There are three nested \"if-else\", making the program less readable. We will see later how exceptions can simplify the program. To throw an exception, you can create a class object and use the \"throw\" keyword to raise the exception. throw {exception_object} The class of \"exception_object\" must be annotated \"enable_rtti\" when defined. For example, @enable_rtti class SomeException public msg as string public __init__(msg as string) = this.msg = msg end func sss() throw new SomeException( hello ) end To handle an exception, you must put the code that may throw an exception in a \"try\" block, and put the code that handles the exception in \"catch\" blocks. The syntax of \"try-catch\" error handling is: try ... catch {exception_object_name} as {exception_type} ... catch {exception_object_name} as {exception_type} ... ... end The code between \"try\" and the first \"catch\" is the \"try block\". The one \"try\" should be followed by at least one \"catch\" block. Each catch block has a \"exception_type\". Once an exception is thrown in the try block, the type of the throw exception object will be checked against the \"exception_type\" of each of the catch blocks in the order of defined in the source code. If a catch block's \"exception_type\" is the same class or the super class of the throw exception object, this catch block will be executed. And you can access the thrown exception object with variable \"{exception_object_name}\". If multiple \"catch\" blocks can match the exception, only the first \"catch\" block will be executed. If no catch-block is matched with the thrown exception, the exception will be handled by the current function's caller's try-catch blocks (if there is any). If no match in the caller's function, the exception will be recursively passed to the related try-catch blocks of functions in the call stack, in the direction from the current function to the top-level code. If still no catch-block is matched, the program will be terminated. Note that if an exception is throw, the program will jump to the matched catch block, and will not execute the code after the execption. After a catch block is executed, the program will continue its execution at the end of the matched try-catch block. In the above example of checking server communications, we can improve the program by using exceptions. Now if it fails to send the message, the function \"send_msg\" will throw an exception of type \"connect_error\". try send_msg() send_msg() send_msg() catch e as connection_error println( Connection Down ) end Here is an example that nested try-catch handles one exception: @enable_rtti class E1 public dummy as int public str as string public func __init__(str as string) = this.str=str public func print() = println( E1 +str) end @enable_rtti class E2 public str as string public dummy as int public func __init__(str as string) = this.str=str public func print() = println( E2 +str) end @enable_rtti class E3 public dummy as int public dummy2 as int public str as string public func __init__(str as string) = this.str=str public func print() = println( E3 +str) end function f1() try f2() println( try conti ) catch e as E1 e.print() catch e as E2 e.print() catch e as E3 e.print() end println( Continue ) end function f2() try throw new E3( yo ) catch e as E1 print( f2 ) e.print() catch e as E2 print( f2 ) e.print() end end f1() This example throws an \"E3\" in f2 and the function f2 cannot handle the exception. The exception will finally be handled by function \"f1\". So the output of the program will be: E3yo Continue 12.2 Hardware generated exceptions In the above section, we have shown two kinds of exceptions that can be thrown by the hardware: Memory access exception and Zero Division. You can catch these two exceptions with exception class \"mem_access_exception\" and \"zero_div_exception\", respectively. func test() dim a as string=null println(a) end func wrapper1() try test() catch e as mem_access_exception println( Caught SEGV ) end end wrapper1() wrapper1() wrapper1() func test2[T]() as T dim a as T = 0 return 2/a end func wrapper2[T,STR as string]() try test2[T]() catch e as div_zero_exception println(STR) end end wrapper2[int, int ]() wrapper2[int, int ]() wrapper2[int, int ]()","title":"12. Exception handling"},{"location":"Birdee Language Mannual/0120Exception/#12-exception-handling","text":"","title":"12. Exception handling"},{"location":"Birdee Language Mannual/0120Exception/#121-exception-handling-basics","text":"Exceptions means that the program enters an uncommon state at the run time. Exceptions may occur when the program has encountered some errors like dereferencing null or dividing by 0: dim a as string = null, b as int = 0 println(a) dim c = 32/b Birdee programmers can also manually generate an exception in their Birdee code. Let's first consider what the program will be like without exceptions. For example, if we need to write a program that checks the communication with a server. We are given a function \"send_msg\" that can send a message to the server. If sending message fails, \"send_msg\" returns false. If successful, it returns true. We are required to send 4 messages to the server. If any one of the message fails, we must print \"Connection Down\". The program will be: if send_msg()==false then println( Connection Down ) else if send_msg()==false then println( Connection Down ) else if send_msg()==false then println( Connection Down ) end There are three nested \"if-else\", making the program less readable. We will see later how exceptions can simplify the program. To throw an exception, you can create a class object and use the \"throw\" keyword to raise the exception. throw {exception_object} The class of \"exception_object\" must be annotated \"enable_rtti\" when defined. For example, @enable_rtti class SomeException public msg as string public __init__(msg as string) = this.msg = msg end func sss() throw new SomeException( hello ) end To handle an exception, you must put the code that may throw an exception in a \"try\" block, and put the code that handles the exception in \"catch\" blocks. The syntax of \"try-catch\" error handling is: try ... catch {exception_object_name} as {exception_type} ... catch {exception_object_name} as {exception_type} ... ... end The code between \"try\" and the first \"catch\" is the \"try block\". The one \"try\" should be followed by at least one \"catch\" block. Each catch block has a \"exception_type\". Once an exception is thrown in the try block, the type of the throw exception object will be checked against the \"exception_type\" of each of the catch blocks in the order of defined in the source code. If a catch block's \"exception_type\" is the same class or the super class of the throw exception object, this catch block will be executed. And you can access the thrown exception object with variable \"{exception_object_name}\". If multiple \"catch\" blocks can match the exception, only the first \"catch\" block will be executed. If no catch-block is matched with the thrown exception, the exception will be handled by the current function's caller's try-catch blocks (if there is any). If no match in the caller's function, the exception will be recursively passed to the related try-catch blocks of functions in the call stack, in the direction from the current function to the top-level code. If still no catch-block is matched, the program will be terminated. Note that if an exception is throw, the program will jump to the matched catch block, and will not execute the code after the execption. After a catch block is executed, the program will continue its execution at the end of the matched try-catch block. In the above example of checking server communications, we can improve the program by using exceptions. Now if it fails to send the message, the function \"send_msg\" will throw an exception of type \"connect_error\". try send_msg() send_msg() send_msg() catch e as connection_error println( Connection Down ) end Here is an example that nested try-catch handles one exception: @enable_rtti class E1 public dummy as int public str as string public func __init__(str as string) = this.str=str public func print() = println( E1 +str) end @enable_rtti class E2 public str as string public dummy as int public func __init__(str as string) = this.str=str public func print() = println( E2 +str) end @enable_rtti class E3 public dummy as int public dummy2 as int public str as string public func __init__(str as string) = this.str=str public func print() = println( E3 +str) end function f1() try f2() println( try conti ) catch e as E1 e.print() catch e as E2 e.print() catch e as E3 e.print() end println( Continue ) end function f2() try throw new E3( yo ) catch e as E1 print( f2 ) e.print() catch e as E2 print( f2 ) e.print() end end f1() This example throws an \"E3\" in f2 and the function f2 cannot handle the exception. The exception will finally be handled by function \"f1\". So the output of the program will be: E3yo Continue","title":"12.1 Exception handling basics"},{"location":"Birdee Language Mannual/0120Exception/#122-hardware-generated-exceptions","text":"In the above section, we have shown two kinds of exceptions that can be thrown by the hardware: Memory access exception and Zero Division. You can catch these two exceptions with exception class \"mem_access_exception\" and \"zero_div_exception\", respectively. func test() dim a as string=null println(a) end func wrapper1() try test() catch e as mem_access_exception println( Caught SEGV ) end end wrapper1() wrapper1() wrapper1() func test2[T]() as T dim a as T = 0 return 2/a end func wrapper2[T,STR as string]() try test2[T]() catch e as div_zero_exception println(STR) end end wrapper2[int, int ]() wrapper2[int, int ]() wrapper2[int, int ]()","title":"12.2 Hardware generated exceptions"},{"location":"Python Binding/0010.Overview/","text":"Python binding for Birdee Birdee depends on Python language for compile-time scripts that can generate and modify the existing program to compile. The Birdee compiler provides various functions and class for Python code that is embeded in the Birdee program, to enable them to access the internal data structures and functions in the Birdee compiler. The set of Python interfaces provided by Birdee is called \"Python binding\". This series of documents lists the details of how Python embeded scripts can use the interfaces of the Birdee compilers. First, we will discuss overview of the usage of Python scripts in Birdee code. The Python scripts can be invoked in three ways: By placing them between a pair of {@ ... @} . Here the script will serve as an expression, statement or a type in Birdee code By adding an annotation on an expression or statement. The python function specified by the annotation will be called By writing a generative script to generate a Birdee program by an indenpendent Python program(not embeded in Birdee code) In the above apporaches, the Python binding is available for the scripts. You can use the script to Insert code to the existing program being compiled (mainly in approaches 1 and 3) Alter the existing code (mainly in approach 2) The details of the basics for Birdee scripts have been discussed in the chapter \"Compile-time scripts\" in Birdee language mannual. The rest part of this section will talk about the Birdee compiler internals that are related to Python binding and how the Python binding can be invoked. How Birdee compiler parses a source file? A Birdee program is composed of a list of statements. A simple statement can be a line of code like dim a as int Some statements can hold other statements. For example, the syntax for \"if\" statement is: if cond then ... else ... end So in an \"if\", there will be a statement for the condition, two lists of statements for the both branches. It is natural to store a parsed Birdee program with a tree, since a statement can hold sub-statements. The tree representing the source code is called an Abstract Syntax Tree (AST). Each node of the tree is a statement in the source code. For example, an \"if\" node in AST has the structure like: IF - Cond - List-True - ... - List-False - ... An important part of Python binding of Birdee is the binding for the AST. In Python scripts, the AST for different kinds of statements are wrapped into different Python classes. Developers can access the fields of the AST in the scripts via these Python classes. In Birdee, some statements may have a \"returning value\". e.g. The statement add(1,2) returns the function call result. And other statements does not have a returning value. The kinds of statements that may return a value is called \"expression\". In Birdee's AST, an expression is a sub-class of the statement class. All kinds of AST (e.g. functions, variables definitions, class definitions, ...) are sub-classes of either expression class (called ExprAST in Python binding), or statement class (StatementAST). How the Python binding can be invoked Most of binding interfaces of Birdee can be accessed via the Python module \"birdeec\". For embeded scripts and annotations, all symbols in this module has already been imported. For generative scripts, you need to manually import this Python module. The binding falls into two catagories. The first is the supporting functions that control the Birdee compiler. e.g. the expr function will call the Birdee compiler to generate an AST by the code given by the Python string. The second part of the binding is the AST classes for different kinds of statements. In each of the AST classes, you can read and write to the internal properties of the nodes to inspect and modify the Birdee program. Based on the Python binding, we also provide some higher level APIs that can simplify the operations of the scripts.","title":"Python binding for Birdee"},{"location":"Python Binding/0010.Overview/#python-binding-for-birdee","text":"Birdee depends on Python language for compile-time scripts that can generate and modify the existing program to compile. The Birdee compiler provides various functions and class for Python code that is embeded in the Birdee program, to enable them to access the internal data structures and functions in the Birdee compiler. The set of Python interfaces provided by Birdee is called \"Python binding\". This series of documents lists the details of how Python embeded scripts can use the interfaces of the Birdee compilers. First, we will discuss overview of the usage of Python scripts in Birdee code. The Python scripts can be invoked in three ways: By placing them between a pair of {@ ... @} . Here the script will serve as an expression, statement or a type in Birdee code By adding an annotation on an expression or statement. The python function specified by the annotation will be called By writing a generative script to generate a Birdee program by an indenpendent Python program(not embeded in Birdee code) In the above apporaches, the Python binding is available for the scripts. You can use the script to Insert code to the existing program being compiled (mainly in approaches 1 and 3) Alter the existing code (mainly in approach 2) The details of the basics for Birdee scripts have been discussed in the chapter \"Compile-time scripts\" in Birdee language mannual. The rest part of this section will talk about the Birdee compiler internals that are related to Python binding and how the Python binding can be invoked.","title":"Python binding for Birdee"},{"location":"Python Binding/0010.Overview/#how-birdee-compiler-parses-a-source-file","text":"A Birdee program is composed of a list of statements. A simple statement can be a line of code like dim a as int Some statements can hold other statements. For example, the syntax for \"if\" statement is: if cond then ... else ... end So in an \"if\", there will be a statement for the condition, two lists of statements for the both branches. It is natural to store a parsed Birdee program with a tree, since a statement can hold sub-statements. The tree representing the source code is called an Abstract Syntax Tree (AST). Each node of the tree is a statement in the source code. For example, an \"if\" node in AST has the structure like: IF - Cond - List-True - ... - List-False - ... An important part of Python binding of Birdee is the binding for the AST. In Python scripts, the AST for different kinds of statements are wrapped into different Python classes. Developers can access the fields of the AST in the scripts via these Python classes. In Birdee, some statements may have a \"returning value\". e.g. The statement add(1,2) returns the function call result. And other statements does not have a returning value. The kinds of statements that may return a value is called \"expression\". In Birdee's AST, an expression is a sub-class of the statement class. All kinds of AST (e.g. functions, variables definitions, class definitions, ...) are sub-classes of either expression class (called ExprAST in Python binding), or statement class (StatementAST).","title":"How Birdee compiler parses a source file?"},{"location":"Python Binding/0010.Overview/#how-the-python-binding-can-be-invoked","text":"Most of binding interfaces of Birdee can be accessed via the Python module \"birdeec\". For embeded scripts and annotations, all symbols in this module has already been imported. For generative scripts, you need to manually import this Python module. The binding falls into two catagories. The first is the supporting functions that control the Birdee compiler. e.g. the expr function will call the Birdee compiler to generate an AST by the code given by the Python string. The second part of the binding is the AST classes for different kinds of statements. In each of the AST classes, you can read and write to the internal properties of the nodes to inspect and modify the Birdee program. Based on the Python binding, we also provide some higher level APIs that can simplify the operations of the scripts.","title":"How the Python binding can be invoked"},{"location":"Python Binding/0020.Functions/","text":"Birdee binding Functions for Python This chapter lists the functions provided by Birdee that can be called from Python. Note that some of the functions are only avaliable in generative script mode and is invisible for embeded scripts in Birdee source code. The following documents uses python's type hint syntax to show the prototypes of the APIs. Compiler Controling in generative script clear_compile_unit def clear_compile_unit() Only in generative script mode. Reset the compiler and clear all parsed data of the current compiled program. The compiler will be ready to compile a new program. top_level def top_level(source: str) Only in generative script mode. It accepts a string that contains one or more lines of top-level Birdee code. It will parse the source string into AST and insert the AST nodes into the top-level of the currently compiled program. A TokenizerException may be throw if parsing the source into AST fails. Note: this function only convert the source code into AST. You may need to call process_top_level to check the correctness of the parsed AST. You can call top_level for multiple times to insert several pieces of code into the top-level. The latter call to this function will append the code to the AST list of the previous call to this function. process_top_level def process_top_level() Only in generative script mode. Process the AST that is generated by calls to the function top_level . A CompileException may be throw if there is an error in the AST (e.g. type mismatch for variable assignment). You can only call this function one time before you reset the compiler by clear_compile_unit . generate def generate() Only in generative script mode. Generate an object file based on processed top-level AST. You should call process_top_level before calling this function. The path of the output file is specified in the command line argument of the compiler. set_print_ir def set_print_ir(flag: bool) Only in generative script mode. Set whether the compiler will output the LLVM IR for the generated program to stderr after calling generate . If the flag is True, the printing behavior is on. Typical workflow of a generative script In a typical generative script, it may first call top_level to feed the source code into the compiler. Then it calls process_top_level to process the program. Optionally, it calls generate to generate the object file of the code. It may also optionally call clear_compile_unit to reset the compiler and reuse the compiler for another Birdee program. Environment queries get_os_name def get_os_name() - str Get the name of target OS. Note: the target OS is what the output object file is compiled for and it may be different from the OS that the compiler runs on. Returns \"windows\", \"linux\" or \"unknown target name\". get_target_bits def get_target_bits() - int Get the bits of the target object file. Returns an integer, maybe 64 or 32. Compiler state queries and control imports def imports(module_name: str) Import a Birdee module. It has the same effect as the Birdee keyword import in Birdee code. The difference is that it is a Python function. It accepts a string which is the module name or a symbol within a module. e.g. \"concurrent.threading\" or \"concurrent.threading:thread\" are valid input for this function. get_cur_script def get_cur_script() - ScriptAST Can only be called within a embeded script ( {@...@} ) for statements. Returns the current ScriptAST that the script is in. class_body def class_body(clz: ClassAST, source: str) Insert a chunk of code in the class body of a class. The class is specified by the argument clz . The code is specified in the argument source . Note that only one function or one line of member variable is added to the class in a call to class_body at a time. If your source contains more than one line to insert and it is not a function definition, the lines after the first valid member definition will be ignored. A single line of multiple member variable definition is accepted in this case, since the members are defined in one single line. A member function that occupies multiple lines are also accepted by this function. size_of def resolve_type(type: ResolvedType) - int Get the size of a type, in bytes. Currently the input type cannot a struct type. expr def expr(source: str) - StatementAST_UniquePtr Converts a Birdee source code string into an AST. Expecting an expression. Takes the ownership of the returned AST. stmt def stmt(source: str) - StatementAST_UniquePtr Converts a Birdee source code string into an AST. Expecting an statement. Takes the ownership of the returned AST. set_ast def set_ast(ast: StatementAST_UniquePtr) Can only be called in embeded script for statements. Sets the current script AST with the given AST node. It will take the ownership of the input AST. You can call this function multiple times to combine multiple lines of Birdee code into in ScriptAST node. All of the Birdee code set into the ScriptAST will be generated and executed. The value of the resulting ScriptAST node will be the result of the first Birdee code set into the ast. resolve_type def resolve_type(source: str) - ResolvedType Convert a string representation of a Birdee type into a ResolvedType AST. The input string should be any valid Birdee type in the current script context, e.g. \"int\", \"string\". set_type def set_type(type: ResolvedType) Can only be called in embeded script for types. Sets the current type script AST with the given resolved type. get_cur_func def get_cur_func() - FunctionAST Returns the reference to the current function AST that the script is in, or None if is not in a function. get_cur_class def get_cur_class() - ClassAST Returns the reference to the current class AST that the script is in, or None if is not in a class. get_func def get_func(name: str) - FunctionAST Find the reference to the function AST with a given name, or None if it does not exist. get_top_level def get_top_level(name: str) - StatementASTList Get the list of statements for the top-level code. get_compile_error def get_compile_error() - CompileError Get the current compile error. You should call it when a CompileException occurs for more information on the error. get_tokenizer_error def get_tokenizer_error() - TokenizerError Get the current tokenizer error. You should call it when a TokenizerException occurs for more information on the error.","title":"Birdee binding Functions for Python"},{"location":"Python Binding/0020.Functions/#birdee-binding-functions-for-python","text":"This chapter lists the functions provided by Birdee that can be called from Python. Note that some of the functions are only avaliable in generative script mode and is invisible for embeded scripts in Birdee source code. The following documents uses python's type hint syntax to show the prototypes of the APIs.","title":"Birdee binding Functions for Python"},{"location":"Python Binding/0020.Functions/#compiler-controling-in-generative-script","text":"clear_compile_unit def clear_compile_unit() Only in generative script mode. Reset the compiler and clear all parsed data of the current compiled program. The compiler will be ready to compile a new program. top_level def top_level(source: str) Only in generative script mode. It accepts a string that contains one or more lines of top-level Birdee code. It will parse the source string into AST and insert the AST nodes into the top-level of the currently compiled program. A TokenizerException may be throw if parsing the source into AST fails. Note: this function only convert the source code into AST. You may need to call process_top_level to check the correctness of the parsed AST. You can call top_level for multiple times to insert several pieces of code into the top-level. The latter call to this function will append the code to the AST list of the previous call to this function. process_top_level def process_top_level() Only in generative script mode. Process the AST that is generated by calls to the function top_level . A CompileException may be throw if there is an error in the AST (e.g. type mismatch for variable assignment). You can only call this function one time before you reset the compiler by clear_compile_unit . generate def generate() Only in generative script mode. Generate an object file based on processed top-level AST. You should call process_top_level before calling this function. The path of the output file is specified in the command line argument of the compiler. set_print_ir def set_print_ir(flag: bool) Only in generative script mode. Set whether the compiler will output the LLVM IR for the generated program to stderr after calling generate . If the flag is True, the printing behavior is on.","title":"Compiler Controling in generative script"},{"location":"Python Binding/0020.Functions/#typical-workflow-of-a-generative-script","text":"In a typical generative script, it may first call top_level to feed the source code into the compiler. Then it calls process_top_level to process the program. Optionally, it calls generate to generate the object file of the code. It may also optionally call clear_compile_unit to reset the compiler and reuse the compiler for another Birdee program.","title":"Typical workflow of a generative script"},{"location":"Python Binding/0020.Functions/#environment-queries","text":"get_os_name def get_os_name() - str Get the name of target OS. Note: the target OS is what the output object file is compiled for and it may be different from the OS that the compiler runs on. Returns \"windows\", \"linux\" or \"unknown target name\". get_target_bits def get_target_bits() - int Get the bits of the target object file. Returns an integer, maybe 64 or 32.","title":"Environment queries"},{"location":"Python Binding/0020.Functions/#compiler-state-queries-and-control","text":"imports def imports(module_name: str) Import a Birdee module. It has the same effect as the Birdee keyword import in Birdee code. The difference is that it is a Python function. It accepts a string which is the module name or a symbol within a module. e.g. \"concurrent.threading\" or \"concurrent.threading:thread\" are valid input for this function. get_cur_script def get_cur_script() - ScriptAST Can only be called within a embeded script ( {@...@} ) for statements. Returns the current ScriptAST that the script is in. class_body def class_body(clz: ClassAST, source: str) Insert a chunk of code in the class body of a class. The class is specified by the argument clz . The code is specified in the argument source . Note that only one function or one line of member variable is added to the class in a call to class_body at a time. If your source contains more than one line to insert and it is not a function definition, the lines after the first valid member definition will be ignored. A single line of multiple member variable definition is accepted in this case, since the members are defined in one single line. A member function that occupies multiple lines are also accepted by this function. size_of def resolve_type(type: ResolvedType) - int Get the size of a type, in bytes. Currently the input type cannot a struct type. expr def expr(source: str) - StatementAST_UniquePtr Converts a Birdee source code string into an AST. Expecting an expression. Takes the ownership of the returned AST. stmt def stmt(source: str) - StatementAST_UniquePtr Converts a Birdee source code string into an AST. Expecting an statement. Takes the ownership of the returned AST. set_ast def set_ast(ast: StatementAST_UniquePtr) Can only be called in embeded script for statements. Sets the current script AST with the given AST node. It will take the ownership of the input AST. You can call this function multiple times to combine multiple lines of Birdee code into in ScriptAST node. All of the Birdee code set into the ScriptAST will be generated and executed. The value of the resulting ScriptAST node will be the result of the first Birdee code set into the ast. resolve_type def resolve_type(source: str) - ResolvedType Convert a string representation of a Birdee type into a ResolvedType AST. The input string should be any valid Birdee type in the current script context, e.g. \"int\", \"string\". set_type def set_type(type: ResolvedType) Can only be called in embeded script for types. Sets the current type script AST with the given resolved type. get_cur_func def get_cur_func() - FunctionAST Returns the reference to the current function AST that the script is in, or None if is not in a function. get_cur_class def get_cur_class() - ClassAST Returns the reference to the current class AST that the script is in, or None if is not in a class. get_func def get_func(name: str) - FunctionAST Find the reference to the function AST with a given name, or None if it does not exist. get_top_level def get_top_level(name: str) - StatementASTList Get the list of statements for the top-level code. get_compile_error def get_compile_error() - CompileError Get the current compile error. You should call it when a CompileException occurs for more information on the error. get_tokenizer_error def get_tokenizer_error() - TokenizerError Get the current tokenizer error. You should call it when a TokenizerException occurs for more information on the error.","title":"Compiler state queries and control"},{"location":"Python Binding/0030.Classes/","text":"Binding classes This chapter introduces the classes that Python scripts can use in Birdee. We use Python type hint syntax to show the members of the classes. Error classes class CompileError: linenumber: int #readonly, the line number of the error pos: int #readonly, the position of characters in the line msg: str #readwrite, the error message The compile error that was actually raised. It can be got from function get_compile_error . class TokenizerError: linenumber: int #readonly, the line number of the error pos: int #readonly, the position of characters in the line msg: str #readwrite, the error message The compile error that was actually raised. It can be got from function get_tokenizer_error . Containers and Ownership pointers Ownership pointer class SOMEUniquePtr: def get() - SOME The ownership pointer of the AST class SOME . SOME above can be replaced by some AST node classes, which can be StatementAST , etc. This UniquePtr class represents the ownership of an AST node. If the ownership is not transfered to another AST node, the AST node will be destroyed when Python runtime reclaim the memory of this ownership pointer object. A reference to AST node is a pointer that has no ownership of the node. You can use get() on a ownership pointer to get the reference of the AST node. You cannot get fields or call member functions directly on ownership pointers. Instead, you can operate on a reference by calling get() . For more information, please refer to the \"Compile time scripts\" chapter of Birdee language manual. For most of the sub-classes of StatementAST and ExprAST, if you get a field of them with type StatementAST , you will get a reference. If you assign a value to the StatementAST typed fields, you usually need a StatementASTUniquePtr and the field will take over the ownership. List class SOMEList: def pop_back(): ... # remove the last item def push_back(itm: SOMEUniquePtr): ... # append an item to the list, will take the owner ship of the itm def __getitem__(idx: int): ... def __setitem__(idx: int, itm: SOMEUniquePtr): ... #will take the ownership of the itm def __len__() - int: ... def __iter__(): ... A list of AST nodes. SOME above can be replaced by some AST node classes, which can be MemberFunctionDef , FieldDef , etc. You can use the list as a normal Python list. The [...] and for ... in ... are allowed on AST node lists. AST classes BasicType class BasicType(Enum): CLASS NULL FUNC VOID BYTE SHORT INT LONG ULONG UINT FLOAT DOUBLE BOOLEAN POINTER PACKAGE It is an enum which represents the basic types. ResolvedType class ResolvedType: base: BasicType # readonly, the base type of the resolved type index_level: int # readwrite, is it an array? 0 for not array, 1 for 1D array and so on def is_class() - bool: ... # if it is a class (not struct) def is_integer() - bool: ... # if it is an integer def get_detail() - ???: ... # get the detailed info of the type. See comments below. def set_detail(_base: BasicType, detail): ... # set the basic type and details def __init__():... def __str__() - str: ... # convert the type into a string def __eq__(other: ResolvedType) - bool: ... # if another type is equal to this The internal class that represents a resolved type. It basically contains three parts. * base is the base type of the type. If it is a basic type (e.g. int), this field should be a enum value (e.g. BasicType.INT ). If the type is a class/struct, this field should be BasicType.CLASS . The detailed ClassAST of the referenced class can be found by detail . If the base type is a BasicType.FUNC , the type is a functype or closure. * index_level is the dimension of the array. If it is 0, the type is not an array. If it is larger than 0, the type is a index_level -D array of type specified by base . * detail is the detailed information of the type. If the type is a class/struct type, get_detail() will return a reference to ClassAST of the referenced class. If the type is a functype or closure, get_detail() will return a reference to PrototypeAST. SourcePos class SourcePos: source_idx: int #readwrite, a unique index for the source file name line: int #readwrite, the line number pos: int #readwrite, the position of characters in the line This class represents a position in the source code. Most of the AST nodes contains a SourcePos object to mark the position of the AST in the source file. PrototypeAST class PrototypeAST: prefix: str # readonly. returns the symbol prefix of the Function definition. # For example, if the function is defined in a module com.a , the prefix should be com.a. name: str # readwrite. the function name or function type name return_type: ResolvedType # readwrite. The return type of the function args: VariableSingleDefASTList # readonly. The argument definitions is_closure: bool # readwrite. if the function is a closure cls: ClassAST # readwrite. The class where the function is defined. Can be None if is not a member function This class holds the information of a function type (functype or closure). It also holds information of a function definition. Template Parameters and Arguments Birdee's function and class templates can have placeholders for types and constant values. The placeholders which are declared in the template definition is called \"template parameters\" in Birdee compiler. For example, the class class Templ[T1,T2, v as int] end has three template parameters, namely T1, T2 and v. The first two are type paramters and the last is constant value parameter. In Python binding, you can access the parameters via the TemplateParameter , TemplateParameters_ClassAST and TemplateParameters_FunctionAST . The class TemplateParameter represents one single template parameter. TemplateParameters_ClassAST and TemplateParameters_FunctionAST are the template parameter lists for classes and functions class TemplateParameter: type: BasicType # readonly. It is CLASS if the template parameter is a type parameter # Otherwise, it is a constant value parameter with the type name: str # readwrite. The name of the parameter class TemplateParameters_ClassAST: #TemplateParameters_FunctionAST is the same params: TemplateParameterList # readonly source: str # readonly. The source code of the template On the other hand, the template arguments are the acutal types/values that are given to the templates when using an instance of template. class TemplateArgument: class TemplateArgumentType(Enum): TEMPLATE_ARG_TYPE TEMPLATE_ARG_EXPR kind: TemplateArgumentType # readwrite, the kind of the argument, type? value? resolved_type: ResolvedType # readwrite. The resolved type for the type argument or the value expr: StatementAST # readwrite. The value expression of the argument. Writing to it needs an ownership pointer and will take the ownership of it AST base classes class StatementAST: pos: SourcePos # readwrite def run(func): ... # run a function func on the sub AST nodes of this node def copy(func) - StatementASTUniquePtr: ... # copy this AST node class ExprAST(StatementAST): resolved_type: ResolvedType #readwrite, the type of the expression def is_lvalue() - bool: ... # returns true if the expression is an LValue (has an address) These two classes are super classes for most of the AST nodes. FunctionAST This class represents a function definition (with body), or a function declaration (without body). class FunctionAST(ExprAST): body: StatementASTList # readonly, the list of statement AST of the body of the function proto: PrototypeAST # readonly, the prototype of the function capture_on_stack: bool # readwrite, if the captured variables of the function is stored on stack is_declare: bool # readwrite, if the function is a declaration or imported from other module is_template_instance: bool # readwrite, if the function is an instance of template function is_imported: bool # readwrite, if the function is imported from other modules template_instance_args: TemplateArgumentList # readonly, if is an template instance, the template argument list; Otherwise None template_source_func: FunctionAST # readonly, if is an template instance, the source template function; Otherwise None capture_this: bool # readwrite, if the function captures this is_template: bool # readonly, if the function is a template function parent: FunctionAST # readonly, if is an closure function, the function that contains the current function; Otherwise None link_name: str # readwrite, the link-time name for the function. # Specifiled by the alias clause of function definition template_param: TemplateParameters_FunctionAST # readonly, if is a template function, the template parameters; Otherwise, None AnnotationStatementAST An annotated statement is wrapped in an AnnotationStatementAST. For example, Birdee code @some function f() end has an AnnotationStatementAST which contains a FunctionAST. class AnnotationStatementAST(StatementAST): @static def new(annotations: list, impl: StatementASTUniquePtr): ... #static function, create a new AnnotationStatementAST node. annotations is a list of string that are for annotations # impl is the annotated AST node. Will take the ownership of impl is_expr: bool # readwrite, if this annotated statement is an expression anno: list # readwrite, a list of annotations in string impl: StatementASTUniquePtr # the ownership pointer of the annotated AST. Reading this field will yield a reference ScriptAST The AST for the embeded scripts, i.e., between {@ @} . class ScriptAST(ExprAST): @static def new(script: str, is_top_level:bool):... # creates a new ScriptAST. is_top_level specifies whether is script is in the top level. stmt: StatementASTList # readonly, the generated statement AST by the script script: str # readwrite, the script ResolvedIdentifierExprAST class ResolvedIdentifierExprAST(ExprAST): def is_mutable()- bool : ... # is this value mutable? This class is an abstract class, which represents an simple primary expression (function name or variable), or a number literal, etc. StringLiteralAST class StringLiteralAST(ResolvedIdentifierExprAST): @static def new(value: str): ... # create a new StringLiteralAST value: str # the string value of the literal This class of AST represents string literals, usually surrounded by a pair of \" , like \"Hello\" in Birdee code. NumberExprAST The AST for number literals. e.g. 1.23 . class NumberExprAST(ResolvedIdentifierExprAST): @static def new(type: BasicType, value): ... # creates a new number with given type value: ??? # readwrite, the value of the number literal type: BasicType # readwrite, the type of the number literal def __str__()- str : ... # convert the value to a Python string ArrayInitializerExprAST class ArrayInitializerExprAST(ExprAST): @static def new(impl: list): ... # create an array from a list of StatementASTUniquePtr values: ExprASTList # readonly, the list of expressions in the array This class of AST represents array literals, like [1,2,3,4] . ReturnAST class ReturnAST(StatementAST): @static def new(retv: StatementASTUniquePtr): ... # create a return statement from an expression. Takes the ownership expr: StatementASTUniquePtr # readwrite, the expression that is returned. Can be None if returns void. This class of AST represents the return statements, like return 0 . IdentifierExprAST class IdentifierExprAST(ExprAST): @static def new(variable_name: str):... #create a new identifier expression. The variable name of the expression is given by the parameter name: str # readwrite, the variable name impl: StatementASTUniquePtr # readwrite, the resolved expression AST. The values of this field # should be a subclass of ResolvedIdentifierExprAST This class represents an identifier expression. For example, a = b here a and b are two IdentifierExprASTs. If b is resolved as an variable, the impl field will be a LocalVarExprAST. If b is an function name, the impl field will be a ResolvedFuncExprAST. ResolvedFuncExprAST class ResolvedFuncExprAST(ResolvedIdentifierExprAST): funcdef: FunctionAST # readwrite, the referenced function This AST is used in IdentifierExprAST to represent a function. ThisExprAST class ThisExprAST(ExprAST): @static def new():... #create a new this expression BoolLiteralExprAST class BoolLiteralExprAST(ExprAST): @static def new(value: bool):... # create a new boolean literal expression value: bool # readwrite, the value of the boolean literal The AST for boolean literal, e.g. true IfBlockAST class IfBlockAST(StatementAST): cond: ExprAST # readonly, the expression to be tested in an if if_true: StatementASTList # readonly, the list of statements for the true condition of the if statement if_falue: StatementASTList # readonly, the list of statements for the else block ForBlockAST class ForBlockAST(StatementAST): is_dim: bool # readwrite, if the for loop's loop variable is defined in the for-statement init_value: StatementASTUniquePtr # readwrite, if is_dim, the variable definition (VariableSingleDefAST). # Otherwise, the initial value of the for loop varaiable loop_var: ExprAST # readwrite, if is_dim==false, the variable definition of the loop variable. Otherwise, None till: StatementASTUniquePtr # readwrite, the expression that marks the end of the loop-variable inclusive: bool # readwrite, if true, it is a for ... to ... . Otherwise, it is a for ... till ... block: StatementASTList # readwrite, the for loop body There are two kinds of for-loops in Birdee. One have the loop varaible defined in the \"for\" statement. The other does not have. for dim i=0 to 3 ... end for j=0 to 3 ... end The difference of these two kinds of for-loop is reflected in the is_dim field of the AST. WhileBlockAST class WhileBlockAST(StatementAST): cond: StatementASTUniquePtr # readwrite, the contition expression of the while loop block: StatementASTList # readonly, the body of the while loop LoopControlAST class LoopControlType(Enum): BREAK CONTINUE class LoopControlAST(StatementAST): @static def new(type: LoopControlType):... # create a new break or continue statement type: LoopControlType # readwrite, the kind of the loop control This AST is either \"break\" or \"continue\" BinaryExprAST The expressions that applies an operator on two expressions. class BinaryOp(Enum): BIN_MUL # * BIN_DIV # / BIN_MOD # % BIN_ADD # + BIN_MINUS # - BIN_LT # BIN_GT # BIN_LE # = BIN_GE # = BIN_EQ # == BIN_NE # != BIN_CMP_EQ # === BIN_CMP_NE # !== BIN_AND # BIN_XOR # ^ BIN_OR # | BIN_LOGIC_AND # BIN_LOGIC_OR # || BIN_ASSIGN # = class BinaryExprAST(ExprAST): @static def new(op: BinaryOp, lhs: StatementASTUniquePtr, rhs: StatementASTUniquePtr): ... #create a new binary expression: lhs op rhs is_overloaded: bool # readwrite, if this binary expression is an overloaded function call to a function lhs: StatementASTUniquePtr # readwrite, the left hand side expression rhs: StatementASTUniquePtr # readwrite, the right hand side expression op: BinaryOp # readwrite the operation on the expressions UnaryExprAST The expressions that applies an operator on one expression. class UnaryOp(Enum): UNA_NOT # ! UNA_ADDRESSOF # addressof UNA_POINTEROF # pointerof UNA_TYPEOF # typeof class UnaryExprAST(ExprAST): is_overloaded: bool # readwrite, if the expression is an overloaded function call # Otherise, None arg: StatementASTUniquePtr # the expression that the operator applies to op: UnaryOp # the operator FunctionTemplateInstanceExprAST The function template instance expression. For example in the code: add[int,long](1,2) The expression add[int,long] is a function template instance. class FunctionTemplateInstanceExprAST(ExprAST): expr: UniquePtrStatementAST # readwrite, the function template instance: FunctionAST # readwrite, the function template instance IndexExprAST The index expression or function template instance expression with only one template parameter. class IndexExprAST(ExprAST): expr: UniquePtrStatementAST # readwrite, the indexed expression (before [...]) index: UniquePtrStatementAST # readwrite, the index (within [...]) template_inst: UniquePtrStatementAST # readwrite, if is a template, the template instance expression. # otherwise, None def is_template_instance()- bool: ... # returns if it is a function template instance CallExprAST The AST for function calls. class CallExprAST(ExprAST): callee: UniquePtrStatementAST # readwrite, the callee expression (before (...) ) args: StatementASTList # readonly, arguments (within (...) ) VariableSingleDefAST The AST which defines a single variable. Corresponds to dim statements. class VariableSingleDefAST(StatementAST): # the types of captures of a variable class CaptureType(Enum): CAPTURE_NONE # not captured CAPTURE_REF # capturing reference to the parent capture object CAPTURE_VAL # capturing the values to the parent capture object name: str # readwrite, the name of the variable value: StatementASTUniquePtr # readwrite, the initial value of the variable. Can be None resolved_type: ResolvedType # readwrite, the type of the variable capture_import_type: CaptureType # readwrite, how the captured variable is imported from parent function capture_import_idx: int # readwrite, the capture index within the parent function capture_export_type: CaptureType # readwrite, how the captured variable is exported to child functions capture_export_idx: int # readwrite, the capture index within capture object for the child functions VariableMultiDefAST The AST that contains multiple variable definitions. class VariableMultiDefAST(StatementAST): lst: VariableSingleDefASTList # readonly, the variable list LocalVarExprAST The AST used by IdentifierExprAST to reference variables. class LocalVarExprAST(ResolvedIdentifierExprAST): @static def new(v: VariableSingleDefAST):... # creates a new LocalVarExprAST vardef: VariableSingleDefAST # readwrite, the variable definition FunctionToClosureAST The AST automatically generated by compiler to convert a function to a closure. class FunctionToClosureAST(ExprAST): func: StatementASTUniquePtr # readwrite, the function/functype expression to be converted TryBlockAST The AST for \"try ... catch ...\" block. A try block may contain several catch variables to catch different types of exception. There are also the same number of \"catch\" blocks in the AST. class TryBlockAST(StatementAST): try_block: StatementASTList # readonly, try block catch_variables: VariableSingleDefASTList # readonly, the definitions of the catch variables def get_catch_block(idx: int) - StatementASTList : ... # get a catch block. The index is from 0 to len(catch_variables) - 1 ThrowAST class ThrowAST(StatementAST): expr: StatementASTUniquePtr # readwrite, the throw expression Class ASTs class AccessModifier(Enum): PUBLIC PRIVATE class FieldDef: @static def new(index: int, access: AccessModifier, vdef: StatementASTUniquePtr) - FieldDefUniquePtr: ... # creates a new field, with given index, modifier and the variable definition (given by vdef) index: int # readwrite, the index of the field within the class access: AccessModifier # readwrite, the access modifier decl: StatementASTUniquePtr # readwrite, should be VarialeSingleDefAST. The variable definition class MemberFunctionDef: @static def new(access: AccessModifier, fdef: StatementASTUniquePtr) - MemberFunctionDef: ... # creates a new field, with modifier and the FunctionAST (given by fdef) access: AccessModifier # readwrite, the access modifier decl: StatementASTUniquePtr # readwrite, should be FunctionAST. The function definition class ClassAST(StatementAST): name: str # readwrite, the name of the class fields: FieldDefList # readonly, the list of fields funcs: MemberFunctionDefList # readonly, the list of member functions template_instance_args: TemplateArgumentList # readonly, the list of the template arguement if it is a template instance template_source_class: ClassAST # readonly, the template source AST if it is a template instance template_param: TemplateParameters_ClassAST # readonly, the template parameters if it is a template needs_rtti: bool # readwrite, if the class has RTTI enabled is_struct: bool # readonly, if it is a struct instead of a class parent_class: ClassAST # readonly, the parent class that this class inherits from def is_template_instance() - bool: ... # returns if it is a template instance def is_template() - bool: ... # returns if it is a template def get_unique_name()- str: ... # returns the fully qualified name of the class def find_field(name: str) - (int,FieldDef): ... # find a field by name from this class. # returns a tuple (int, FieldDef). The int is the number of levels of parents where the field is found. # the returned FieldDef may not be in the current class NewExprAST The AST for new AST, including newing an array or an object. class NewExprAST(ExprAST): args: StatementASTList # readonly, the list of arguments/dimensions to the new expression func: FunctionAST # readwrite, the constructor function to be called MemberExprAST The AST for referencing members of an object, or functions/variables imported from other modules. class MemberExprAST(ResolvedIdentifierExprAST): class MemberType(Enum): ERROR PACKAGE # if it is an package. e.g. in mod1.mod2.v1 , mod1.mod2 is of type PACKAGE FIELD # a field of an object FUNCTION # a member function of an object IMPORTED_DIM # an imported variable of other modules VIRTUAL_FUNCTION # a virtual function of an object, will read the vtable to generate the callee IMPORTED_FUNCTION # a function of an imported module @static def new(obj: StatementASTUniquePtr, name: str): ... # creates a new member expr obj.name @static def new_func_member(obj: StatementASTUniquePtr, member: MemberFunctionDef): ... # creates a new member function expr kind: MemberType # the kind of the member obj: StatementASTUniquePtr # the object # the following fields can only be read when this class actually stores that kind of value # you can get the kind of the exact value by kind field func: MemberFunctionDef field: FieldDef imported_func: FunctionAST import_dim: VariableSingleDefAST def to_string_array()- list: ... # convert the member expr chain to a list of python string Number Cast AST This is a class of AST classes. Each converts a number type from another. The FROM and TO in the code below are two number types. class CastNumberExpr_FROM_TO(ExprAST): @static def new(expr: StatementASTUniquePtr):... # creates a new Number Cast AST expr: StatementASTUniquePtr # the expression to be converted","title":"Binding classes"},{"location":"Python Binding/0030.Classes/#binding-classes","text":"This chapter introduces the classes that Python scripts can use in Birdee. We use Python type hint syntax to show the members of the classes.","title":"Binding classes"},{"location":"Python Binding/0030.Classes/#error-classes","text":"class CompileError: linenumber: int #readonly, the line number of the error pos: int #readonly, the position of characters in the line msg: str #readwrite, the error message The compile error that was actually raised. It can be got from function get_compile_error . class TokenizerError: linenumber: int #readonly, the line number of the error pos: int #readonly, the position of characters in the line msg: str #readwrite, the error message The compile error that was actually raised. It can be got from function get_tokenizer_error .","title":"Error classes"},{"location":"Python Binding/0030.Classes/#containers-and-ownership-pointers","text":"","title":"Containers and Ownership pointers"},{"location":"Python Binding/0030.Classes/#ownership-pointer","text":"class SOMEUniquePtr: def get() - SOME The ownership pointer of the AST class SOME . SOME above can be replaced by some AST node classes, which can be StatementAST , etc. This UniquePtr class represents the ownership of an AST node. If the ownership is not transfered to another AST node, the AST node will be destroyed when Python runtime reclaim the memory of this ownership pointer object. A reference to AST node is a pointer that has no ownership of the node. You can use get() on a ownership pointer to get the reference of the AST node. You cannot get fields or call member functions directly on ownership pointers. Instead, you can operate on a reference by calling get() . For more information, please refer to the \"Compile time scripts\" chapter of Birdee language manual. For most of the sub-classes of StatementAST and ExprAST, if you get a field of them with type StatementAST , you will get a reference. If you assign a value to the StatementAST typed fields, you usually need a StatementASTUniquePtr and the field will take over the ownership.","title":"Ownership pointer"},{"location":"Python Binding/0030.Classes/#list","text":"class SOMEList: def pop_back(): ... # remove the last item def push_back(itm: SOMEUniquePtr): ... # append an item to the list, will take the owner ship of the itm def __getitem__(idx: int): ... def __setitem__(idx: int, itm: SOMEUniquePtr): ... #will take the ownership of the itm def __len__() - int: ... def __iter__(): ... A list of AST nodes. SOME above can be replaced by some AST node classes, which can be MemberFunctionDef , FieldDef , etc. You can use the list as a normal Python list. The [...] and for ... in ... are allowed on AST node lists.","title":"List"},{"location":"Python Binding/0030.Classes/#ast-classes","text":"","title":"AST classes"},{"location":"Python Binding/0030.Classes/#basictype","text":"class BasicType(Enum): CLASS NULL FUNC VOID BYTE SHORT INT LONG ULONG UINT FLOAT DOUBLE BOOLEAN POINTER PACKAGE It is an enum which represents the basic types.","title":"BasicType"},{"location":"Python Binding/0030.Classes/#resolvedtype","text":"class ResolvedType: base: BasicType # readonly, the base type of the resolved type index_level: int # readwrite, is it an array? 0 for not array, 1 for 1D array and so on def is_class() - bool: ... # if it is a class (not struct) def is_integer() - bool: ... # if it is an integer def get_detail() - ???: ... # get the detailed info of the type. See comments below. def set_detail(_base: BasicType, detail): ... # set the basic type and details def __init__():... def __str__() - str: ... # convert the type into a string def __eq__(other: ResolvedType) - bool: ... # if another type is equal to this The internal class that represents a resolved type. It basically contains three parts. * base is the base type of the type. If it is a basic type (e.g. int), this field should be a enum value (e.g. BasicType.INT ). If the type is a class/struct, this field should be BasicType.CLASS . The detailed ClassAST of the referenced class can be found by detail . If the base type is a BasicType.FUNC , the type is a functype or closure. * index_level is the dimension of the array. If it is 0, the type is not an array. If it is larger than 0, the type is a index_level -D array of type specified by base . * detail is the detailed information of the type. If the type is a class/struct type, get_detail() will return a reference to ClassAST of the referenced class. If the type is a functype or closure, get_detail() will return a reference to PrototypeAST.","title":"ResolvedType"},{"location":"Python Binding/0030.Classes/#sourcepos","text":"class SourcePos: source_idx: int #readwrite, a unique index for the source file name line: int #readwrite, the line number pos: int #readwrite, the position of characters in the line This class represents a position in the source code. Most of the AST nodes contains a SourcePos object to mark the position of the AST in the source file.","title":"SourcePos"},{"location":"Python Binding/0030.Classes/#prototypeast","text":"class PrototypeAST: prefix: str # readonly. returns the symbol prefix of the Function definition. # For example, if the function is defined in a module com.a , the prefix should be com.a. name: str # readwrite. the function name or function type name return_type: ResolvedType # readwrite. The return type of the function args: VariableSingleDefASTList # readonly. The argument definitions is_closure: bool # readwrite. if the function is a closure cls: ClassAST # readwrite. The class where the function is defined. Can be None if is not a member function This class holds the information of a function type (functype or closure). It also holds information of a function definition.","title":"PrototypeAST"},{"location":"Python Binding/0030.Classes/#template-parameters-and-arguments","text":"Birdee's function and class templates can have placeholders for types and constant values. The placeholders which are declared in the template definition is called \"template parameters\" in Birdee compiler. For example, the class class Templ[T1,T2, v as int] end has three template parameters, namely T1, T2 and v. The first two are type paramters and the last is constant value parameter. In Python binding, you can access the parameters via the TemplateParameter , TemplateParameters_ClassAST and TemplateParameters_FunctionAST . The class TemplateParameter represents one single template parameter. TemplateParameters_ClassAST and TemplateParameters_FunctionAST are the template parameter lists for classes and functions class TemplateParameter: type: BasicType # readonly. It is CLASS if the template parameter is a type parameter # Otherwise, it is a constant value parameter with the type name: str # readwrite. The name of the parameter class TemplateParameters_ClassAST: #TemplateParameters_FunctionAST is the same params: TemplateParameterList # readonly source: str # readonly. The source code of the template On the other hand, the template arguments are the acutal types/values that are given to the templates when using an instance of template. class TemplateArgument: class TemplateArgumentType(Enum): TEMPLATE_ARG_TYPE TEMPLATE_ARG_EXPR kind: TemplateArgumentType # readwrite, the kind of the argument, type? value? resolved_type: ResolvedType # readwrite. The resolved type for the type argument or the value expr: StatementAST # readwrite. The value expression of the argument. Writing to it needs an ownership pointer and will take the ownership of it","title":"Template Parameters and Arguments"},{"location":"Python Binding/0030.Classes/#ast-base-classes","text":"class StatementAST: pos: SourcePos # readwrite def run(func): ... # run a function func on the sub AST nodes of this node def copy(func) - StatementASTUniquePtr: ... # copy this AST node class ExprAST(StatementAST): resolved_type: ResolvedType #readwrite, the type of the expression def is_lvalue() - bool: ... # returns true if the expression is an LValue (has an address) These two classes are super classes for most of the AST nodes.","title":"AST base classes"},{"location":"Python Binding/0030.Classes/#functionast","text":"This class represents a function definition (with body), or a function declaration (without body). class FunctionAST(ExprAST): body: StatementASTList # readonly, the list of statement AST of the body of the function proto: PrototypeAST # readonly, the prototype of the function capture_on_stack: bool # readwrite, if the captured variables of the function is stored on stack is_declare: bool # readwrite, if the function is a declaration or imported from other module is_template_instance: bool # readwrite, if the function is an instance of template function is_imported: bool # readwrite, if the function is imported from other modules template_instance_args: TemplateArgumentList # readonly, if is an template instance, the template argument list; Otherwise None template_source_func: FunctionAST # readonly, if is an template instance, the source template function; Otherwise None capture_this: bool # readwrite, if the function captures this is_template: bool # readonly, if the function is a template function parent: FunctionAST # readonly, if is an closure function, the function that contains the current function; Otherwise None link_name: str # readwrite, the link-time name for the function. # Specifiled by the alias clause of function definition template_param: TemplateParameters_FunctionAST # readonly, if is a template function, the template parameters; Otherwise, None","title":"FunctionAST"},{"location":"Python Binding/0030.Classes/#annotationstatementast","text":"An annotated statement is wrapped in an AnnotationStatementAST. For example, Birdee code @some function f() end has an AnnotationStatementAST which contains a FunctionAST. class AnnotationStatementAST(StatementAST): @static def new(annotations: list, impl: StatementASTUniquePtr): ... #static function, create a new AnnotationStatementAST node. annotations is a list of string that are for annotations # impl is the annotated AST node. Will take the ownership of impl is_expr: bool # readwrite, if this annotated statement is an expression anno: list # readwrite, a list of annotations in string impl: StatementASTUniquePtr # the ownership pointer of the annotated AST. Reading this field will yield a reference","title":"AnnotationStatementAST"},{"location":"Python Binding/0030.Classes/#scriptast","text":"The AST for the embeded scripts, i.e., between {@ @} . class ScriptAST(ExprAST): @static def new(script: str, is_top_level:bool):... # creates a new ScriptAST. is_top_level specifies whether is script is in the top level. stmt: StatementASTList # readonly, the generated statement AST by the script script: str # readwrite, the script","title":"ScriptAST"},{"location":"Python Binding/0030.Classes/#resolvedidentifierexprast","text":"class ResolvedIdentifierExprAST(ExprAST): def is_mutable()- bool : ... # is this value mutable? This class is an abstract class, which represents an simple primary expression (function name or variable), or a number literal, etc.","title":"ResolvedIdentifierExprAST"},{"location":"Python Binding/0030.Classes/#stringliteralast","text":"class StringLiteralAST(ResolvedIdentifierExprAST): @static def new(value: str): ... # create a new StringLiteralAST value: str # the string value of the literal This class of AST represents string literals, usually surrounded by a pair of \" , like \"Hello\" in Birdee code.","title":"StringLiteralAST"},{"location":"Python Binding/0030.Classes/#numberexprast","text":"The AST for number literals. e.g. 1.23 . class NumberExprAST(ResolvedIdentifierExprAST): @static def new(type: BasicType, value): ... # creates a new number with given type value: ??? # readwrite, the value of the number literal type: BasicType # readwrite, the type of the number literal def __str__()- str : ... # convert the value to a Python string","title":"NumberExprAST"},{"location":"Python Binding/0030.Classes/#arrayinitializerexprast","text":"class ArrayInitializerExprAST(ExprAST): @static def new(impl: list): ... # create an array from a list of StatementASTUniquePtr values: ExprASTList # readonly, the list of expressions in the array This class of AST represents array literals, like [1,2,3,4] .","title":"ArrayInitializerExprAST"},{"location":"Python Binding/0030.Classes/#returnast","text":"class ReturnAST(StatementAST): @static def new(retv: StatementASTUniquePtr): ... # create a return statement from an expression. Takes the ownership expr: StatementASTUniquePtr # readwrite, the expression that is returned. Can be None if returns void. This class of AST represents the return statements, like return 0 .","title":"ReturnAST"},{"location":"Python Binding/0030.Classes/#identifierexprast","text":"class IdentifierExprAST(ExprAST): @static def new(variable_name: str):... #create a new identifier expression. The variable name of the expression is given by the parameter name: str # readwrite, the variable name impl: StatementASTUniquePtr # readwrite, the resolved expression AST. The values of this field # should be a subclass of ResolvedIdentifierExprAST This class represents an identifier expression. For example, a = b here a and b are two IdentifierExprASTs. If b is resolved as an variable, the impl field will be a LocalVarExprAST. If b is an function name, the impl field will be a ResolvedFuncExprAST.","title":"IdentifierExprAST"},{"location":"Python Binding/0030.Classes/#resolvedfuncexprast","text":"class ResolvedFuncExprAST(ResolvedIdentifierExprAST): funcdef: FunctionAST # readwrite, the referenced function This AST is used in IdentifierExprAST to represent a function.","title":"ResolvedFuncExprAST"},{"location":"Python Binding/0030.Classes/#thisexprast","text":"class ThisExprAST(ExprAST): @static def new():... #create a new this expression","title":"ThisExprAST"},{"location":"Python Binding/0030.Classes/#boolliteralexprast","text":"class BoolLiteralExprAST(ExprAST): @static def new(value: bool):... # create a new boolean literal expression value: bool # readwrite, the value of the boolean literal The AST for boolean literal, e.g. true","title":"BoolLiteralExprAST"},{"location":"Python Binding/0030.Classes/#ifblockast","text":"class IfBlockAST(StatementAST): cond: ExprAST # readonly, the expression to be tested in an if if_true: StatementASTList # readonly, the list of statements for the true condition of the if statement if_falue: StatementASTList # readonly, the list of statements for the else block","title":"IfBlockAST"},{"location":"Python Binding/0030.Classes/#forblockast","text":"class ForBlockAST(StatementAST): is_dim: bool # readwrite, if the for loop's loop variable is defined in the for-statement init_value: StatementASTUniquePtr # readwrite, if is_dim, the variable definition (VariableSingleDefAST). # Otherwise, the initial value of the for loop varaiable loop_var: ExprAST # readwrite, if is_dim==false, the variable definition of the loop variable. Otherwise, None till: StatementASTUniquePtr # readwrite, the expression that marks the end of the loop-variable inclusive: bool # readwrite, if true, it is a for ... to ... . Otherwise, it is a for ... till ... block: StatementASTList # readwrite, the for loop body There are two kinds of for-loops in Birdee. One have the loop varaible defined in the \"for\" statement. The other does not have. for dim i=0 to 3 ... end for j=0 to 3 ... end The difference of these two kinds of for-loop is reflected in the is_dim field of the AST.","title":"ForBlockAST"},{"location":"Python Binding/0030.Classes/#whileblockast","text":"class WhileBlockAST(StatementAST): cond: StatementASTUniquePtr # readwrite, the contition expression of the while loop block: StatementASTList # readonly, the body of the while loop","title":"WhileBlockAST"},{"location":"Python Binding/0030.Classes/#loopcontrolast","text":"class LoopControlType(Enum): BREAK CONTINUE class LoopControlAST(StatementAST): @static def new(type: LoopControlType):... # create a new break or continue statement type: LoopControlType # readwrite, the kind of the loop control This AST is either \"break\" or \"continue\"","title":"LoopControlAST"},{"location":"Python Binding/0030.Classes/#binaryexprast","text":"The expressions that applies an operator on two expressions. class BinaryOp(Enum): BIN_MUL # * BIN_DIV # / BIN_MOD # % BIN_ADD # + BIN_MINUS # - BIN_LT # BIN_GT # BIN_LE # = BIN_GE # = BIN_EQ # == BIN_NE # != BIN_CMP_EQ # === BIN_CMP_NE # !== BIN_AND # BIN_XOR # ^ BIN_OR # | BIN_LOGIC_AND # BIN_LOGIC_OR # || BIN_ASSIGN # = class BinaryExprAST(ExprAST): @static def new(op: BinaryOp, lhs: StatementASTUniquePtr, rhs: StatementASTUniquePtr): ... #create a new binary expression: lhs op rhs is_overloaded: bool # readwrite, if this binary expression is an overloaded function call to a function lhs: StatementASTUniquePtr # readwrite, the left hand side expression rhs: StatementASTUniquePtr # readwrite, the right hand side expression op: BinaryOp # readwrite the operation on the expressions","title":"BinaryExprAST"},{"location":"Python Binding/0030.Classes/#unaryexprast","text":"The expressions that applies an operator on one expression. class UnaryOp(Enum): UNA_NOT # ! UNA_ADDRESSOF # addressof UNA_POINTEROF # pointerof UNA_TYPEOF # typeof class UnaryExprAST(ExprAST): is_overloaded: bool # readwrite, if the expression is an overloaded function call # Otherise, None arg: StatementASTUniquePtr # the expression that the operator applies to op: UnaryOp # the operator","title":"UnaryExprAST"},{"location":"Python Binding/0030.Classes/#functiontemplateinstanceexprast","text":"The function template instance expression. For example in the code: add[int,long](1,2) The expression add[int,long] is a function template instance. class FunctionTemplateInstanceExprAST(ExprAST): expr: UniquePtrStatementAST # readwrite, the function template instance: FunctionAST # readwrite, the function template instance","title":"FunctionTemplateInstanceExprAST"},{"location":"Python Binding/0030.Classes/#indexexprast","text":"The index expression or function template instance expression with only one template parameter. class IndexExprAST(ExprAST): expr: UniquePtrStatementAST # readwrite, the indexed expression (before [...]) index: UniquePtrStatementAST # readwrite, the index (within [...]) template_inst: UniquePtrStatementAST # readwrite, if is a template, the template instance expression. # otherwise, None def is_template_instance()- bool: ... # returns if it is a function template instance","title":"IndexExprAST"},{"location":"Python Binding/0030.Classes/#callexprast","text":"The AST for function calls. class CallExprAST(ExprAST): callee: UniquePtrStatementAST # readwrite, the callee expression (before (...) ) args: StatementASTList # readonly, arguments (within (...) )","title":"CallExprAST"},{"location":"Python Binding/0030.Classes/#variablesingledefast","text":"The AST which defines a single variable. Corresponds to dim statements. class VariableSingleDefAST(StatementAST): # the types of captures of a variable class CaptureType(Enum): CAPTURE_NONE # not captured CAPTURE_REF # capturing reference to the parent capture object CAPTURE_VAL # capturing the values to the parent capture object name: str # readwrite, the name of the variable value: StatementASTUniquePtr # readwrite, the initial value of the variable. Can be None resolved_type: ResolvedType # readwrite, the type of the variable capture_import_type: CaptureType # readwrite, how the captured variable is imported from parent function capture_import_idx: int # readwrite, the capture index within the parent function capture_export_type: CaptureType # readwrite, how the captured variable is exported to child functions capture_export_idx: int # readwrite, the capture index within capture object for the child functions","title":"VariableSingleDefAST"},{"location":"Python Binding/0030.Classes/#variablemultidefast","text":"The AST that contains multiple variable definitions. class VariableMultiDefAST(StatementAST): lst: VariableSingleDefASTList # readonly, the variable list","title":"VariableMultiDefAST"},{"location":"Python Binding/0030.Classes/#localvarexprast","text":"The AST used by IdentifierExprAST to reference variables. class LocalVarExprAST(ResolvedIdentifierExprAST): @static def new(v: VariableSingleDefAST):... # creates a new LocalVarExprAST vardef: VariableSingleDefAST # readwrite, the variable definition","title":"LocalVarExprAST"},{"location":"Python Binding/0030.Classes/#functiontoclosureast","text":"The AST automatically generated by compiler to convert a function to a closure. class FunctionToClosureAST(ExprAST): func: StatementASTUniquePtr # readwrite, the function/functype expression to be converted","title":"FunctionToClosureAST"},{"location":"Python Binding/0030.Classes/#tryblockast","text":"The AST for \"try ... catch ...\" block. A try block may contain several catch variables to catch different types of exception. There are also the same number of \"catch\" blocks in the AST. class TryBlockAST(StatementAST): try_block: StatementASTList # readonly, try block catch_variables: VariableSingleDefASTList # readonly, the definitions of the catch variables def get_catch_block(idx: int) - StatementASTList : ... # get a catch block. The index is from 0 to len(catch_variables) - 1","title":"TryBlockAST"},{"location":"Python Binding/0030.Classes/#throwast","text":"class ThrowAST(StatementAST): expr: StatementASTUniquePtr # readwrite, the throw expression","title":"ThrowAST"},{"location":"Python Binding/0030.Classes/#class-asts","text":"class AccessModifier(Enum): PUBLIC PRIVATE class FieldDef: @static def new(index: int, access: AccessModifier, vdef: StatementASTUniquePtr) - FieldDefUniquePtr: ... # creates a new field, with given index, modifier and the variable definition (given by vdef) index: int # readwrite, the index of the field within the class access: AccessModifier # readwrite, the access modifier decl: StatementASTUniquePtr # readwrite, should be VarialeSingleDefAST. The variable definition class MemberFunctionDef: @static def new(access: AccessModifier, fdef: StatementASTUniquePtr) - MemberFunctionDef: ... # creates a new field, with modifier and the FunctionAST (given by fdef) access: AccessModifier # readwrite, the access modifier decl: StatementASTUniquePtr # readwrite, should be FunctionAST. The function definition class ClassAST(StatementAST): name: str # readwrite, the name of the class fields: FieldDefList # readonly, the list of fields funcs: MemberFunctionDefList # readonly, the list of member functions template_instance_args: TemplateArgumentList # readonly, the list of the template arguement if it is a template instance template_source_class: ClassAST # readonly, the template source AST if it is a template instance template_param: TemplateParameters_ClassAST # readonly, the template parameters if it is a template needs_rtti: bool # readwrite, if the class has RTTI enabled is_struct: bool # readonly, if it is a struct instead of a class parent_class: ClassAST # readonly, the parent class that this class inherits from def is_template_instance() - bool: ... # returns if it is a template instance def is_template() - bool: ... # returns if it is a template def get_unique_name()- str: ... # returns the fully qualified name of the class def find_field(name: str) - (int,FieldDef): ... # find a field by name from this class. # returns a tuple (int, FieldDef). The int is the number of levels of parents where the field is found. # the returned FieldDef may not be in the current class","title":"Class ASTs"},{"location":"Python Binding/0030.Classes/#newexprast","text":"The AST for new AST, including newing an array or an object. class NewExprAST(ExprAST): args: StatementASTList # readonly, the list of arguments/dimensions to the new expression func: FunctionAST # readwrite, the constructor function to be called","title":"NewExprAST"},{"location":"Python Binding/0030.Classes/#memberexprast","text":"The AST for referencing members of an object, or functions/variables imported from other modules. class MemberExprAST(ResolvedIdentifierExprAST): class MemberType(Enum): ERROR PACKAGE # if it is an package. e.g. in mod1.mod2.v1 , mod1.mod2 is of type PACKAGE FIELD # a field of an object FUNCTION # a member function of an object IMPORTED_DIM # an imported variable of other modules VIRTUAL_FUNCTION # a virtual function of an object, will read the vtable to generate the callee IMPORTED_FUNCTION # a function of an imported module @static def new(obj: StatementASTUniquePtr, name: str): ... # creates a new member expr obj.name @static def new_func_member(obj: StatementASTUniquePtr, member: MemberFunctionDef): ... # creates a new member function expr kind: MemberType # the kind of the member obj: StatementASTUniquePtr # the object # the following fields can only be read when this class actually stores that kind of value # you can get the kind of the exact value by kind field func: MemberFunctionDef field: FieldDef imported_func: FunctionAST import_dim: VariableSingleDefAST def to_string_array()- list: ... # convert the member expr chain to a list of python string","title":"MemberExprAST"},{"location":"Python Binding/0030.Classes/#number-cast-ast","text":"This is a class of AST classes. Each converts a number type from another. The FROM and TO in the code below are two number types. class CastNumberExpr_FROM_TO(ExprAST): @static def new(expr: StatementASTUniquePtr):... # creates a new Number Cast AST expr: StatementASTUniquePtr # the expression to be converted","title":"Number Cast AST"},{"location":"Python Binding/0040.HighLevelAPI/","text":"High level APIs Besides the core functions and classes provided by the birdeec module, Birdee provides high level APIs that are written in Python based on the core APIs, to make it easier to do meta-programming using the scripts. The module names include bdconst , bdassert , bdutils , and traits . You can import the module in your scripts. bdutils This module provides some most handy functions that you may frequently need in your scripts. The functions falls into the following categroies. AST creation and insertion The make_* functions in this section create an AST node for the given type. The set_* functions create the AST and call the birdeec.set_ast function to insert the created AST to the current script AST. def make_int(n: int)- StatementASTUniquePtr : ... def set_int(n: int): ... def make_uint(n: int)- StatementASTUniquePtr : ... def set_uint(n: int): ... def make_long(n: int)- StatementASTUniquePtr : ... def set_long(n: int): ... def make_ulong(n: int)- StatementASTUniquePtr : ... def set_ulong(n: int): ... # c should be a string of length 1. This function # sets the script AST to the ASCII code of the character def set_char(c: str)- StatementASTUniquePtr : ... def make_float(n: float)- StatementASTUniquePtr : ... def set_float(n: float): ... def make_double(n: float)- StatementASTUniquePtr : ... def set_double(n: float): ... def make_bool(n: bool)- StatementASTUniquePtr : ... def set_bool(n: bool): ... def make_str(s: str)- StatementASTUniquePtr : ... def set_str(s: str): ... def set_expr(s: str): ... def set_stmt(s: str): ... # resolve and set a type def resolve_set_type(s: str): ... Utilities for templates These functions are utilities for getting information from the templates or functions. #Get the template argument of the current class at a specific index def get_cls_templ_at(idx)- TemplateArgument: ... #Get the template argument of the current class at a specific index, and makes sure it is a type def get_cls_type_templ_at(idx)- ResolvedType: ... #Get the template argument of the current class at a specific index, and makes sure it is an expression def get_cls_expr_templ_at(idx)- ExprASTUniquePtr: ... #Get and set the template argument of the current class at a specific index as a type def cls_templ_type_at(idx): ... #Get and set the template argument of the current class at a specific index as a expression def cls_templ_expr_at(idx): ... #Get the definition of a parameter of a function def get_func_arg_at(func: FunctionAST,idx)- VariableSingleDefAST: ... #Get the template argument at a specific index of a function (by default the current function) def get_func_templ_at(idx, thefunc = None)- - TemplateArgument: ... #Get the template argument as a type of the a function at a specific index (by default from the current function) def get_func_type_templ_at(idx, thefunc = None)- ResolvedType: ... #Get the template argument as an expression of the a function at a specific index (by default from the current function) def get_func_expr_templ_at(idx, thefunc = None)- ExprASTUniquePtr: ... #Get and set the template argument of a function at a specific index as a type (by default from the current function) def func_templ_type_at(idx, thefunc = None):... #Get and set the template argument of a function at a specific index as a type (by default from the current function) def func_templ_expr_at(idx, thefunc = None):... bdconst This module enables developers to generate constant integers in Birdee code. def define(name, value):... The define function takes two parameters, name is the name of the defined constant. value is the integer value of the constant. After you call this function, two Python variables are defined in the Python globals, which have the names name and _name (\"name\" has been specified by the parameter). The name variable is a function that will generate an constant integer AST node and set the current AST using the generated AST. The _name variable is a Python integer that has the same value of value parameter of the define function. Here we give an example of using define function: {@ from bdconst import define define( CONST1 , 1) define( CONST2 , 2) print(_CONST1) print(_CONST2) @} dim v1 = {@CONST1()@} dim v2 = {@CONST2()@} After compiling the above example, the compiler will print the values of _CONST1 and _CONST2 which are 1 and 2. The Birdee variables v1 and v2 have the initial values of 1 and 2. bdassert This module provides the code generator that can do runtime assertion. In Birdee programs, developers may have some assertions on the states of the program. The condition of the assertion will be checked at the run time. If the condition does not hold, a runtime_exception will be raised. def bdassert(expr: str):... The bdassert function takes one parameter that is the Birdee source code string for the condition to check. This function will generate the input source code as an expression and also generate the code to check if the generated expression is true . The expr should be a boolean Birdee expression. Here is an example: {@from bdassert import *@} function complicated() as int ... end dim v as int = compilcated() {@bdassert( v!=0 )@} println(int2str(32/v)) The above example uses bdassert to make sure that v is never 0. If it is zero, an exception will be throw. The bdassert function is useful for debugging and testing.","title":"High level APIs"},{"location":"Python Binding/0040.HighLevelAPI/#high-level-apis","text":"Besides the core functions and classes provided by the birdeec module, Birdee provides high level APIs that are written in Python based on the core APIs, to make it easier to do meta-programming using the scripts. The module names include bdconst , bdassert , bdutils , and traits . You can import the module in your scripts.","title":"High level APIs"},{"location":"Python Binding/0040.HighLevelAPI/#bdutils","text":"This module provides some most handy functions that you may frequently need in your scripts. The functions falls into the following categroies.","title":"bdutils"},{"location":"Python Binding/0040.HighLevelAPI/#ast-creation-and-insertion","text":"The make_* functions in this section create an AST node for the given type. The set_* functions create the AST and call the birdeec.set_ast function to insert the created AST to the current script AST. def make_int(n: int)- StatementASTUniquePtr : ... def set_int(n: int): ... def make_uint(n: int)- StatementASTUniquePtr : ... def set_uint(n: int): ... def make_long(n: int)- StatementASTUniquePtr : ... def set_long(n: int): ... def make_ulong(n: int)- StatementASTUniquePtr : ... def set_ulong(n: int): ... # c should be a string of length 1. This function # sets the script AST to the ASCII code of the character def set_char(c: str)- StatementASTUniquePtr : ... def make_float(n: float)- StatementASTUniquePtr : ... def set_float(n: float): ... def make_double(n: float)- StatementASTUniquePtr : ... def set_double(n: float): ... def make_bool(n: bool)- StatementASTUniquePtr : ... def set_bool(n: bool): ... def make_str(s: str)- StatementASTUniquePtr : ... def set_str(s: str): ... def set_expr(s: str): ... def set_stmt(s: str): ... # resolve and set a type def resolve_set_type(s: str): ...","title":"AST creation and insertion"},{"location":"Python Binding/0040.HighLevelAPI/#utilities-for-templates","text":"These functions are utilities for getting information from the templates or functions. #Get the template argument of the current class at a specific index def get_cls_templ_at(idx)- TemplateArgument: ... #Get the template argument of the current class at a specific index, and makes sure it is a type def get_cls_type_templ_at(idx)- ResolvedType: ... #Get the template argument of the current class at a specific index, and makes sure it is an expression def get_cls_expr_templ_at(idx)- ExprASTUniquePtr: ... #Get and set the template argument of the current class at a specific index as a type def cls_templ_type_at(idx): ... #Get and set the template argument of the current class at a specific index as a expression def cls_templ_expr_at(idx): ... #Get the definition of a parameter of a function def get_func_arg_at(func: FunctionAST,idx)- VariableSingleDefAST: ... #Get the template argument at a specific index of a function (by default the current function) def get_func_templ_at(idx, thefunc = None)- - TemplateArgument: ... #Get the template argument as a type of the a function at a specific index (by default from the current function) def get_func_type_templ_at(idx, thefunc = None)- ResolvedType: ... #Get the template argument as an expression of the a function at a specific index (by default from the current function) def get_func_expr_templ_at(idx, thefunc = None)- ExprASTUniquePtr: ... #Get and set the template argument of a function at a specific index as a type (by default from the current function) def func_templ_type_at(idx, thefunc = None):... #Get and set the template argument of a function at a specific index as a type (by default from the current function) def func_templ_expr_at(idx, thefunc = None):...","title":"Utilities for templates"},{"location":"Python Binding/0040.HighLevelAPI/#bdconst","text":"This module enables developers to generate constant integers in Birdee code. def define(name, value):... The define function takes two parameters, name is the name of the defined constant. value is the integer value of the constant. After you call this function, two Python variables are defined in the Python globals, which have the names name and _name (\"name\" has been specified by the parameter). The name variable is a function that will generate an constant integer AST node and set the current AST using the generated AST. The _name variable is a Python integer that has the same value of value parameter of the define function. Here we give an example of using define function: {@ from bdconst import define define( CONST1 , 1) define( CONST2 , 2) print(_CONST1) print(_CONST2) @} dim v1 = {@CONST1()@} dim v2 = {@CONST2()@} After compiling the above example, the compiler will print the values of _CONST1 and _CONST2 which are 1 and 2. The Birdee variables v1 and v2 have the initial values of 1 and 2.","title":"bdconst"},{"location":"Python Binding/0040.HighLevelAPI/#bdassert","text":"This module provides the code generator that can do runtime assertion. In Birdee programs, developers may have some assertions on the states of the program. The condition of the assertion will be checked at the run time. If the condition does not hold, a runtime_exception will be raised. def bdassert(expr: str):... The bdassert function takes one parameter that is the Birdee source code string for the condition to check. This function will generate the input source code as an expression and also generate the code to check if the generated expression is true . The expr should be a boolean Birdee expression. Here is an example: {@from bdassert import *@} function complicated() as int ... end dim v as int = compilcated() {@bdassert( v!=0 )@} println(int2str(32/v)) The above example uses bdassert to make sure that v is never 0. If it is zero, an exception will be throw. The bdassert function is useful for debugging and testing.","title":"bdassert"},{"location":"Tools/Birdee-playground-(REPL)/","text":"Birdee playground Birdee provides a \"playground\" environment to let you try Birdee code and instantly view the results of each line in your input. The playground is also called REPL (Read-Eval-Print-Loop), this explains what the \"playground\" does: for each line the user input, it executes the line of code and then print the result. Unlike the Birdee compiler, it will not produce an compiled program in a file. Instead, it runs the inputed code immediately. Opening playground The playground is an console application which you can find in $BIRDEE_HOME\\bin\\birdeeplay (Linux) or %BIRDEE_HOME%\\bin\\BirdeePlayground.exe (Windows CMD). Run this program, then you should see the following in the console: Birdee Playground ____ _ __ / __ )(_)________/ /__ ___ / __ / / ___/ __ / _ \\/ _ \\ / /_/ / / / / /_/ / __/ __/ /_____/_/_/ \\__,_/\\___/\\___/ You can try and see Birdee codes here. Type :q to exit. birdee If you cannot open Birdee playground, please check: If the \"BirdeeBinding.dll\", \"BirdeeCompilerCore.dll\" (libBirdeeBinding.so and libBirdeeCompilerCore.so) is in the same directory of the playground executable file. If Python with the required version is installed. For Windows, you need to add the root directory to the \"PATH\" environment variable. Try Birdee code Now you can type in any valid Birdee code. After typing \"Enter\" key, the playground will compile and execute the line. For example, you can define a variable: birdee dim a = 1 Then you can use the variable in an expression. If the code you entered is an expression, the playground will print the type and the value of the result: birdee (a+1)*a int: 2 You can define and use classes/structs and functions. A class: birdee class clsa ........ public v as string ........ public func __init__(v as string) = this.v=v ........ public func printit()= println(v) ........ end birdee dim b = new clsa( hi ) birdee b.printit() hi birdee A function: birdee function addint(a as int, b as int) as int ........ return a+b ........ end functype (int, int) as int: Function addint birdee addint(3,4) int: 7 Even a function template: birdee function add[T](a as T, b as T) as T = a+b (Error type): Function add birdee add(1,2) int: 3 birdee add( 1 , 2 ) birdee.string: 12 You can also import the compiled Birdee modules in the BIRDEE_HOME . Moveover, declaring existing C/C++ functions is allowed: birdee declare function malloc(sz as uint) as pointer functype (uint) as pointer: Function malloc birdee import typedptr:* ........ dim p = mkref[int](malloc(4)) birdee p.set(32) birdee p.get() int: 32 The above code declares a C function - \"malloc\" in the standard C library, which allocates a piece of memory. Then, we import a Birdee module \"typedptr\" and set and get the allocated memory with the \"typedptr\" interface. Special commands There are several special commands in Birdee playground designed to control the playground, which is not valid Birdee code. The commands include: :q - Exit the playground :printir=... - \"...\" can be true or false. This command controls whether playground should print the LLVM IR after it compiles user codes.","title":"Birdee playground"},{"location":"Tools/Birdee-playground-(REPL)/#birdee-playground","text":"Birdee provides a \"playground\" environment to let you try Birdee code and instantly view the results of each line in your input. The playground is also called REPL (Read-Eval-Print-Loop), this explains what the \"playground\" does: for each line the user input, it executes the line of code and then print the result. Unlike the Birdee compiler, it will not produce an compiled program in a file. Instead, it runs the inputed code immediately.","title":"Birdee playground"},{"location":"Tools/Birdee-playground-(REPL)/#opening-playground","text":"The playground is an console application which you can find in $BIRDEE_HOME\\bin\\birdeeplay (Linux) or %BIRDEE_HOME%\\bin\\BirdeePlayground.exe (Windows CMD). Run this program, then you should see the following in the console: Birdee Playground ____ _ __ / __ )(_)________/ /__ ___ / __ / / ___/ __ / _ \\/ _ \\ / /_/ / / / / /_/ / __/ __/ /_____/_/_/ \\__,_/\\___/\\___/ You can try and see Birdee codes here. Type :q to exit. birdee If you cannot open Birdee playground, please check: If the \"BirdeeBinding.dll\", \"BirdeeCompilerCore.dll\" (libBirdeeBinding.so and libBirdeeCompilerCore.so) is in the same directory of the playground executable file. If Python with the required version is installed. For Windows, you need to add the root directory to the \"PATH\" environment variable.","title":"Opening playground"},{"location":"Tools/Birdee-playground-(REPL)/#try-birdee-code","text":"Now you can type in any valid Birdee code. After typing \"Enter\" key, the playground will compile and execute the line. For example, you can define a variable: birdee dim a = 1 Then you can use the variable in an expression. If the code you entered is an expression, the playground will print the type and the value of the result: birdee (a+1)*a int: 2 You can define and use classes/structs and functions. A class: birdee class clsa ........ public v as string ........ public func __init__(v as string) = this.v=v ........ public func printit()= println(v) ........ end birdee dim b = new clsa( hi ) birdee b.printit() hi birdee A function: birdee function addint(a as int, b as int) as int ........ return a+b ........ end functype (int, int) as int: Function addint birdee addint(3,4) int: 7 Even a function template: birdee function add[T](a as T, b as T) as T = a+b (Error type): Function add birdee add(1,2) int: 3 birdee add( 1 , 2 ) birdee.string: 12 You can also import the compiled Birdee modules in the BIRDEE_HOME . Moveover, declaring existing C/C++ functions is allowed: birdee declare function malloc(sz as uint) as pointer functype (uint) as pointer: Function malloc birdee import typedptr:* ........ dim p = mkref[int](malloc(4)) birdee p.set(32) birdee p.get() int: 32 The above code declares a C function - \"malloc\" in the standard C library, which allocates a piece of memory. Then, we import a Birdee module \"typedptr\" and set and get the allocated memory with the \"typedptr\" interface.","title":"Try Birdee code"},{"location":"Tools/Birdee-playground-(REPL)/#special-commands","text":"There are several special commands in Birdee playground designed to control the playground, which is not valid Birdee code. The commands include: :q - Exit the playground :printir=... - \"...\" can be true or false. This command controls whether playground should print the LLVM IR after it compiles user codes.","title":"Special commands"},{"location":"Tools/Compiler-command-line-mannual/","text":"Command line arguments for compiler (birdeec) Birdee compiler can be invoked by command line. The executable file of Birdee compiler should be \"birdeec\" or \"birdeec.exe\". The accepted arguments are listed in the following table. Note that the \"[..]\" means a user input string. Arugment Alias Optional? Explanations -i [file_name] N/A Required The input source file path -o [file_name] N/A Required The output file path -s --script Optional Treat the input source file as a python generative script -e N/A Optional Put the top-level code in a function called \"main\" instead of \"{modulename}.main\" N/A --corelib Optional Prevent the compiler from auto importing the core Birdee modules for the source code N/A --printir Optional Print the LLVM IR to stderr after compilation -p [prefix] N/A Optional Prepend a prefix for each global symbols of the compiled object file N/A --print-import Optional Don't compile the whole file. Print the imported module names and currently compiled module to stdout only. Cannot be used with \"-s\" switch. \"-o\" switch can be omitted when using this switch -O [optimize-level] N/A Optional Set the optimization level of the compiler, optimize-level can be 0~3. \"-O 0\" means no optimization. The larger optimize-level, the more aggressive optimization. By default to be 0 --llvm-opt-start ... --llvm-opt-end N/A Optional Give the arguments between \"--llvm-opt-start\" and \"--llvm-opt-end\" to the LLVM optimizer.","title":"Command line arguments for compiler (birdeec)"},{"location":"Tools/Compiler-command-line-mannual/#command-line-arguments-for-compiler-birdeec","text":"Birdee compiler can be invoked by command line. The executable file of Birdee compiler should be \"birdeec\" or \"birdeec.exe\". The accepted arguments are listed in the following table. Note that the \"[..]\" means a user input string. Arugment Alias Optional? Explanations -i [file_name] N/A Required The input source file path -o [file_name] N/A Required The output file path -s --script Optional Treat the input source file as a python generative script -e N/A Optional Put the top-level code in a function called \"main\" instead of \"{modulename}.main\" N/A --corelib Optional Prevent the compiler from auto importing the core Birdee modules for the source code N/A --printir Optional Print the LLVM IR to stderr after compilation -p [prefix] N/A Optional Prepend a prefix for each global symbols of the compiled object file N/A --print-import Optional Don't compile the whole file. Print the imported module names and currently compiled module to stdout only. Cannot be used with \"-s\" switch. \"-o\" switch can be omitted when using this switch -O [optimize-level] N/A Optional Set the optimization level of the compiler, optimize-level can be 0~3. \"-O 0\" means no optimization. The larger optimize-level, the more aggressive optimization. By default to be 0 --llvm-opt-start ... --llvm-opt-end N/A Optional Give the arguments between \"--llvm-opt-start\" and \"--llvm-opt-end\" to the LLVM optimizer.","title":"Command line arguments for compiler (birdeec)"},{"location":"Tools/bbuild/","text":"The automatic building tool for Birdee - bbuild The Birdee compiler \"birdeec\" only generates object files from Birdee source code, but it does not help you to link it. In large projects, the dependencies among modules could be complicated. Without bbuild, users may resort to Makefile or other building tools to compile and link such projects, which involves manually writing Makefiles or other configuration files to tell the building tool about the dependencies. bbuild aims to free the users from manually managing the building configuration by automatically finding and compiling the dependencies. In addition, bbuild can optionally link the program with all dependencies. Requirements bbuild is a Python3 program. It depends on native compiler tool sets: On Linux, it depends on gcc; On Windows, it depends on MSVC. Make sure these dependencies are installed in your system before using bbuild. To use the linker of MSVC, you need to run bbuild in the Visual Studio x64 Commmand Prompt. What does bbuild do? You should specify a \"root\" module to compile. Given a \"root\" module, bbuild will find all modules the root module directly or indirectly depends on. For all dependent Birdee modules, bbuild first finds any compiled object file of the dependent module. If no compiled object file is found, bbuild searches the Birdee source code using the module name and compiles the found module source code into object file. Finally, if the user requires to link the root module with all dependent modules, bbuild will call the native linker (linker.exe on Windows or gcc on Linux) to link all object files. Like building tools including Makefile, bbuild will check the timestamps of the source code files and the resulting binary files. It will only re-compile the modified source code files since the last build, and skip the unchanged source files. How to use bbuild? python $BIRDEE_HOME/pylib/bbuild.py -i {source_dir} -o {out_dir} [-bs {binary_file_search_path}] [-le {link_executable_target}] [-lc {link_command} ] [-j {thread_num}] root_module1 [other_root_modules...] -i: the source root dir -o: the output object file root dir -le: link to an executable. The path to the link target -bs: binary *.bmm and *.obj/*.o file search root dir. The out_dir specified by \"-o\" switch is automatically added to the binary search path -lc: The extra commands to pass to the linker. It is recommended to add a pair of \"\" around link_command -j: set the number of parallel compilers root_modules: a list of the module names, e.g. org.bird.quail. bbuild will find source from source_root_dir/org/bird/quail.{txt/bdm}. It will also resolve any direct or indirect dependencies of it. You can specify multiple search directories by adding multiple \"-i\", \"-bs\" switches. For any dependent module, bbuild will first search the paths given by \"-bs\" switch. e.g. Given \"-o /home/menooker/bin -bs /home/menooker/birdee\" and a module \"org.bird.quail\", bbuild will search for file \"/home/menooker/birdee/org/bird/quail.bmm\" or \"/home/menooker/bin/org/bird/quail.bmm\". If the binary file is not found, bbuild will try to compile it from the source code. Given \"-i /home/menooker/project\", it will search for source file \"/home/menooker/project/org/bird/quail.{txt,bdm}\". The compiled binary of module will be at \"/home/menooker/bin/org/bird/quail.bmm\". For example, let's compile the main module test_package.b.mod2 (The code can be found in \"tests\" of Birdee source code). The commands and outputs are shown below menooker@DESKTOP:~/Birdee/tests$ cat test_package/b/mod2.txt package test_package.b import test_package.a.mod1:func import logic_obj_cmp:a func() println(a) menooker@DESKTOP:~/Birdee/tests$ find test_package/* test_package/a test_package/a/mod1.txt test_package/b test_package/b/functype_test_lib.txt test_package/b/mod2.txt menooker@DESKTOP:~/Birdee/tests$ ls logic_obj_cmp.txt logic_obj_cmp.txt menooker@DESKTOP:~/Birdee/tests$ python3 $BIRDEE_HOME/pylib/bbuild.py -i . -o linuxbin test_package.b.mod2 -le linuxbin/mod2 -lc -g -lpthead Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./test_package/b/mod2.txt --print-import Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./test_package/a/mod1.txt --print-import Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./logic_obj_cmp.txt --print-import Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./test_package/a/mod1.txt -o linuxbin/test_package/a/mod1.o -l /home/menooker/Birdee/BirdeeHome/blib -l . -l linuxbin Wrote linuxbin/test_package/a/mod1.o Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./logic_obj_cmp.txt -o linuxbin/logic_obj_cmp.o -l /home/menooker/Birdee/BirdeeHome/blib -l . -l linuxbin Wrote linuxbin/logic_obj_cmp.o Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./test_package/b/mod2.txt -o linuxbin/test_package/b/mod2.o -l /home/menooker/Birdee/BirdeeHome/blib -l . -l linuxbin -e Wrote linuxbin/test_package/b/mod2.o Running command gcc -o linuxbin/mod2 -Wl,--start-group /home/menooker/Birdee/BirdeeHome/lib/libBirdeeRuntime.a /home/menooker/Birdee/BirdeeHome/blib/birdee.o linuxbin/test_package/a/mod1.o linuxbin/logic_obj_cmp.o linuxbin/test_package/b/mod2.o -lgc -Wl,--end-group -g -lpthead menooker@DESKTOP:~/Birdee/tests$ find linuxbin/* linuxbin/logic_obj_cmp.bmm linuxbin/logic_obj_cmp.o linuxbin/mod2 linuxbin/test_package linuxbin/test_package/a linuxbin/test_package/a/mod1.bmm linuxbin/test_package/a/mod1.o linuxbin/test_package/b linuxbin/test_package/b/mod2.bmm linuxbin/test_package/b/mod2.o","title":"The automatic building tool for Birdee - bbuild"},{"location":"Tools/bbuild/#the-automatic-building-tool-for-birdee-bbuild","text":"The Birdee compiler \"birdeec\" only generates object files from Birdee source code, but it does not help you to link it. In large projects, the dependencies among modules could be complicated. Without bbuild, users may resort to Makefile or other building tools to compile and link such projects, which involves manually writing Makefiles or other configuration files to tell the building tool about the dependencies. bbuild aims to free the users from manually managing the building configuration by automatically finding and compiling the dependencies. In addition, bbuild can optionally link the program with all dependencies.","title":"The automatic building tool for Birdee - bbuild"},{"location":"Tools/bbuild/#requirements","text":"bbuild is a Python3 program. It depends on native compiler tool sets: On Linux, it depends on gcc; On Windows, it depends on MSVC. Make sure these dependencies are installed in your system before using bbuild. To use the linker of MSVC, you need to run bbuild in the Visual Studio x64 Commmand Prompt.","title":"Requirements"},{"location":"Tools/bbuild/#what-does-bbuild-do","text":"You should specify a \"root\" module to compile. Given a \"root\" module, bbuild will find all modules the root module directly or indirectly depends on. For all dependent Birdee modules, bbuild first finds any compiled object file of the dependent module. If no compiled object file is found, bbuild searches the Birdee source code using the module name and compiles the found module source code into object file. Finally, if the user requires to link the root module with all dependent modules, bbuild will call the native linker (linker.exe on Windows or gcc on Linux) to link all object files. Like building tools including Makefile, bbuild will check the timestamps of the source code files and the resulting binary files. It will only re-compile the modified source code files since the last build, and skip the unchanged source files.","title":"What does bbuild do?"},{"location":"Tools/bbuild/#how-to-use-bbuild","text":"python $BIRDEE_HOME/pylib/bbuild.py -i {source_dir} -o {out_dir} [-bs {binary_file_search_path}] [-le {link_executable_target}] [-lc {link_command} ] [-j {thread_num}] root_module1 [other_root_modules...] -i: the source root dir -o: the output object file root dir -le: link to an executable. The path to the link target -bs: binary *.bmm and *.obj/*.o file search root dir. The out_dir specified by \"-o\" switch is automatically added to the binary search path -lc: The extra commands to pass to the linker. It is recommended to add a pair of \"\" around link_command -j: set the number of parallel compilers root_modules: a list of the module names, e.g. org.bird.quail. bbuild will find source from source_root_dir/org/bird/quail.{txt/bdm}. It will also resolve any direct or indirect dependencies of it. You can specify multiple search directories by adding multiple \"-i\", \"-bs\" switches. For any dependent module, bbuild will first search the paths given by \"-bs\" switch. e.g. Given \"-o /home/menooker/bin -bs /home/menooker/birdee\" and a module \"org.bird.quail\", bbuild will search for file \"/home/menooker/birdee/org/bird/quail.bmm\" or \"/home/menooker/bin/org/bird/quail.bmm\". If the binary file is not found, bbuild will try to compile it from the source code. Given \"-i /home/menooker/project\", it will search for source file \"/home/menooker/project/org/bird/quail.{txt,bdm}\". The compiled binary of module will be at \"/home/menooker/bin/org/bird/quail.bmm\". For example, let's compile the main module test_package.b.mod2 (The code can be found in \"tests\" of Birdee source code). The commands and outputs are shown below menooker@DESKTOP:~/Birdee/tests$ cat test_package/b/mod2.txt package test_package.b import test_package.a.mod1:func import logic_obj_cmp:a func() println(a) menooker@DESKTOP:~/Birdee/tests$ find test_package/* test_package/a test_package/a/mod1.txt test_package/b test_package/b/functype_test_lib.txt test_package/b/mod2.txt menooker@DESKTOP:~/Birdee/tests$ ls logic_obj_cmp.txt logic_obj_cmp.txt menooker@DESKTOP:~/Birdee/tests$ python3 $BIRDEE_HOME/pylib/bbuild.py -i . -o linuxbin test_package.b.mod2 -le linuxbin/mod2 -lc -g -lpthead Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./test_package/b/mod2.txt --print-import Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./test_package/a/mod1.txt --print-import Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./logic_obj_cmp.txt --print-import Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./test_package/a/mod1.txt -o linuxbin/test_package/a/mod1.o -l /home/menooker/Birdee/BirdeeHome/blib -l . -l linuxbin Wrote linuxbin/test_package/a/mod1.o Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./logic_obj_cmp.txt -o linuxbin/logic_obj_cmp.o -l /home/menooker/Birdee/BirdeeHome/blib -l . -l linuxbin Wrote linuxbin/logic_obj_cmp.o Running command /home/menooker/Birdee/BirdeeHome/bin/birdeec -i ./test_package/b/mod2.txt -o linuxbin/test_package/b/mod2.o -l /home/menooker/Birdee/BirdeeHome/blib -l . -l linuxbin -e Wrote linuxbin/test_package/b/mod2.o Running command gcc -o linuxbin/mod2 -Wl,--start-group /home/menooker/Birdee/BirdeeHome/lib/libBirdeeRuntime.a /home/menooker/Birdee/BirdeeHome/blib/birdee.o linuxbin/test_package/a/mod1.o linuxbin/logic_obj_cmp.o linuxbin/test_package/b/mod2.o -lgc -Wl,--end-group -g -lpthead menooker@DESKTOP:~/Birdee/tests$ find linuxbin/* linuxbin/logic_obj_cmp.bmm linuxbin/logic_obj_cmp.o linuxbin/mod2 linuxbin/test_package linuxbin/test_package/a linuxbin/test_package/a/mod1.bmm linuxbin/test_package/a/mod1.o linuxbin/test_package/b linuxbin/test_package/b/mod2.bmm linuxbin/test_package/b/mod2.o","title":"How to use bbuild?"}]}