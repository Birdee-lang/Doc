<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Binding classes - Birdee Language</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../..">Birdee Language</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../..">Welcome</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Birdee Language Mannual <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../Birdee Language Mannual/0010HelloWorld/">1. Hello world!</a>
</li>
                                    
<li >
    <a href="../../Birdee Language Mannual/0020Basics/">2. Language Basics</a>
</li>
                                    
<li >
    <a href="../../Birdee Language Mannual/0030FlowControl/">3. Flow Control</a>
</li>
                                    
<li >
    <a href="../../Birdee Language Mannual/0040ScopeAndName/">4. Scope and names</a>
</li>
                                    
<li >
    <a href="../../Birdee Language Mannual/0050Array/">5. Array</a>
</li>
                                    
<li >
    <a href="../../Birdee Language Mannual/0060Class/">6. Class</a>
</li>
                                    
<li >
    <a href="../../Birdee Language Mannual/0070Import/">7. Modules and Imports</a>
</li>
                                    
<li >
    <a href="../../Birdee Language Mannual/0080Template/">8. Templates</a>
</li>
                                    
<li >
    <a href="../../Birdee Language Mannual/0090Script/">9. Compile-time scripts</a>
</li>
                                    
<li >
    <a href="../../Birdee Language Mannual/0100Cpp/">10. Interoperability with C/C++</a>
</li>
                                    
<li >
    <a href="../../Birdee Language Mannual/0110Functional/">11. Functional Programming</a>
</li>
                                    
<li >
    <a href="../../Birdee Language Mannual/0120Exception/">12. Exception handling</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Python Binding <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../0010.Overview/">Python binding for Birdee</a>
</li>
                                    
<li >
    <a href="../0020.Functions/">Birdee binding Functions for Python</a>
</li>
                                    
<li class="active">
    <a href="./">Binding classes</a>
</li>
                                    
<li >
    <a href="../0040.HighLevelAPI/">High level APIs</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Tools <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../Tools/Birdee-playground-(REPL)/">Birdee playground</a>
</li>
                                    
<li >
    <a href="../../Tools/Compiler-command-line-mannual/">Command line arguments for compiler (birdeec)</a>
</li>
                                    
<li >
    <a href="../../Tools/bbuild/">The automatic building tool for Birdee - bbuild</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../0020.Functions/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../0040.HighLevelAPI/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#binding-classes">Binding classes</a></li>
            <li><a href="#error-classes">Error classes</a></li>
            <li><a href="#containers-and-ownership-pointers">Containers and Ownership pointers</a></li>
            <li><a href="#ast-classes">AST classes</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="binding-classes">Binding classes</h1>
<p>This chapter introduces the classes that Python scripts can use in Birdee. We use Python type hint syntax to show the members of the classes.</p>
<h2 id="error-classes">Error classes</h2>
<pre><code class="python">class CompileError:
    linenumber: int #readonly, the line number of the error
    pos: int #readonly, the position of characters in the line
    msg: str #readwrite, the error message
</code></pre>

<p>The compile error that was actually raised. It can be got from function <code>get_compile_error</code>. </p>
<pre><code class="python">class TokenizerError:
    linenumber: int #readonly, the line number of the error
    pos: int #readonly, the position of characters in the line
    msg: str #readwrite, the error message
</code></pre>

<p>The compile error that was actually raised. It can be got from function <code>get_tokenizer_error</code>.</p>
<h2 id="containers-and-ownership-pointers">Containers and Ownership pointers</h2>
<h3 id="ownership-pointer">Ownership pointer</h3>
<pre><code class="python">class SOMEUniquePtr:
    def get() -&gt; SOME
</code></pre>

<p>The ownership pointer of the AST class <code>SOME</code>. <code>SOME</code> above can be replaced by some AST node classes, which can be <code>StatementAST</code>, etc. This UniquePtr class represents the ownership of an AST node. If the ownership is not transfered to another AST node, the AST node will be destroyed when Python runtime reclaim the memory of this ownership pointer object. A reference to AST node is a pointer that has no ownership of the node. You can use <code>get()</code> on a ownership pointer to get the reference of the AST node. You cannot get fields or call member functions directly on ownership pointers. Instead, you can operate on a reference by calling <code>get()</code>. For more information, please refer to the "Compile time scripts" chapter of Birdee language manual.</p>
<p>For most of the sub-classes of StatementAST and ExprAST, if you get a field of them with type <code>StatementAST</code>, you will get a reference. If you assign a value to the <code>StatementAST</code> typed fields, you usually need a <code>StatementASTUniquePtr</code> and the field will take over the ownership.</p>
<h3 id="list">List</h3>
<pre><code class="python">class SOMEList:
    def pop_back(): ... # remove the last item
    def push_back(itm: SOMEUniquePtr): ... # append an item to the list, will take the owner ship of the itm
    def __getitem__(idx: int): ...
    def __setitem__(idx: int, itm: SOMEUniquePtr): ... #will take the ownership of the itm
    def __len__() -&gt; int: ...
    def __iter__(): ...
</code></pre>

<p>A list of AST nodes. <code>SOME</code> above can be replaced by some AST node classes, which can be <code>MemberFunctionDef</code>, <code>FieldDef</code>, etc. You can use the list as a normal Python list. The <code>[...]</code> and <code>for ... in ...</code> are allowed on AST node lists. </p>
<h2 id="ast-classes">AST classes</h2>
<h3 id="basictype">BasicType</h3>
<pre><code class="python">class BasicType(Enum):
    CLASS
    NULL
    FUNC
    VOID
    BYTE
    SHORT
    INT
    LONG
    ULONG
    UINT
    FLOAT
    DOUBLE
    BOOLEAN
    POINTER
    PACKAGE
</code></pre>

<p>It is an enum which represents the basic types.</p>
<h3 id="resolvedtype">ResolvedType</h3>
<pre><code class="python">class ResolvedType:
    base: BasicType # readonly, the base type of the resolved type
    index_level: int # readwrite, is it an array? 0 for not array, 1 for 1D array and so on
    def is_class() -&gt; bool: ... # if it is a class (not struct)
    def is_integer() -&gt; bool: ... # if it is an integer
    def get_detail() -&gt; ???: ... # get the detailed info of the type. See comments below.
    def set_detail(_base: BasicType, detail): ... # set the basic type and details
    def __init__():...
    def __str__() -&gt; str: ... # convert the type into a string
    def __eq__(other: ResolvedType) -&gt; bool: ... # if another type is equal to this
</code></pre>

<p>The internal class that represents a resolved type. It basically contains three parts.
 * <code>base</code> is the base type of the type. If it is a basic type (e.g. int), this field should be a enum value (e.g. <code>BasicType.INT</code>). If the type is a class/struct, this field should be <code>BasicType.CLASS</code>. The detailed ClassAST of the referenced class can be found by <code>detail</code>. If the base type is a <code>BasicType.FUNC</code>, the type is a functype or closure.
 * <code>index_level</code> is the dimension of the array. If it is 0, the type is not an array. If it is larger than 0, the type is a <code>index_level</code>-D array of type specified by <code>base</code>.
 * <code>detail</code> is the detailed information of the type. If the type is a class/struct type, <code>get_detail()</code> will return a reference to ClassAST of the referenced class. If the type is a functype or closure, <code>get_detail()</code> will return a reference to PrototypeAST.</p>
<h3 id="sourcepos">SourcePos</h3>
<pre><code class="python">class SourcePos:
    source_idx: int #readwrite, a unique index for the source file name
    line: int #readwrite, the line number
    pos: int #readwrite, the position of characters in the line
</code></pre>

<p>This class represents a position in the source code. Most of the AST nodes contains a SourcePos object to mark the position of the AST in the source file.</p>
<h3 id="prototypeast">PrototypeAST</h3>
<pre><code class="python">class PrototypeAST:
    prefix: str # readonly. returns the symbol prefix of the Function definition. 
    # For example, if the function is defined in a module &quot;com.a&quot;, the prefix should be &quot;com.a.&quot; 
    name: str # readwrite. the function name or function type name
    return_type: ResolvedType # readwrite. The return type of the function
    args: VariableSingleDefASTList # readonly. The argument definitions
    is_closure: bool # readwrite. if the function is a closure
    cls: ClassAST # readwrite. The class where the function is defined. Can be None if is not a member function
</code></pre>

<p>This class holds the information of a function type (functype or closure). It also holds information of a function definition.</p>
<h3 id="template-parameters-and-arguments">Template Parameters and Arguments</h3>
<p>Birdee's function and class templates can have placeholders for types and constant values. The placeholders which are declared in the template definition is called "template parameters" in Birdee compiler. For example, the class</p>
<pre><code class="vb">class Templ[T1,T2, v as int]

end
</code></pre>

<p>has three template parameters, namely T1, T2 and v. The first two are type paramters and the last is constant value parameter. In Python binding, you can access the parameters via the <code>TemplateParameter</code>, <code>TemplateParameters_ClassAST</code> and <code>TemplateParameters_FunctionAST</code>.</p>
<p>The class <code>TemplateParameter</code> represents one single template parameter. <code>TemplateParameters_ClassAST</code> and <code>TemplateParameters_FunctionAST</code> are the template parameter lists for classes and functions</p>
<pre><code class="python">class TemplateParameter:
    type: BasicType # readonly. It is CLASS if the template parameter is a type parameter
    # Otherwise, it is a constant value parameter with the type
    name: str # readwrite. The name of the parameter 

class TemplateParameters_ClassAST: #TemplateParameters_FunctionAST is the same
    params: TemplateParameterList # readonly
    source: str # readonly. The source code of the template
</code></pre>

<p>On the other hand, the template arguments are the acutal types/values that are given to the templates when using an instance of template.</p>
<pre><code class="python">class TemplateArgument:
    class TemplateArgumentType(Enum):
        TEMPLATE_ARG_TYPE
        TEMPLATE_ARG_EXPR

    kind: TemplateArgumentType # readwrite, the kind of the argument, type? value?
    resolved_type: ResolvedType # readwrite. The resolved type for the type argument or the value
    expr: StatementAST # readwrite. The value expression of the argument. Writing to it needs an ownership pointer and will take the ownership of it

</code></pre>

<h3 id="ast-base-classes">AST base classes</h3>
<pre><code class="python">class StatementAST:
    pos: SourcePos # readwrite
    def run(func): ... # run a function &quot;func&quot; on the sub AST nodes of this node
    def copy(func) -&gt; StatementASTUniquePtr: ... # copy this AST node

class ExprAST(StatementAST):
    resolved_type: ResolvedType #readwrite, the type of the expression
    def is_lvalue() -&gt; bool: ... # returns true if the expression is an LValue (has an address)
</code></pre>

<p>These two classes are super classes for most of the AST nodes.</p>
<h3 id="functionast">FunctionAST</h3>
<p>This class represents a function definition (with body), or a function declaration (without body).</p>
<pre><code class="python">class FunctionAST(ExprAST):
    body: StatementASTList # readonly, the list of statement AST of the body of the function
    proto: PrototypeAST # readonly, the prototype of the function
    capture_on_stack: bool # readwrite, if the captured variables of the function is stored on stack
    is_declare: bool # readwrite, if the function is a declaration or imported from other module
    is_template_instance: bool # readwrite, if the function is an instance of template function
    is_imported: bool # readwrite, if the function is imported from other modules
    template_instance_args: TemplateArgumentList # readonly, if is an template instance, the template argument list; Otherwise None
    template_source_func: FunctionAST # readonly, if is an template instance, the source template function; Otherwise None
    capture_this: bool # readwrite, if the function captures &quot;this&quot;
    is_template: bool # readonly, if the function is a template function
    parent: FunctionAST # readonly, if is an closure function, the function that contains the current function; Otherwise None
    link_name: str # readwrite, the link-time name for the function. 
    # Specifiled by the &quot;alias&quot; clause of function definition
    template_param: TemplateParameters_FunctionAST # readonly, if is a template function, the template parameters; Otherwise, None
</code></pre>

<h3 id="annotationstatementast">AnnotationStatementAST</h3>
<p>An annotated statement is wrapped in an AnnotationStatementAST. For example, Birdee code</p>
<pre><code class="vb">@some
function f()
end
</code></pre>

<p>has an AnnotationStatementAST which contains a FunctionAST.</p>
<pre><code class="python">class AnnotationStatementAST(StatementAST):
    @static
    def new(annotations: list, impl: StatementASTUniquePtr): ... 
    #static function, create a new AnnotationStatementAST node. &quot;annotations&quot; is a list of string that are for annotations
    #&quot;impl&quot; is the annotated AST node. Will take the ownership of &quot;impl&quot;
    is_expr: bool # readwrite, if this annotated statement is an expression
    anno: list # readwrite, a list of annotations in string
    impl: StatementASTUniquePtr # the ownership pointer of the annotated AST. Reading this field will yield a reference
</code></pre>

<h3 id="scriptast">ScriptAST</h3>
<p>The AST for the embeded scripts, i.e., between <code>{@ @}</code>.</p>
<pre><code class="python">class ScriptAST(ExprAST):
    @static
    def new(script: str, is_top_level:bool):... # creates a new ScriptAST. &quot;is_top_level&quot; specifies whether is script is in the top level.
    stmt: StatementASTList # readonly, the generated statement AST by the script
    script: str # readwrite, the script
</code></pre>

<h3 id="resolvedidentifierexprast">ResolvedIdentifierExprAST</h3>
<pre><code class="python">class ResolvedIdentifierExprAST(ExprAST):
    def is_mutable()-&gt; bool : ... # is this value mutable?
</code></pre>

<p>This class is an abstract class, which represents an simple primary expression (function name or variable), or a number literal, etc.</p>
<h3 id="stringliteralast">StringLiteralAST</h3>
<pre><code class="python">class StringLiteralAST(ResolvedIdentifierExprAST):
    @static
    def new(value: str): ... # create a new StringLiteralAST 
    value: str  # the string value of the literal
</code></pre>

<p>This class of AST represents string literals, usually surrounded by a pair of <code>"</code>, like <code>"Hello"</code> in Birdee code.</p>
<h3 id="numberexprast">NumberExprAST</h3>
<p>The AST for number literals. e.g. <code>1.23</code>.</p>
<pre><code class="python">class NumberExprAST(ResolvedIdentifierExprAST):
    @static
    def new(type: BasicType, value): ... # creates a new number with given type
    value: ??? # readwrite, the value of the number literal
    type: BasicType # readwrite, the type of the number literal
    def __str__()-&gt;str : ... # convert the value to a Python string
</code></pre>

<h3 id="arrayinitializerexprast">ArrayInitializerExprAST</h3>
<pre><code class="python">class ArrayInitializerExprAST(ExprAST):
    @static
    def new(impl: list): ... # create an array from a list of StatementASTUniquePtr 
    values: ExprASTList # readonly, the list of expressions in the array
</code></pre>

<p>This class of AST represents array literals, like <code>[1,2,3,4]</code>.</p>
<h3 id="returnast">ReturnAST</h3>
<pre><code class="python">class ReturnAST(StatementAST):
    @static
    def new(retv: StatementASTUniquePtr): ... # create a return statement from an expression. Takes the ownership
    expr: StatementASTUniquePtr # readwrite, the expression that is returned. Can be None if returns void.
</code></pre>

<p>This class of AST represents the return statements, like <code>return 0</code>.</p>
<h3 id="identifierexprast">IdentifierExprAST</h3>
<pre><code class="python">class IdentifierExprAST(ExprAST):
    @static
    def new(variable_name: str):... #create a new identifier expression. The variable name of the expression is given by the parameter
    name: str # readwrite, the variable name
    impl: StatementASTUniquePtr # readwrite, the resolved expression AST. The values of this field 
    # should be a subclass of ResolvedIdentifierExprAST
</code></pre>

<p>This class represents an identifier expression. For example, </p>
<pre><code class="vb">a = b
</code></pre>

<p>here <code>a</code> and <code>b</code> are two IdentifierExprASTs. If <code>b</code> is resolved as an variable, the <code>impl</code> field will be a LocalVarExprAST. If <code>b</code> is an function name, the <code>impl</code> field will be a ResolvedFuncExprAST.</p>
<h3 id="resolvedfuncexprast">ResolvedFuncExprAST</h3>
<pre><code class="python">class ResolvedFuncExprAST(ResolvedIdentifierExprAST):
    funcdef: FunctionAST # readwrite, the referenced function 
</code></pre>

<p>This AST is used in IdentifierExprAST to represent a function.</p>
<h3 id="thisexprast">ThisExprAST</h3>
<pre><code class="python">class ThisExprAST(ExprAST):
    @static
    def new():... #create a new this expression
</code></pre>

<h3 id="boolliteralexprast">BoolLiteralExprAST</h3>
<pre><code class="python">class BoolLiteralExprAST(ExprAST):
    @static
    def new(value: bool):... # create a new boolean literal expression
    value: bool # readwrite, the value of the boolean literal
</code></pre>

<p>The AST for boolean literal, e.g. <code>true</code></p>
<h3 id="ifblockast">IfBlockAST</h3>
<pre><code class="python">class IfBlockAST(StatementAST):
    cond: ExprAST # readonly, the expression to be tested in an &quot;if&quot;
    if_true: StatementASTList # readonly, the list of statements for the &quot;true&quot; condition of the &quot;if&quot; statement
    if_falue: StatementASTList # readonly, the list of statements for the &quot;else&quot; block
</code></pre>

<h3 id="forblockast">ForBlockAST</h3>
<pre><code class="python">class ForBlockAST(StatementAST):
    is_dim: bool # readwrite, if the for loop's loop variable is defined in the for-statement
    init_value: StatementASTUniquePtr # readwrite, if is_dim, the variable definition (VariableSingleDefAST).
    # Otherwise, the initial value of the for loop varaiable
    loop_var: ExprAST # readwrite, if is_dim==false, the variable definition of the loop variable. Otherwise, None
    till: StatementASTUniquePtr # readwrite, the expression that marks the end of the loop-variable
    inclusive: bool # readwrite, if true, it is a &quot;for ... to ...&quot;. Otherwise, it is a &quot;for ... till ...&quot;
    block: StatementASTList # readwrite, the for loop body
</code></pre>

<p>There are two kinds of for-loops in Birdee. One have the loop varaible defined in the "for" statement. The other does not have.</p>
<pre><code class="vb">for dim i=0 to 3
    ...
end

for j=0 to 3
    ...
end
</code></pre>

<p>The difference of these two kinds of for-loop is reflected in the <code>is_dim</code> field of the AST.</p>
<h3 id="whileblockast">WhileBlockAST</h3>
<pre><code class="python">class WhileBlockAST(StatementAST):
    cond: StatementASTUniquePtr # readwrite, the contition expression of the while loop
    block: StatementASTList # readonly, the body of the while loop
</code></pre>

<h3 id="loopcontrolast">LoopControlAST</h3>
<pre><code class="python">class LoopControlType(Enum):
    BREAK
    CONTINUE

class LoopControlAST(StatementAST):
    @static
    def new(type: LoopControlType):... # create a new &quot;break&quot; or &quot;continue&quot; statement
    type: LoopControlType # readwrite, the kind of the loop control
</code></pre>

<p>This AST is either "break" or "continue"</p>
<h3 id="binaryexprast">BinaryExprAST</h3>
<p>The expressions that applies an operator on two expressions.</p>
<pre><code class="python">class BinaryOp(Enum):
    BIN_MUL              # *
    BIN_DIV              # /
    BIN_MOD              # %
    BIN_ADD              # +
    BIN_MINUS            # -
    BIN_LT               # &lt;
    BIN_GT               # &gt;
    BIN_LE               # &lt;=
    BIN_GE               # &gt;=
    BIN_EQ               # ==
    BIN_NE               # !=
    BIN_CMP_EQ           # ===
    BIN_CMP_NE           # !==  
    BIN_AND              # &amp;
    BIN_XOR              # ^
    BIN_OR               # |
    BIN_LOGIC_AND        # &amp;&amp;
    BIN_LOGIC_OR         # ||
    BIN_ASSIGN           # =

class BinaryExprAST(ExprAST):
    @static
    def new(op: BinaryOp, lhs: StatementASTUniquePtr, rhs: StatementASTUniquePtr): ...
    #create a new binary expression: lhs op rhs
    is_overloaded: bool # readwrite, if this binary expression is an overloaded function call to a function
    lhs: StatementASTUniquePtr # readwrite, the left hand side expression
    rhs: StatementASTUniquePtr # readwrite, the right hand side expression
    op: BinaryOp # readwrite the operation on the expressions
</code></pre>

<h3 id="unaryexprast">UnaryExprAST</h3>
<p>The expressions that applies an operator on one expression.</p>
<pre><code class="python">class UnaryOp(Enum):
    UNA_NOT        # !
    UNA_ADDRESSOF  # addressof
    UNA_POINTEROF  # pointerof
    UNA_TYPEOF     # typeof

class UnaryExprAST(ExprAST):
    is_overloaded: bool # readwrite, if the expression is an overloaded function call
    # Otherise, None
    arg: StatementASTUniquePtr # the expression that the operator applies to
    op: UnaryOp # the operator
</code></pre>

<h3 id="functiontemplateinstanceexprast">FunctionTemplateInstanceExprAST</h3>
<p>The function template instance expression. For example in the code:</p>
<pre><code>add[int,long](1,2)
</code></pre>

<p>The expression <code>add[int,long]</code> is a function template instance.</p>
<pre><code class="python">class FunctionTemplateInstanceExprAST(ExprAST):
    expr: UniquePtrStatementAST # readwrite, the function template
    instance: FunctionAST # readwrite, the function template instance
</code></pre>

<h3 id="indexexprast">IndexExprAST</h3>
<p>The index expression or function template instance expression with only one template parameter.</p>
<pre><code class="python">class IndexExprAST(ExprAST):
    expr: UniquePtrStatementAST # readwrite, the indexed expression (before [...])
    index: UniquePtrStatementAST # readwrite, the index (within [...])
    template_inst: UniquePtrStatementAST # readwrite, if is a template, the template instance expression.
    # otherwise, None
    def is_template_instance()-&gt;bool: ... # returns if it is a function template instance

</code></pre>

<h3 id="callexprast">CallExprAST</h3>
<p>The AST for function calls.</p>
<pre><code class="python">class CallExprAST(ExprAST):
    callee: UniquePtrStatementAST # readwrite, the callee expression (before (...) )
    args: StatementASTList # readonly, arguments (within (...) )
</code></pre>

<h3 id="variablesingledefast">VariableSingleDefAST</h3>
<p>The AST which defines a single variable. Corresponds to <code>dim</code> statements.</p>
<pre><code class="python">class VariableSingleDefAST(StatementAST):
    # the types of captures of a variable
    class CaptureType(Enum):
        CAPTURE_NONE   # not captured
        CAPTURE_REF    # capturing reference to the parent capture object
        CAPTURE_VAL    # capturing the values to the parent capture object
    name: str # readwrite, the name of the variable
    value: StatementASTUniquePtr # readwrite, the initial value of the variable. Can be None
    resolved_type: ResolvedType # readwrite, the type of the variable
    capture_import_type: CaptureType # readwrite, how the captured variable is imported from parent function
    capture_import_idx: int # readwrite, the capture index within the parent function
    capture_export_type: CaptureType # readwrite, how the captured variable is exported to child functions
    capture_export_idx: int # readwrite, the capture index within capture object for the child functions
</code></pre>

<h3 id="variablemultidefast">VariableMultiDefAST</h3>
<p>The AST that contains multiple variable definitions.</p>
<pre><code class="python">class VariableMultiDefAST(StatementAST):
    lst: VariableSingleDefASTList # readonly, the variable list
</code></pre>

<h3 id="localvarexprast">LocalVarExprAST</h3>
<p>The AST used by IdentifierExprAST to reference variables.</p>
<pre><code class="python">class LocalVarExprAST(ResolvedIdentifierExprAST):
    @static
    def new(v: VariableSingleDefAST):... # creates a new LocalVarExprAST
    vardef: VariableSingleDefAST # readwrite, the variable definition
</code></pre>

<h3 id="functiontoclosureast">FunctionToClosureAST</h3>
<p>The AST automatically generated by compiler to convert a function to a closure.</p>
<pre><code class="python">class FunctionToClosureAST(ExprAST):
    func: StatementASTUniquePtr # readwrite, the function/functype expression to be converted
</code></pre>

<h3 id="tryblockast">TryBlockAST</h3>
<p>The AST for "try ... catch ..." block. A try block may contain several catch variables to catch different types of exception. There are also the same number of "catch" blocks in the AST.</p>
<pre><code class="python">class TryBlockAST(StatementAST):
    try_block: StatementASTList # readonly, try block
    catch_variables: VariableSingleDefASTList # readonly, the definitions of the catch variables
    def get_catch_block(idx: int) -&gt; StatementASTList : ... 
    # get a catch block. The index is from 0 to len(catch_variables) - 1
</code></pre>

<h3 id="throwast">ThrowAST</h3>
<pre><code class="python">class ThrowAST(StatementAST):
    expr: StatementASTUniquePtr # readwrite, the throw expression
</code></pre>

<h3 id="class-asts">Class ASTs</h3>
<pre><code class="python">class AccessModifier(Enum):
    PUBLIC
    PRIVATE

class FieldDef:
    @static
    def new(index: int, access: AccessModifier, vdef: StatementASTUniquePtr) -&gt; FieldDefUniquePtr: ...
    # creates a new field, with given index, modifier and the variable definition (given by vdef)
    index: int # readwrite, the index of the field within the class
    access: AccessModifier # readwrite, the access modifier
    decl: StatementASTUniquePtr # readwrite, should be VarialeSingleDefAST. The variable definition

class MemberFunctionDef:
    @static
    def new(access: AccessModifier, fdef: StatementASTUniquePtr) -&gt; MemberFunctionDef: ...
    # creates a new field, with modifier and the FunctionAST (given by fdef)
    access: AccessModifier # readwrite, the access modifier
    decl: StatementASTUniquePtr # readwrite, should be FunctionAST. The function definition

class ClassAST(StatementAST):
    name: str # readwrite, the name of the class
    fields: FieldDefList # readonly, the list of fields
    funcs: MemberFunctionDefList # readonly, the list of member functions
    template_instance_args: TemplateArgumentList # readonly, the list of the template arguement if it is a template instance
    template_source_class: ClassAST # readonly, the template source AST if it is a template instance
    template_param: TemplateParameters_ClassAST # readonly, the template parameters if it is a template
    needs_rtti: bool # readwrite, if the class has RTTI enabled
    is_struct: bool # readonly, if it is a struct instead of a class
    parent_class: ClassAST # readonly, the parent class that this class inherits from
    def is_template_instance() -&gt; bool: ... # returns if it is a template instance
    def is_template() -&gt; bool: ... # returns if it is a template
    def get_unique_name()-&gt; str: ... # returns the fully qualified name of the class
    def find_field(name: str) -&gt; (int,FieldDef): ... # find a field by name from this class. 
    # returns a tuple (int, FieldDef). The int is the number of levels of parents where the field is found.
    # the returned FieldDef may not be in the current class
</code></pre>

<h3 id="newexprast">NewExprAST</h3>
<p>The AST for <code>new</code> AST, including newing an array or an object. </p>
<pre><code class="python">class NewExprAST(ExprAST):
    args: StatementASTList # readonly, the list of arguments/dimensions to the new expression
    func: FunctionAST # readwrite, the constructor function to be called
</code></pre>

<h3 id="memberexprast">MemberExprAST</h3>
<p>The AST for referencing members of an object, or functions/variables imported from other modules.</p>
<pre><code class="python">class MemberExprAST(ResolvedIdentifierExprAST):
    class MemberType(Enum):
        ERROR
        PACKAGE           # if it is an package. e.g. in &quot;mod1.mod2.v1&quot;, &quot;mod1.mod2&quot; is of type &quot;PACKAGE&quot;
        FIELD             # a field of an object
        FUNCTION          # a member function of an object
        IMPORTED_DIM      # an imported variable of other modules
        VIRTUAL_FUNCTION  # a virtual function of an object, will read the vtable to generate the callee
        IMPORTED_FUNCTION # a function of an imported module

    @static
    def new(obj: StatementASTUniquePtr, name: str): ... # creates a new member expr &quot;obj.name&quot;
    @static
    def new_func_member(obj: StatementASTUniquePtr, member: MemberFunctionDef): ... # creates a new member function expr

    kind: MemberType # the kind of the member
    obj: StatementASTUniquePtr # the object
    # the following fields can only be read when this class actually stores that kind of value
    # you can get the kind of the exact value by &quot;kind&quot; field
    func: MemberFunctionDef
    field: FieldDef
    imported_func: FunctionAST
    import_dim: VariableSingleDefAST
    def to_string_array()-&gt;list: ... # convert the member expr chain to a list of python string
</code></pre>

<h3 id="number-cast-ast">Number Cast AST</h3>
<p>This is a class of AST classes. Each converts a number type from another. The FROM and TO in the code below are two number types.</p>
<pre><code class="python">class CastNumberExpr_FROM_TO(ExprAST):
    @static
    def new(expr: StatementASTUniquePtr):... # creates a new Number Cast AST
    expr: StatementASTUniquePtr # the expression to be converted
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
